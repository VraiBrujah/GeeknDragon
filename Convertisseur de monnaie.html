<?php
// EnchantDragon — Convertisseur de monnaie (PHP + JS)
// Déposez ce fichier dans votre thème / page. Adapte les chemins CSS/JS si besoin.
?><!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EnchantDragon — Convertisseur de monnaie</title>

  <!-- Styles Geek&Dragon -->
  <link rel="stylesheet" href="/css/boutique-premium.css">
  <link rel="stylesheet" href="/css/styles.css">

  <style>
    /* Conteneur global centré, thème sombre existant */
    .converter-wrap{max-width:1100px;margin:0 auto;padding:1.25rem;}
    .converter-card{
      background:var(--boutique-card);
      border:1px solid var(--boutique-border);
      border-radius:var(--boutique-radius-lg);
      box-shadow:var(--boutique-shadow-md);
      padding:1.25rem;
      color:var(--boutique-text);
    }
    .converter-card h2{
      font-family:'Cinzel',serif; font-weight:700; text-align:center;
      color:var(--boutique-text); margin:0 0 1rem;
    }

    /* Monnaie source — une seule ligne centrée */
    .source-row{
      display:flex; flex-wrap:nowrap; justify-content:center; align-items:flex-end;
      gap:var(--boutique-space-lg); overflow-x:auto; padding:0.25rem 0.5rem;
    }
    .source-item{ display:flex; flex-direction:column; align-items:center; min-width:150px; }
    .source-item label{
      color:var(--boutique-text-accent); font-weight:600; margin-bottom:.35rem; text-align:center;
    }
    .src-input{
      width:140px; text-align:center;
      background:var(--boutique-bg); color:var(--boutique-text);
      border:1px solid var(--boutique-border);
      border-radius:var(--boutique-radius-md);
      padding:.6rem .75rem; font-size:1rem;
      transition:var(--boutique-transition-fast);
    }
    .src-input:focus{ outline:none; border-color:var(--boutique-primary);
      box-shadow:0 0 0 3px rgba(139,92,246,.25); }

    /* Tables / blocs résultats */
    .surface-soft{
      background:var(--boutique-surface);
      border:1px solid var(--boutique-border);
      border-radius:var(--boutique-radius-lg);
      padding:1rem; color:var(--boutique-text);
    }
    .results-grid{ display:grid; gap:1rem; }
    @media(min-width:900px){ .results-grid{ grid-template-columns:1fr; } }

    /* Tableau dynamique */
    .table{ width:100%; border-collapse:collapse; }
    .table th,.table td{ padding:.6rem .75rem; border-bottom:1px solid var(--boutique-border); }
    .table th{ color:var(--boutique-text-accent); text-align:center; }
    .table td{ text-align:center; }
    .table td:first-child,.table th:first-child{ text-align:left; }

    /* Équivalences compactes (1 ligne par métal) */
    .equiv-row{ display:grid; grid-template-columns:170px 1fr; gap:.5rem; align-items:start; }
    .equiv-row strong{ color:var(--boutique-text-accent); text-align:center; display:block; }
    .equiv-text{ color:var(--boutique-text); }

    /* Phrase finale */
    .minimal-phrase{
      text-align:center; color:var(--boutique-text); line-height:1.6;
      background:var(--boutique-gradient-card);
      border:1px solid var(--boutique-border); border-radius:var(--boutique-radius-lg);
      padding:1rem;
    }

    /* Masquage quand pas de données */
    .is-hidden{ display:none !important; }
  </style>
</head>
<body>

<section class="shop-section">
  <div class="converter-wrap">
    <!-- Monnaie source -->
    <div class="converter-card rim-gold">
      <h2>Monnaie source</h2>
      <div class="source-row" id="sourceRow">
        <div class="source-item">
          <label for="in-cp">Cuivre</label>
          <input id="in-cp" class="src-input" type="text" inputmode="numeric" pattern="[0-9]*" value="0" autocomplete="off">
        </div>
        <div class="source-item">
          <label for="in-sp">Argent</label>
          <input id="in-sp" class="src-input" type="text" inputmode="numeric" pattern="[0-9]*" value="0" autocomplete="off">
        </div>
        <div class="source-item">
          <label for="in-ep">Électrum</label>
          <input id="in-ep" class="src-input" type="text" inputmode="numeric" pattern="[0-9]*" value="0" autocomplete="off">
        </div>
        <div class="source-item">
          <label for="in-gp">Or</label>
          <input id="in-gp" class="src-input" type="text" inputmode="numeric" pattern="[0-9]*" value="0" autocomplete="off">
        </div>
        <div class="source-item">
          <label for="in-pp">Platine</label>
          <input id="in-pp" class="src-input" type="text" inputmode="numeric" pattern="[0-9]*" value="0" autocomplete="off">
        </div>
      </div>
    </div>

    <div class="results-grid mt-3h">
      <!-- Conversion du trésor -->
      <div class="surface-soft is-hidden" id="convCard">
        <h2 style="text-align:center;margin-top:0">Conversion du trésor total — métal × multiplicateur</h2>
        <div class="table-wrap">
          <table class="table" id="convTable">
            <thead><tr id="convHead"></tr></thead>
            <tbody id="convBody"></tbody>
          </table>
        </div>
      </div>

      <!-- Équivalences totales par métal -->
      <div class="surface-soft is-hidden" id="equivCard">
        <h2 style="text-align:center;margin-top:0">Équivalences totales par métal</h2>
        <div id="equivList" class="stack-sm"></div>
      </div>

      <!-- Représentation minimale — complète -->
      <div class="surface-soft is-hidden" id="minimalCard">
        <h2 style="text-align:center;margin-top:0">Représentation minimale — complète</h2>
        <p class="minimal-phrase" id="minimalText">—</p>
      </div>
    </div>
  </div>
</section>

<script>
(() => {
  "use strict";

  // --- Config (en pièces de cuivre)
  const RATES = { "Cuivre":1, "Argent":10, "Électrum":50, "Or":100, "Platine":1000 };
  const COINS = ["Platine","Or","Électrum","Argent","Cuivre"]; // noblesse décroissante
  const MULTS = [1,10,100,1000,10000];            // pour le tableau
  const MULTS_DESC = [10000,1000,100,10,1];       // pour les décompositions
  const VOWELS = "AEIOUYÂÀÄÉÈÊËÎÏÔÖÙÛÜŒaeiouyâàäéèêëîïôöùûüœ";
  const nf = new Intl.NumberFormat("fr-FR");

  // Pré-calcul des 25 dénominations pour la minimisation (triées grand->petit)
  const TOKENS = [];
  for (const coin of COINS) {
    for (const m of MULTS_DESC.slice().reverse().reverse()) {} // no-op to please linter
  }
  for (const coin of COINS) {
    for (const m of MULTS_DESC) {
      TOKENS.push({ coin, mult:m, value: RATES[coin]*m });
    }
  }
  TOKENS.sort((a,b)=> b.value - a.value || COINS.indexOf(a.coin)-COINS.indexOf(b.coin));

  // --- DOM
  const inputs = {
    "Cuivre":   document.getElementById("in-cp"),
    "Argent":   document.getElementById("in-sp"),
    "Électrum": document.getElementById("in-ep"),
    "Or":       document.getElementById("in-gp"),
    "Platine":  document.getElementById("in-pp"),
  };
  const convCard  = document.getElementById("convCard");
  const convHead  = document.getElementById("convHead");
  const convBody  = document.getElementById("convBody");
  const equivCard = document.getElementById("equivCard");
  const equivList = document.getElementById("equivList");
  const minimalCard = document.getElementById("minimalCard");
  const minimalText = document.getElementById("minimalText");

  // --- Helpers
  const toInt = v => (v && /^[0-9]+$/.test(v)) ? parseInt(v,10) : 0;
  const fmt = n => nf.format(n);
  const pieceWord = q => q===1 ? "pièce" : "pièces";
  const articleDe = coin => VOWELS.includes(coin[0]) ? ("d’"+coin.toLowerCase()) : ("de "+coin.toLowerCase());
  const joinEt = arr => arr.length<=1 ? (arr[0]||"") : arr.slice(0,-1).join(", ") + " et " + arr[arr.length-1];

  function inputsTotalCp(){
    let total=0;
    total += toInt(inputs["Cuivre"].value)   * RATES["Cuivre"];
    total += toInt(inputs["Argent"].value)   * RATES["Argent"];
    total += toInt(inputs["Électrum"].value) * RATES["Électrum"];
    total += toInt(inputs["Or"].value)       * RATES["Or"];
    total += toInt(inputs["Platine"].value)  * RATES["Platine"];
    return total;
  }

  function minimalSentenceFromCp(totalCp, tokens=TOKENS){
    let remaining = totalCp;
    const items = [];
    for (const t of tokens){
      if (remaining<=0) break;
      const q = Math.floor(remaining / t.value);
      if (q>0){
        remaining -= q * t.value;
        items.push({coin:t.coin, mult:t.mult, qty:q});
      }
    }
    const parts = items.map(it => it.mult===1
      ? `${fmt(it.qty)} ${pieceWord(it.qty)} ${articleDe(it.coin)}`
      : `${fmt(it.qty)} ${pieceWord(it.qty)} ${articleDe(it.coin)} x${it.mult}`
    );
    return { text: parts.length ? `Représentation minimale : ${joinEt(parts)}` : "Représentation minimale : —", items, remaining };
  }

  // --- Conversion table (colonnes dynamiques)
  function fillConversionTable(totalCp){
    // Colonnes utilisées
    const used = MULTS.filter(m => COINS.some(c => Math.floor(totalCp/(RATES[c]*m))>0));
    convHead.innerHTML = "";
    convBody.innerHTML = "";
    if (used.length===0){ convCard.classList.add("is-hidden"); return; }
    convCard.classList.remove("is-hidden");

    // Entêtes
    convHead.appendChild(th("Métal"));
    for(const m of used){ convHead.appendChild(th(`x${fmt(m)}`)); }

    // Lignes
    for(const coin of COINS){
      const row = document.createElement("tr");
      let has=false;
      row.appendChild(tdLeft(coin));
      for(const m of used){
        const v = Math.floor(totalCp/(RATES[coin]*m));
        has = has || v>0;
        row.appendChild(td(v>0 ? fmt(v) : ""));
      }
      if (has) convBody.appendChild(row);
    }
  }
  function th(txt){ const e=document.createElement("th"); e.textContent=txt; return e; }
  function td(txt){ const e=document.createElement("td"); e.textContent=txt; return e; }
  function tdLeft(txt){ const e=td(txt); e.style.textAlign="left"; return e; }

  // --- Équivalences par métal (compact, 1 ligne)
  function fillEquivalences(totalCp){
    equivList.innerHTML="";
    let any=false;

    for(const coin of COINS){
      const base = RATES[coin];
      const units = Math.floor(totalCp/base);
      const remainderCp = totalCp % base;

      // Décomposition dans CE métal (10k -> 1)
      let rest = units;
      const parts = [];
      for(const m of MULTS_DESC){
        const q = Math.floor(rest/m);
        if(q>0){
          parts.push(m===1
            ? `${fmt(q)} ${pieceWord(q)}`
            : `${fmt(q)} ${pieceWord(q)} x${fmt(m)}`
          );
          rest -= q*m;
        }
      }
      if (!parts.length) continue; // ligne inutile -> on saute

      let summary = joinEt(parts);
      if (remainderCp>0){
        const rem = minimalSentenceFromCp(remainderCp);
        summary += " — Reste : " + rem.text.replace("Représentation minimale : ","");
      }

      const row = document.createElement("div"); row.className = "equiv-row";
      const left = document.createElement("div");
      const right = document.createElement("div");
      left.innerHTML = `<strong>${coin}</strong>`;
      right.className = "equiv-text";
      right.textContent = summary;

      row.appendChild(left); row.appendChild(right);
      equivList.appendChild(row);
      any=true;
    }

    equivCard.classList.toggle("is-hidden", !any);
  }

  // --- Phrase minimale complète
  function fillMinimal(totalCp){
    if (totalCp<=0){ minimalCard.classList.add("is-hidden"); return; }
    const res = minimalSentenceFromCp(totalCp);
    minimalText.textContent = res.text;
    minimalCard.classList.remove("is-hidden");
  }

  // --- Orchestration
  let tId=null;
  function scheduleCompute(){
    if (tId) cancelAnimationFrame(tId);
    tId = requestAnimationFrame(compute);
  }
  function compute(){
    const totalCp = inputsTotalCp();
    const show = totalCp>0;
    convCard.classList.toggle("is-hidden", !show);
    equivCard.classList.toggle("is-hidden", !show);
    minimalCard.classList.toggle("is-hidden", !show);
    if (!show) return;
    fillConversionTable(totalCp);
    fillEquivalences(totalCp);
    fillMinimal(totalCp);
  }

  // --- Entrées : filtre chiffres, clear au focus, 0 au blur, recalcul immédiat
  for (const coin of COINS){
    const el = inputs[coin];

    el.addEventListener("input", (e) => {
      const cur = e.target.value.replace(/\D+/g,"");
      if (e.target.value !== cur) e.target.value = cur;
      scheduleCompute();
    }, {passive:true});

    el.addEventListener("focus", (e) => {
      if (e.target.value==="0") e.target.value="";
      e.target.select();
    });

    el.addEventListener("blur", (e) => {
      if (e.target.value==="") e.target.value="0";
      scheduleCompute();
    });
  }

  // Premier rendu
  compute();
})();
</script>
</body>
</html>
