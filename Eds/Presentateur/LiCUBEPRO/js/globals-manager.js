/**
 * =================================================================
 * GESTIONNAIRE DE VARIABLES GLOBALES - SYST√àME CENTRALIS√â
 * =================================================================
 * 
 * R√¥le : Gestionnaire central pour toutes les variables num√©riques
 *        du syst√®me de pr√©sentation Li-CUBE PRO‚Ñ¢
 * 
 * Fonctionnalit√©s :
 * - Chargement des GLOBALS depuis JSON
 * - Clonage vers state local mutable
 * - D√©tection automatique mode vente/location
 * - Binding automatique via data-pricing-value
 * - Calculs dynamiques temps r√©el
 * 
 * Utilisation :
 *   import { GlobalsManager } from './globals-manager.js';
 *   const manager = new GlobalsManager();
 *   await manager.initialize();
 * 
 * @author Claude Code - EDS Qu√©bec
 * @version 2.0.0
 * @licence Propri√©taire EDS Qu√©bec
 */

/**
 * Classe principale de gestion des variables globales
 * Impl√©mente le pattern Singleton pour une instance unique
 */
class GlobalsManager {
    constructor() {
        // Singleton : une seule instance autoris√©e
        if (GlobalsManager.instance) {
            return GlobalsManager.instance;
        }
        GlobalsManager.instance = this;

        // √âtat interne du gestionnaire
        this.globals = null;          // Constantes globales (read-only)
        this.state = null;            // √âtat local mutable (clonage)
        this.mode = 'vente';          // Mode d√©tect√© : 'vente' ou 'location'
        this.isInitialized = false;   // Flag d'initialisation
        this.listeners = new Map();   // √âcouteurs de changements

        // Configuration de formatage
        this.formatters = {
            currency: (value, suffix = 'CAD') => `${this.formatNumber(value)} ${suffix}`,
            percentage: (value, suffix = '%') => `${this.formatNumber(value, 1)}${suffix}`,
            number: (value, precision = 0) => this.formatNumber(value, precision),
            weight: (value) => `${this.formatNumber(value, 0)} kg`,
            voltage: (value) => `${this.formatNumber(value, 1)}V`,
            energy: (value) => `${this.formatNumber(value, 0)} Wh`,
            cycles: (value) => `${this.formatNumber(value, 0)} cycles`
        };

        console.log('üìä GlobalsManager : Instance cr√©√©e');
    }

    /**
     * Initialise le gestionnaire global
     * Charge GLOBALS.json, d√©tecte le mode, clone l'√©tat local
     * 
     * @returns {Promise<boolean>} Succ√®s de l'initialisation
     */
    async initialize() {
        try {
            console.log('üöÄ GlobalsManager : Initialisation...');

            // √âtape 1 : D√©tection du mode (vente/location)
            this.detectMode();

            // √âtape 2 : Chargement des GLOBALS depuis JSON
            await this.loadGlobals();

            // √âtape 3 : Clonage vers √©tat local mutable
            this.cloneToLocalState();

            // √âtape 4 : Mise √† jour des calculs dynamiques
            this.updateDynamicCalculations();

            // √âtape 5 : Application du binding automatique
            this.applyDataBinding();

            this.isInitialized = true;
            console.log(`‚úÖ GlobalsManager : Initialis√© en mode ${this.mode.toUpperCase()}`);
            
            return true;

        } catch (error) {
            console.error('‚ùå GlobalsManager : Erreur d\'initialisation', error);
            return false;
        }
    }

    /**
     * D√©tecte automatiquement le mode (vente/location)
     * Bas√© sur l'URL ou la classe CSS du body
     */
    detectMode() {
        // M√©thode 1 : D√©tection par URL
        const path = window.location.pathname || '';
        if (path.includes('presentations-location') || path.includes('location')) {
            this.mode = 'location';
            console.log('üéØ Mode d√©tect√© par URL : LOCATION');
            return;
        }

        // M√©thode 2 : D√©tection par attribut data-mode
        const bodyMode = document.body.getAttribute('data-mode');
        if (bodyMode === 'location') {
            this.mode = 'location';
            console.log('üéØ Mode d√©tect√© par attribut : LOCATION');
            return;
        }

        // M√©thode 3 : D√©tection par classe CSS
        if (document.body.classList.contains('mode-location')) {
            this.mode = 'location';
            console.log('üéØ Mode d√©tect√© par classe : LOCATION');
            return;
        }

        // Par d√©faut : mode vente
        this.mode = 'vente';
        console.log('üéØ Mode par d√©faut : VENTE');
    }

    /**
     * Charge les variables globales depuis le fichier JSON
     * Utilise le chemin relatif appropri√© selon la profondeur
     */
    async loadGlobals() {
        const possiblePaths = [
            '../Correction/GLOBALS.initial.json',
            '../../Correction/GLOBALS.initial.json',
            '../../../Correction/GLOBALS.initial.json',
            './Correction/GLOBALS.initial.json'
        ];

        for (const path of possiblePaths) {
            try {
                console.log(`üìÅ Tentative de chargement : ${path}`);
                const response = await fetch(path);
                
                if (response.ok) {
                    this.globals = await response.json();
                    console.log('‚úÖ GLOBALS charg√© avec succ√®s depuis :', path);
                    return;
                }
            } catch (error) {
                console.warn(`‚ö†Ô∏è  √âchec du chargement depuis ${path}:`, error.message);
            }
        }

        throw new Error('‚ùå Impossible de charger GLOBALS.initial.json depuis tous les chemins test√©s');
    }

    /**
     * Clone les GLOBALS vers un √©tat local mutable
     * Utilise structuredClone pour un clonage profond
     */
    cloneToLocalState() {
        if (!this.globals) {
            throw new Error('‚ùå GLOBALS non charg√©, impossible de cloner l\'√©tat');
        }

        // Clonage profond pour √©viter les mutations accidentelles
        this.state = structuredClone(this.globals);
        console.log('üìã √âtat local clon√© depuis GLOBALS');
    }

    /**
     * Met √† jour les calculs dynamiques selon le mode actuel
     * Recalcule les pourcentages, √©conomies, ratios
     */
    updateDynamicCalculations() {
        if (!this.state) return;

        const tcoKey = `tco_${this.mode}`;
        const tcoData = this.state.calculations[tcoKey];

        if (tcoData) {
            // Recalcul du pourcentage d'√©conomies
            const licubeTotal = tcoData.licube.total_20_years;
            const nicdTotal = tcoData.nicd.total_20_years;
            
            if (nicdTotal > 0) {
                const savings = nicdTotal - licubeTotal;
                const percentage = (savings / nicdTotal) * 100;
                
                tcoData.savings.total = Math.round(savings);
                tcoData.savings.percentage = Math.round(percentage * 10) / 10; // 1 d√©cimale
                
                console.log(`üí∞ Calculs mis √† jour [${this.mode}] : ${percentage.toFixed(1)}% d'√©conomies`);
            }
        }

        // Mise √† jour des ratios de poids
        if (this.state.licube && this.state.nicd) {
            const licubeWeight = this.state.licube.weight_kg;
            const nicdWeight = this.state.nicd.weight_kg;
            
            if (nicdWeight > 0) {
                const reduction = ((nicdWeight - licubeWeight) / nicdWeight) * 100;
                this.state.licube.weight_reduction_percentage = Math.round(reduction);
                
                console.log(`‚öñÔ∏è  R√©duction de poids calcul√©e : ${reduction.toFixed(0)}%`);
            }
        }
    }

    /**
     * Applique le binding automatique sur tous les √©l√©ments data-pricing-value
     * Parcourt le DOM et met √† jour les valeurs
     */
    applyDataBinding() {
        const elements = document.querySelectorAll('[data-pricing-value]');
        console.log(`üîó Application du binding sur ${elements.length} √©l√©ments`);

        elements.forEach((element, index) => {
            try {
                this.bindElement(element);
            } catch (error) {
                console.error(`‚ùå Erreur binding √©l√©ment ${index + 1}:`, error, element);
            }
        });
    }

    /**
     * Applique le binding sur un √©l√©ment sp√©cifique
     * 
     * @param {HTMLElement} element - √âl√©ment √† lier
     */
    bindElement(element) {
        const variablePath = element.getAttribute('data-pricing-value');
        const formatType = element.getAttribute('data-pricing-format') || 'number';
        const suffix = element.getAttribute('data-pricing-suffix') || '';

        if (!variablePath) return;

        // R√©cup√©ration de la valeur via le chemin
        const value = this.getValue(variablePath);
        
        if (value !== null && value !== undefined) {
            // Application du formatage
            const formattedValue = this.formatValue(value, formatType, suffix);
            
            // Mise √† jour du contenu
            element.textContent = formattedValue;
            
            // Ajout d'une classe CSS pour identification
            element.classList.add('globals-bound');
            
            console.log(`‚úÖ Binding: ${variablePath} = ${formattedValue}`);
        } else {
            console.warn(`‚ö†Ô∏è  Valeur non trouv√©e pour: ${variablePath}`);
            element.classList.add('globals-error');
        }
    }

    /**
     * R√©cup√®re une valeur via son chemin dans l'√©tat
     * 
     * @param {string} path - Chemin vers la valeur (ex: "licube.weight_kg")
     * @returns {any} Valeur trouv√©e ou null
     */
    getValue(path) {
        if (!this.state || !path) return null;

        const parts = path.split('.');
        let current = this.state;

        for (const part of parts) {
            if (current && typeof current === 'object' && part in current) {
                current = current[part];
            } else {
                return null;
            }
        }

        return current;
    }

    /**
     * Met √† jour une valeur dans l'√©tat et propage les changements
     * 
     * @param {string} path - Chemin vers la valeur
     * @param {any} value - Nouvelle valeur
     * @returns {boolean} Succ√®s de la mise √† jour
     */
    setValue(path, value) {
        if (!this.state || !path) return false;

        const parts = path.split('.');
        const lastPart = parts.pop();
        let current = this.state;

        // Navigation jusqu'au parent
        for (const part of parts) {
            if (!current[part] || typeof current[part] !== 'object') {
                current[part] = {};
            }
            current = current[part];
        }

        // Mise √† jour de la valeur
        current[lastPart] = value;

        // Recalcul des valeurs d√©pendantes
        this.updateDynamicCalculations();

        // Notification des changements
        this.notifyListeners(path, value);

        console.log(`üìù Valeur mise √† jour: ${path} = ${value}`);
        return true;
    }

    /**
     * Formate une valeur selon le type sp√©cifi√©
     * 
     * @param {number} value - Valeur √† formater
     * @param {string} formatType - Type de formatage
     * @param {string} suffix - Suffixe optionnel
     * @returns {string} Valeur format√©e
     */
    formatValue(value, formatType = 'number', suffix = '') {
        if (value === null || value === undefined || isNaN(value)) {
            return '‚Äî';
        }

        const formatter = this.formatters[formatType];
        if (formatter) {
            return formatter(value, suffix);
        }

        // Formatage par d√©faut
        return suffix ? `${this.formatNumber(value)}${suffix}` : this.formatNumber(value);
    }

    /**
     * Formate un nombre avec s√©parateurs de milliers
     * 
     * @param {number} num - Nombre √† formater
     * @param {number} precision - Nombre de d√©cimales
     * @returns {string} Nombre format√©
     */
    formatNumber(num, precision = 0) {
        if (typeof num !== 'number' || isNaN(num)) return '0';
        
        return new Intl.NumberFormat('fr-CA', {
            minimumFractionDigits: precision,
            maximumFractionDigits: precision
        }).format(num);
    }

    /**
     * Ajoute un √©couteur de changements
     * 
     * @param {string} path - Chemin √† surveiller
     * @param {Function} callback - Fonction de rappel
     */
    addListener(path, callback) {
        if (!this.listeners.has(path)) {
            this.listeners.set(path, new Set());
        }
        this.listeners.get(path).add(callback);
    }

    /**
     * Supprime un √©couteur de changements
     * 
     * @param {string} path - Chemin surveill√©
     * @param {Function} callback - Fonction de rappel √† supprimer
     */
    removeListener(path, callback) {
        const pathListeners = this.listeners.get(path);
        if (pathListeners) {
            pathListeners.delete(callback);
            if (pathListeners.size === 0) {
                this.listeners.delete(path);
            }
        }
    }

    /**
     * Notifie tous les √©couteurs d'un changement
     * 
     * @param {string} path - Chemin modifi√©
     * @param {any} value - Nouvelle valeur
     */
    notifyListeners(path, value) {
        const pathListeners = this.listeners.get(path);
        if (pathListeners) {
            pathListeners.forEach(callback => {
                try {
                    callback(value, path);
                } catch (error) {
                    console.error('‚ùå Erreur dans listener:', error);
                }
            });
        }
    }

    /**
     * Re-applique le binding sur tous les √©l√©ments
     * Utile apr√®s des modifications d'√©tat
     */
    refreshBinding() {
        this.applyDataBinding();
        console.log('üîÑ Binding rafra√Æchi');
    }

    /**
     * Retourne des informations de d√©bogage
     * 
     * @returns {Object} √âtat actuel du gestionnaire
     */
    getDebugInfo() {
        return {
            mode: this.mode,
            isInitialized: this.isInitialized,
            hasGlobals: !!this.globals,
            hasState: !!this.state,
            listenersCount: this.listeners.size,
            boundElementsCount: document.querySelectorAll('.globals-bound').length,
            errorElementsCount: document.querySelectorAll('.globals-error').length
        };
    }
}

/**
 * Instance globale unique (Singleton)
 * Export√©e pour utilisation dans d'autres modules
 */
const globalsManager = new GlobalsManager();

/**
 * Initialisation automatique au chargement DOM
 * Lance le processus d√®s que la page est pr√™te
 */
document.addEventListener('DOMContentLoaded', async () => {
    console.log('üì± DOM pr√™t, initialisation GlobalsManager...');
    
    const success = await globalsManager.initialize();
    
    if (success) {
        // Dispatch d'un √©v√©nement personnalis√© pour notifier l'initialisation
        window.dispatchEvent(new CustomEvent('globals-ready', {
            detail: { manager: globalsManager }
        }));
        
        console.log('‚úÖ GlobalsManager pr√™t et disponible globalement');
    } else {
        console.error('‚ùå √âchec de l\'initialisation GlobalsManager');
    }
});

/**
 * Export pour utilisation moderne (ES modules)
 */
export { GlobalsManager, globalsManager };

/**
 * Disponibilit√© globale pour compatibilit√© legacy
 */
window.GlobalsManager = GlobalsManager;
window.globalsManager = globalsManager;