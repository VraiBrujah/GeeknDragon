<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Éditeur de Widgets Hiérarchique - Li-CUBE PRO™</title>
    <link rel="import" href="editor-layout.html">
    <script>
        const layout = document.querySelector('link[rel="import"]').import.getElementById('layout');
        document.head.appendChild(layout.content.cloneNode(true));
    </script>

    <!-- Polices -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="../assets/css/widget-editor.css">
</head>
<body>
    <div class="widget-editor">
        <!-- Barre d'outils -->
        <div class="editor-toolbar">
            <div class="toolbar-left">
                <h1 class="toolbar-title">
                    <i class="fas fa-cubes"></i>
                    Éditeur Hiérarchique
                </h1>
            </div>
            
            <div class="toolbar-center">
                <button class="btn btn-sm" id="newCanvasBtn">
                    <i class="fas fa-plus"></i>
                    Nouveau Canevas
                </button>
            </div>

            <!-- Chemin hiérarchique actif -->
            <div class="toolbar-breadcrumb" id="hierarchyBreadcrumb"></div>

            <div class="toolbar-right">
                <button class="btn btn-sm" id="saveWidgetBtn" disabled>
                    <i class="fas fa-save"></i>
                    Sauvegarder
                </button>
                <button class="btn btn-sm" id="loadWidgetBtn">
                    <i class="fas fa-folder-open"></i>
                    Charger
                </button>
                <button class="btn btn-sm" id="clearCanvasBtn">
                    <i class="fas fa-trash"></i>
                    Vider
                </button>
            </div>
        </div>

        <!-- Bibliothèque de widgets -->
        <div class="editor-library">
            <div class="library-header">
                <i class="fas fa-puzzle-piece"></i>
                Widgets Disponibles
            </div>
            <div class="widget-list" id="widgetList">
                <!-- Widgets générés dynamiquement -->
            </div>
        </div>

        <!-- Canvas d'édition -->
        <div class="editor-canvas">
            <div class="canvas-workspace" id="canvasWorkspace">
                <div class="canvas-empty" id="canvasEmpty">
                    <i class="fas fa-plus-circle"></i>
                    <h3>Aucun canevas</h3>
                    <p>Cliquez sur "Nouveau Canevas" pour commencer ou glissez un widget ici</p>
                </div>
            </div>
        </div>

        <!-- Panneau de propriétés -->
        <div class="editor-properties">
            <div class="properties-header">
                <i class="fas fa-cog"></i>
                Propriétés
            </div>
            <div class="properties-content" id="propertiesContent">
                <div class="property-group">
                    <h4><i class="fas fa-info-circle"></i> Sélection</h4>
                    <p style="color: var(--text-muted); font-style: italic;">
                        Sélectionnez un widget pour voir ses propriétés
                    </p>
                </div>
            </div>
        </div>

        <!-- Viewer temps réel -->
        <div class="editor-viewer">
            <div class="viewer-header">
                <div class="viewer-title">
                    <i class="fas fa-eye"></i>
                    Aperçu Temps Réel
                </div>
                <div class="viewer-controls">
                    <button class="btn btn-sm" id="refreshPreviewBtn">
                        <i class="fas fa-sync"></i>
                        Actualiser
                    </button>
                </div>
            </div>
            <div class="viewer-content" id="viewerContent">
                <!-- Aperçu généré ici -->
            </div>
        </div>
    </div>

    <!-- Messages de statut -->
    <div class="status-message" id="statusMessage"></div>

    <script>
        // ================================================================================
        // SYSTÈME HIÉRARCHIQUE DE WIDGETS - VERSION COMPLÈTEMENT REFACTORISÉE
        // ================================================================================

        // Rôle      : Classe de base pour tous les widgets avec support hiérarchique
        // Type      : class
        // Unité     : sans unité
        // Formule   : widget = {id, type, data, children, parent, render()}
        // Exemple   : CanvasWidget contient [LogoWidget, TextWidget] comme enfants
        class BaseWidget {
            constructor() {
                this.id = `widget-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                this.type = this.constructor.name.replace('Widget', '').toLowerCase();
                this.name = 'Widget de Base';
                this.description = 'Widget de base';
                this.category = 'Base';
                this.icon = 'fas fa-puzzle-piece';
                
                // Système hiérarchique
                this.children = [];
                this.parent = null;
                this.canHaveChildren = false;
                
                // Données par défaut
                this.data = {};
                this.defaultData = {};
            }

            // Rôle      : Ajouter un enfant au widget actuel
            // Type      : function
            // Unité     : sans unité
            // Formule   : parent.children.push(child), child.parent = parent
            // Exemple   : canvasWidget.addChild(logoWidget)
            addChild(childWidget) {
                if (!this.canHaveChildren) return false;
                
                if (childWidget.parent) {
                    childWidget.parent.removeChild(childWidget);
                }
                
                this.children.push(childWidget);
                childWidget.parent = this;
                return true;
            }

            // Rôle      : Supprimer un enfant du widget actuel
            // Type      : function
            // Unité     : sans unité
            // Formule   : parent.children = parent.children.filter(c => c !== child)
            // Exemple   : canvasWidget.removeChild(logoWidget)
            removeChild(childWidget) {
                const index = this.children.indexOf(childWidget);
                if (index > -1) {
                    this.children.splice(index, 1);
                    childWidget.parent = null;
                    return true;
                }
                return false;
            }

            // Rôle      : Obtenir tous les descendants (enfants, petits-enfants, etc.)
            // Type      : function
            // Unité     : sans unité
            // Formule   : descendants = enfants + descendants_des_enfants (récursif)
            // Exemple   : [logoWidget, textWidget, buttonWidget] pour un canvas
            getAllDescendants() {
                let descendants = [];
                for (let child of this.children) {
                    descendants.push(child);
                    descendants = descendants.concat(child.getAllDescendants());
                }
                return descendants;
            }

            // Rôle      : Trouver un widget par ID dans l'arbre hiérarchique
            // Type      : function
            // Unité     : sans unité
            // Formule   : recherche_récursive(id) dans this + enfants + descendants
            // Exemple   : canvas.findById('widget-123') retourne logoWidget
            findById(id) {
                if (this.id === id) return this;
                for (let child of this.children) {
                    const found = child.findById(id);
                    if (found) return found;
                }
                return null;
            }

            // Rôle      : Obtenir le widget racine (ancêtre le plus haut)
            // Type      : function
            // Unité     : sans unité
            // Formule   : remonte_parent jusqu'à parent === null
            // Exemple   : logoWidget.getRootWidget() retourne canvasWidget
            getRootWidget() {
                let current = this;
                while (current.parent) {
                    current = current.parent;
                }
                return current;
            }

            // Rôle      : Sérialiser le widget et tous ses enfants pour sauvegarde
            // Type      : function
            // Unité     : sans unité
            // Formule   : {id, type, data, children: children.map(serialize)}
            // Exemple   : Sérialisation complète de l'arbre hiérarchique
            serialize() {
                return {
                    id: this.id,
                    type: this.type,
                    name: this.name,
                    data: JSON.parse(JSON.stringify(this.data)),
                    children: this.children.map(child => child.serialize())
                };
            }

            // Rôle      : Rendu HTML du widget avec ses enfants
            // Type      : function
            // Unité     : sans unité
            // Formule   : HTML_widget + HTML_enfants_récursif
            // Exemple   : <div class="widget">contenu + enfants</div>
            render() {
                return `<div class="base-widget">Widget de Base</div>`;
            }

            // Rôle      : Rendu des enfants dans la hiérarchie
            // Type      : function
            // Unité     : sans unité
            // Formule   : concatenation(child.render() pour child dans children)
            // Exemple   : HTML combiné de tous les widgets enfants
            renderChildren() {
                return this.children.map(child => child.render()).join('');
            }

            // Rôle      : Obtenir les propriétés éditables du widget
            // Type      : function
            // Unité     : sans unité
            // Formule   : liste des champs de configuration utilisateur
            // Exemple   : [{name: 'text', label: 'Texte', type: 'text'}]
            getEditableFields() {
                return [];
            }

            // Actions personnalisées pour la bibliothèque (ex: suppression widgets personnalisés)
            getActions() {
                return [];
            }
        }

        // Rôle      : Widget canevas racine pouvant contenir d'autres widgets
        // Type      : class extends BaseWidget
        // Unité     : sans unité
        // Formule   : canevas = widget_conteneur avec width, height, enfants multiples
        // Exemple   : Canevas 800x600 contenant logo, titre, boutons
        class CanvasWidget extends BaseWidget {
            constructor() {
                super();
                this.name = 'Canevas';
                this.description = 'Conteneur principal pour widgets';
                this.category = 'Conteneurs';
                this.icon = 'fas fa-th-large';
                this.canHaveChildren = true;
                
                this.defaultData = {
                    width: 800,
                    height: 600,
                    backgroundColor: '#ffffff',
                    padding: 20
                };
                this.data = { ...this.defaultData };
            }

            render() {
                const d = { ...this.defaultData, ...this.data };
                const childrenHtml = this.renderChildren();
                
                return `
                    <div class="canvas-widget" style="
                        width: ${d.width}px;
                        height: ${d.height}px;
                        background-color: ${d.backgroundColor};
                        padding: ${d.padding}px;
                        position: relative;
                        overflow: auto;
                        border: 1px solid #e2e8f0;
                        border-radius: 8px;
                    ">
                        ${childrenHtml}
                    </div>
                `;
            }

            getEditableFields() {
                return [
                    { name: 'width', label: 'Largeur (px)', type: 'number', min: 200, max: 1920 },
                    { name: 'height', label: 'Hauteur (px)', type: 'number', min: 200, max: 1080 },
                    { name: 'backgroundColor', label: 'Couleur de fond', type: 'color' },
                    { name: 'padding', label: 'Espacement interne (px)', type: 'number', min: 0, max: 100 }
                ];
            }
        }

        // Rôle      : Widget logo avec image et effets
        // Type      : class extends BaseWidget
        // Unité     : sans unité  
        // Formule   : logo = image + styles + position dans parent
        // Exemple   : Logo 60x60px avec image EDS et lien vers accueil
        class LogoWidget extends BaseWidget {
            constructor() {
                super();
                this.name = 'Logo';
                this.description = 'Image de marque avec lien';
                this.category = 'Branding';
                this.icon = 'fas fa-image';
                
                this.defaultData = {
                    imagePath: '../assets/images/logo-eds.png',
                    altText: 'Logo',
                    width: 60,
                    height: 60,
                    link: '#',
                    x: 10,
                    y: 10
                };
                this.data = { ...this.defaultData };
            }

            render() {
                const d = { ...this.defaultData, ...this.data };
                
                return `
                    <div class="logo-widget" style="
                        position: absolute;
                        left: ${d.x}px;
                        top: ${d.y}px;
                        width: ${d.width}px;
                        height: ${d.height}px;
                    ">
                        <a href="${d.link}" style="display: block; width: 100%; height: 100%;">
                            <img src="${d.imagePath}" alt="${d.altText}" 
                                 style="width: 100%; height: 100%; object-fit: contain;">
                        </a>
                    </div>
                `;
            }

            getEditableFields() {
                return [
                    { name: 'imagePath', label: 'Chemin de l\'image', type: 'text' },
                    { name: 'altText', label: 'Texte alternatif', type: 'text' },
                    { name: 'width', label: 'Largeur (px)', type: 'number', min: 20, max: 200 },
                    { name: 'height', label: 'Hauteur (px)', type: 'number', min: 20, max: 200 },
                    { name: 'link', label: 'Lien', type: 'text' },
                    { name: 'x', label: 'Position X (px)', type: 'number', min: 0 },
                    { name: 'y', label: 'Position Y (px)', type: 'number', min: 0 }
                ];
            }
        }

        // Rôle      : Widget texte avec formatage
        // Type      : class extends BaseWidget
        // Unité     : sans unité
        // Formule   : texte = contenu + styles + position dans parent
        // Exemple   : Titre H1 "Bienvenue" en vert centré
        class TextWidget extends BaseWidget {
            constructor() {
                super();
                this.name = 'Texte';
                this.description = 'Bloc de texte formaté';
                this.category = 'Contenu';
                this.icon = 'fas fa-font';
                
                this.defaultData = {
                    text: 'Votre texte ici',
                    fontSize: 16,
                    fontWeight: 'normal',
                    color: '#333333',
                    textAlign: 'left',
                    x: 10,
                    y: 80,
                    width: 300
                };
                this.data = { ...this.defaultData };
            }

            render() {
                const d = { ...this.defaultData, ...this.data };
                
                return `
                    <div class="text-widget" style="
                        position: absolute;
                        left: ${d.x}px;
                        top: ${d.y}px;
                        width: ${d.width}px;
                        font-size: ${d.fontSize}px;
                        font-weight: ${d.fontWeight};
                        color: ${d.color};
                        text-align: ${d.textAlign};
                    ">
                        ${d.text}
                    </div>
                `;
            }

            getEditableFields() {
                return [
                    { name: 'text', label: 'Texte', type: 'textarea' },
                    { name: 'fontSize', label: 'Taille (px)', type: 'number', min: 8, max: 72 },
                    { name: 'fontWeight', label: 'Poids', type: 'select', options: [
                        { value: 'normal', label: 'Normal' },
                        { value: 'bold', label: 'Gras' }
                    ]},
                    { name: 'color', label: 'Couleur', type: 'color' },
                    { name: 'textAlign', label: 'Alignement', type: 'select', options: [
                        { value: 'left', label: 'Gauche' },
                        { value: 'center', label: 'Centre' },
                        { value: 'right', label: 'Droite' }
                    ]},
                    { name: 'x', label: 'Position X (px)', type: 'number', min: 0 },
                    { name: 'y', label: 'Position Y (px)', type: 'number', min: 0 },
                    { name: 'width', label: 'Largeur (px)', type: 'number', min: 100, max: 1000 }
                ];
            }
        }

        // Rôle      : Widget conteneur flexible pouvant contenir d'autres widgets
        // Type      : class extends BaseWidget
        // Unité     : sans unité
        // Formule   : conteneur = zone_rectangulaire + enfants_positionnés + styles
        // Exemple   : Conteneur 400x300 avec bordure contenant logo + texte
        class ContainerWidget extends BaseWidget {
            constructor() {
                super();
                this.name = 'Conteneur';
                this.description = 'Zone conteneur pour grouper des widgets';
                this.category = 'Conteneurs';
                this.icon = 'fas fa-square';
                this.canHaveChildren = true;
                
                this.defaultData = {
                    width: 400,
                    height: 300,
                    backgroundColor: 'transparent',
                    borderColor: '#e2e8f0',
                    borderWidth: 1,
                    borderRadius: 8,
                    padding: 10,
                    x: 10,
                    y: 10
                };
                this.data = { ...this.defaultData };
            }

            render() {
                const d = { ...this.defaultData, ...this.data };
                const childrenHtml = this.renderChildren();
                
                return `
                    <div class="container-widget" style="
                        position: absolute;
                        left: ${d.x}px;
                        top: ${d.y}px;
                        width: ${d.width}px;
                        height: ${d.height}px;
                        background-color: ${d.backgroundColor};
                        border: ${d.borderWidth}px solid ${d.borderColor};
                        border-radius: ${d.borderRadius}px;
                        padding: ${d.padding}px;
                        overflow: auto;
                    ">
                        ${childrenHtml}
                    </div>
                `;
            }

            getEditableFields() {
                return [
                    { name: 'width', label: 'Largeur (px)', type: 'number', min: 100, max: 1000 },
                    { name: 'height', label: 'Hauteur (px)', type: 'number', min: 100, max: 800 },
                    { name: 'backgroundColor', label: 'Couleur de fond', type: 'color' },
                    { name: 'borderColor', label: 'Couleur bordure', type: 'color' },
                    { name: 'borderWidth', label: 'Épaisseur bordure (px)', type: 'number', min: 0, max: 10 },
                    { name: 'borderRadius', label: 'Arrondi bordure (px)', type: 'number', min: 0, max: 50 },
                    { name: 'padding', label: 'Espacement interne (px)', type: 'number', min: 0, max: 50 },
                    { name: 'x', label: 'Position X (px)', type: 'number', min: 0 },
                    { name: 'y', label: 'Position Y (px)', type: 'number', min: 0 }
                ];
            }
        }

        // ================================================================================
        // ÉDITEUR HIÉRARCHIQUE PRINCIPAL
        // ================================================================================

        // Rôle      : Gestionnaire principal de l'éditeur avec système hiérarchique
        // Type      : class
        // Unité     : sans unité
        // Formule   : éditeur = widgets_disponibles + canvas_actuel + widget_sélectionné + UI
        // Exemple   : Éditeur avec canvas 800x600 contenant logo + texte sélectionné
        class HierarchicalWidgetEditor {
            constructor() {
                this.availableWidgets = [
                    CanvasWidget,
                    LogoWidget, 
                    TextWidget,
                    ContainerWidget
                ];
                
                this.currentCanvas = null;
                this.selectedWidget = null;
                this.customWidgets = this.loadCustomWidgets();
                this.navigationPath = [];

                this.init();
            }

            // Rôle      : Initialisation de l'éditeur et des événements
            // Type      : function
            // Unité     : sans unité
            // Formule   : setup_UI + setup_événements + render_initial
            // Exemple   : Interface prête avec bibliothèque widgets + canevas vide
            init() {
                this.setupEventListeners();
                this.renderWidgetLibrary();
                this.updateUI();
                this.updateNavigationUI();
                this.loadTemplate();
                this.showStatus('Éditeur hiérarchique prêt', 'success');
            }

            // Rôle      : Configuration des événements utilisateur
            // Type      : function
            // Unité     : sans unité
            // Formule   : addEventListener pour tous les boutons et interactions
            // Exemple   : Clic nouveau canevas, drag & drop, sélection widgets
            setupEventListeners() {
                // Boutons de la barre d'outils
                document.getElementById('newCanvasBtn').addEventListener('click', () => this.createNewCanvas());
                document.getElementById('saveWidgetBtn').addEventListener('click', () => this.saveCurrentWidget());
                document.getElementById('loadWidgetBtn').addEventListener('click', () => this.loadWidget());
                document.getElementById('clearCanvasBtn').addEventListener('click', () => this.clearCanvas());
                document.getElementById('refreshPreviewBtn').addEventListener('click', () => this.updatePreview());

                // Drag & Drop pour ajout de widgets
                this.setupDragAndDrop();
            }

            // Rôle      : Configuration du système drag & drop
            // Type      : function
            // Unité     : sans unité
            // Formule   : events dragstart + dragover + drop pour widgets et canvas
            // Exemple   : Glisser LogoWidget depuis bibliothèque vers canvas
            setupDragAndDrop() {
                const workspace = document.getElementById('canvasWorkspace');
                
                workspace.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (this.currentCanvas) {
                        workspace.classList.add('can-drop');
                    }
                });

                workspace.addEventListener('dragleave', () => {
                    workspace.classList.remove('can-drop');
                });

                workspace.addEventListener('drop', (e) => {
                    e.preventDefault();
                    workspace.classList.remove('can-drop');
                    
                    const widgetType = e.dataTransfer.getData('text/widget-type');
                    if (widgetType) {
                        this.addWidgetToCanvas(widgetType, e.offsetX, e.offsetY);
                    }
                });
            }

            // Rôle      : Créer un nouveau canevas vide
            // Type      : function
            // Unité     : sans unité
            // Formule   : nouveau_canvas = CanvasWidget() + render + set_as_current
            // Exemple   : Canevas 800x600 blanc devient le canvas actuel
            createNewCanvas() {
                const canvas = new CanvasWidget();
                this.currentCanvas = canvas;
                this.selectedWidget = canvas;
                this.renderCanvas();
                this.updateProperties();
                this.updatePreview();
                this.updateUI();
                this.buildNavigationPath(canvas);
                this.updateNavigationUI();
                this.showStatus('Nouveau canevas créé', 'success');
            }

            // Rôle      : Ajouter un widget au canvas ou au widget sélectionné
            // Type      : function
            // Unité     : sans unité
            // Formule   : nouveau_widget = WidgetClass() + parent.addChild(widget) + positions
            // Exemple   : LogoWidget ajouté à position (50, 50) dans le canvas
            addWidgetToCanvas(widgetType, x = 10, y = 10) {
                if (!this.currentCanvas) {
                    this.createNewCanvas();
                }

                const WidgetClass = this.findWidgetClass(widgetType);
                if (!WidgetClass) {
                    this.showStatus('Type de widget non trouvé', 'error');
                    return;
                }

                const widget = new WidgetClass();
                
                // Ajuster la position si le widget supporte x/y
                if (widget.data.hasOwnProperty('x')) {
                    widget.data.x = x;
                }
                if (widget.data.hasOwnProperty('y')) {
                    widget.data.y = y;
                }

                // Ajouter au widget sélectionné ou au canvas
                let parent = this.selectedWidget;
                
                // Si le widget sélectionné ne peut pas avoir d'enfants, remonter jusqu'à en trouver un
                while (parent && !parent.canHaveChildren) {
                    parent = parent.parent;
                }
                
                // Si aucun parent trouvé, utiliser le canvas
                if (!parent) {
                    parent = this.currentCanvas;
                }

                if (parent && parent.addChild(widget)) {
                    this.selectedWidget = widget;
                    this.renderCanvas();
                    this.updateProperties();
                    this.updatePreview();
                    this.showStatus(`Widget ${widget.name} ajouté`, 'success');
                } else {
                    this.showStatus('Impossible d\'ajouter le widget', 'error');
                }
            }

            // Rôle      : Trouver une classe de widget par nom/type
            // Type      : function
            // Unité     : sans unité
            // Formule   : recherche dans availableWidgets + customWidgets par id/type
            // Exemple   : findWidgetClass('logo') retourne LogoWidget
            findWidgetClass(widgetType) {
                // Chercher dans les widgets de base
                let WidgetClass = this.availableWidgets.find(W => {
                    const instance = new W();
                    return instance.type === widgetType || instance.id === widgetType;
                });

                // Chercher dans les widgets personnalisés
                if (!WidgetClass && this.customWidgets[widgetType]) {
                    const customData = this.customWidgets[widgetType];
                    const BaseClass = this.findWidgetClass(customData.originalType);
                    if (BaseClass) {
                        WidgetClass = class extends BaseClass {
                            constructor() {
                                super();
                                this.name = customData.name;
                                this.id = widgetType;
                                this.data = { ...this.defaultData, ...customData.data };
                                this.isCustom = true;
                            }
                            
                            getActions() {
                                return [
                                    {
                                        icon: 'fas fa-trash text-red-400',
                                        action: () => widgetEditor.deleteCustomWidget(this.id),
                                        title: 'Supprimer ce widget personnalisé'
                                    }
                                ];
                            }
                        };
                    }
                }

                return WidgetClass;
            }

            // Rôle      : Rendre le canvas dans l'interface utilisateur
            // Type      : function
            // Unité     : sans unité
            // Formule   : HTML_canvas = canvas ? canvas.render() : état_vide
            // Exemple   : Affichage du canvas avec tous ses widgets enfants
            renderCanvas() {
                const workspace = document.getElementById('canvasWorkspace');
                const emptyState = document.getElementById('canvasEmpty');

                if (this.currentCanvas) {
                    emptyState.style.display = 'none';
                    
                    const canvasHtml = this.currentCanvas.render();
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = canvasHtml;
                    
                    // Ajouter les événements de sélection
                    this.addSelectionEvents(tempDiv);
                    
                    workspace.innerHTML = '';
                    workspace.appendChild(tempDiv.firstChild);
                } else {
                    emptyState.style.display = 'flex';
                }
            }

            // Rôle      : Ajouter les événements de sélection aux widgets dans le canvas
            // Type      : function
            // Unité     : sans unité
            // Formule   : addEventListener click pour chaque widget dans DOM
            // Exemple   : Clic sur logo widget le sélectionne et affiche ses propriétés
            addSelectionEvents(container) {
                const addEventsRecursive = (element, widget) => {
                    element.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectWidget(widget);
                    });

                    // Ajouter les événements aux enfants
                    widget.children.forEach((child, index) => {
                        const childElements = element.querySelectorAll(`[data-widget-id="${child.id}"]`);
                        childElements.forEach(childEl => addEventsRecursive(childEl, child));
                    });
                };

                if (this.currentCanvas) {
                    const canvasElement = container.querySelector('.canvas-widget');
                    if (canvasElement) {
                        canvasElement.setAttribute('data-widget-id', this.currentCanvas.id);
                        addEventsRecursive(canvasElement, this.currentCanvas);
                    }
                }
            }

            // Rôle      : Sélectionner un widget et mettre à jour l'interface
            // Type      : function
            // Unité     : sans unité
            // Formule   : selectedWidget = widget + update_UI + highlight_visuel
            // Exemple   : Sélection du logo met à jour le panneau propriétés
            selectWidget(widget) {
                // Supprimer l'ancienne sélection
                document.querySelectorAll('.widget-container.selected').forEach(el => {
                    el.classList.remove('selected');
                });

                this.selectedWidget = widget;
                this.buildNavigationPath(widget);

                // Ajouter la nouvelle sélection
                const widgetElement = document.querySelector(`[data-widget-id="${widget.id}"]`);
                if (widgetElement) {
                    widgetElement.classList.add('selected');
                }

                this.updateProperties();
                this.updateUI();
                this.updateNavigationUI();
                this.showStatus(`Widget ${widget.name} sélectionné`, 'info');
            }

            // Rôle      : Mettre à jour le panneau des propriétés
            // Type      : function
            // Unité     : sans unité
            // Formule   : HTML_propriétés = widget ? generatePropertyFields(widget) : vide
            // Exemple   : Affichage des champs texte, couleur, position pour le widget sélectionné
            updateProperties() {
                const content = document.getElementById('propertiesContent');
                
                if (!this.selectedWidget) {
                    content.innerHTML = `
                        <div class="property-group">
                            <h4><i class="fas fa-info-circle"></i> Sélection</h4>
                            <p style="color: var(--text-muted); font-style: italic;">
                                Sélectionnez un widget pour voir ses propriétés
                            </p>
                        </div>
                    `;
                    return;
                }

                const widget = this.selectedWidget;
                const fields = widget.getEditableFields();

                let html = `
                    <div class="property-group">
                        <h4><i class="fas fa-info-circle"></i> Widget Sélectionné</h4>
                        <div style="color: var(--text-muted); margin-bottom: 1rem;">
                            <strong>${widget.name}</strong><br>
                            ID: ${widget.id}<br>
                            Type: ${widget.type}
                        </div>
                    </div>
                `;

                if (fields.length > 0) {
                    html += `
                        <div class="property-group">
                            <h4><i class="fas fa-sliders-h"></i> Propriétés</h4>
                    `;

                    fields.forEach(field => {
                        const value = widget.data[field.name] !== undefined ? widget.data[field.name] : '';
                        html += this.createPropertyField(field, value, widget.id);
                    });

                    html += '</div>';
                }

                // Sauvegarde de widgets personnalisés
                html += `
                    <div class="property-group">
                        <h4><i class="fas fa-save"></i> Widget Personnalisé</h4>
                        <div class="property-field">
                            <label class="property-label">Nom du widget</label>
                            <input type="text" id="customWidgetName" class="property-input" 
                                   placeholder="Mon Widget Personnalisé" 
                                   value="${widget.isCustom ? widget.name : ''}">
                        </div>
                        <div class="property-field" style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                            <button class="btn btn-sm btn-primary" id="saveCustomWidgetBtn">
                                <i class="fas fa-save"></i>
                                ${widget.isCustom ? 'Mettre à jour' : 'Sauvegarder'}
                            </button>
                        </div>
                    </div>
                `;

                content.innerHTML = html;
                this.attachPropertyEventListeners();
            }

            // Rôle      : Créer un champ de propriété HTML
            // Type      : function
            // Unité     : sans unité
            // Formule   : HTML_field = input_type(field.type) + events + validation
            // Exemple   : Champ couleur avec picker et mise à jour temps réel
            createPropertyField(field, value, widgetId) {
                const fieldId = `prop-${field.name}-${widgetId}`;
                
                let inputHtml = '';
                switch (field.type) {
                    case 'text':
                        inputHtml = `
                            <input type="text" id="${fieldId}" class="property-input" 
                                   value="${value}" data-field="${field.name}">
                        `;
                        break;
                    case 'textarea':
                        inputHtml = `
                            <textarea id="${fieldId}" class="property-input" rows="3"
                                      data-field="${field.name}">${value}</textarea>
                        `;
                        break;
                    case 'number':
                        inputHtml = `
                            <input type="number" id="${fieldId}" class="property-input" 
                                   value="${value}" data-field="${field.name}"
                                   min="${field.min || ''}" max="${field.max || ''}">
                        `;
                        break;
                    case 'color':
                        inputHtml = `
                            <input type="color" id="${fieldId}" class="property-input" 
                                   value="${value}" data-field="${field.name}">
                        `;
                        break;
                    case 'select':
                        const options = field.options.map(opt => 
                            `<option value="${opt.value}" ${opt.value === value ? 'selected' : ''}>${opt.label}</option>`
                        ).join('');
                        inputHtml = `
                            <select id="${fieldId}" class="property-input" data-field="${field.name}">
                                ${options}
                            </select>
                        `;
                        break;
                    default:
                        inputHtml = `
                            <input type="text" id="${fieldId}" class="property-input" 
                                   value="${value}" data-field="${field.name}">
                        `;
                }

                return `
                    <div class="property-field">
                        <label class="property-label" for="${fieldId}">${field.label}</label>
                        ${inputHtml}
                    </div>
                `;
            }

            // Rôle      : Attacher les événements aux champs de propriétés
            // Type      : function
            // Unité     : sans unité
            // Formule   : addEventListener pour tous les inputs de propriétés
            // Exemple   : Changement de couleur met à jour le widget en temps réel
            attachPropertyEventListeners() {
                const inputs = document.querySelectorAll('.property-input[data-field]');
                inputs.forEach(input => {
                    const updateProperty = () => {
                        if (this.selectedWidget) {
                            const fieldName = input.dataset.field;
                            let value = input.value;
                            
                            // Conversion de type
                            if (input.type === 'number') {
                                value = parseFloat(value) || 0;
                            } else if (input.type === 'checkbox') {
                                value = input.checked;
                            }

                            this.selectedWidget.data[fieldName] = value;
                            this.renderCanvas();
                            this.updatePreview();
                        }
                    };

                    input.addEventListener('input', updateProperty);
                    input.addEventListener('change', updateProperty);
                });

                // Événement de sauvegarde
                const saveBtn = document.getElementById('saveCustomWidgetBtn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', () => this.saveAsCustomWidget());
                }
            }

            // Rôle      : Sauvegarder le widget sélectionné comme widget personnalisé
            // Type      : function
            // Unité     : sans unité
            // Formule   : custom_widget = {name, data, originalType} + save_localStorage
            // Exemple   : Logo personnalisé "Mon Logo Corporate" sauvé et disponible
            saveAsCustomWidget() {
                if (!this.selectedWidget) return;

                const nameInput = document.getElementById('customWidgetName');
                const customName = nameInput ? nameInput.value.trim() : '';

                if (!customName) {
                    alert('Veuillez saisir un nom pour votre widget personnalisé.');
                    return;
                }

                const customId = `custom_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const customWidget = {
                    id: customId,
                    name: customName,
                    originalType: this.selectedWidget.type,
                    data: JSON.parse(JSON.stringify(this.selectedWidget.data)),
                    createdAt: new Date().toISOString()
                };

                this.customWidgets[customId] = customWidget;
                this.saveCustomWidgets();
                this.renderWidgetLibrary();

                this.showStatus(`Widget "${customName}" sauvegardé`, 'success');
            }

            // Rôle      : Supprimer un widget personnalisé
            // Type      : function
            // Unité     : sans unité
            // Formule   : delete customWidgets[id] + save_localStorage + update_UI
            // Exemple   : Suppression du widget "Mon Logo Corporate"
            deleteCustomWidget(customId) {
                const widget = this.customWidgets[customId];
                if (!widget) return;

                if (confirm(`Voulez-vous vraiment supprimer le widget "${widget.name}" ?`)) {
                    delete this.customWidgets[customId];
                    this.saveCustomWidgets();
                    this.renderWidgetLibrary();
                    this.showStatus(`Widget "${widget.name}" supprimé`, 'success');
                }
            }

            // Rôle      : Rendre la bibliothèque de widgets disponibles
            // Type      : function
            // Unité     : sans unité
            // Formule   : HTML_library = widgets_base + widgets_personnalisés groupés par catégorie
            // Exemple   : Catégories Branding, Contenu, Conteneurs, Personnalisés
            renderWidgetLibrary() {
                const container = document.getElementById('widgetList');
                const categories = {};

                // Organiser les widgets par catégorie
                this.availableWidgets.forEach(WidgetClass => {
                    const instance = new WidgetClass();
                    if (!categories[instance.category]) {
                        categories[instance.category] = [];
                    }
                    categories[instance.category].push(instance);
                });

                // Ajouter les widgets personnalisés
                Object.values(this.customWidgets).forEach(customWidget => {
                    if (!categories['Personnalisés']) {
                        categories['Personnalisés'] = [];
                    }
                    
                    const pseudoInstance = {
                        id: customWidget.id,
                        name: customWidget.name,
                        description: `Widget personnalisé basé sur ${customWidget.originalType}`,
                        icon: 'fas fa-star',
                        isCustom: true,
                        getActions: () => [
                            {
                                icon: 'fas fa-trash text-red-400',
                                action: () => this.deleteCustomWidget(customWidget.id),
                                title: 'Supprimer ce widget personnalisé'
                            }
                        ]
                    };
                    categories['Personnalisés'].push(pseudoInstance);
                });

                let html = '';
                Object.entries(categories).forEach(([category, widgets]) => {
                    html += `
                        <div class="widget-category">
                            <div class="category-title">${category}</div>
                    `;

                    widgets.forEach(widget => {
                        const customBadge = widget.isCustom ? 
                            '<div class="widget-custom-badge"><i class="fas fa-user"></i></div>' : '';
                        
                        let actionsHtml = '';
                        if (widget.getActions && typeof widget.getActions === 'function') {
                            const actions = widget.getActions();
                            actions.forEach(action => {
                                actionsHtml += `
                                    <button class="btn btn-sm" onclick="event.stopPropagation(); (${action.action.toString()})()" 
                                            title="${action.title}">
                                        <i class="${action.icon}"></i>
                                    </button>
                                `;
                            });
                        }

                        html += `
                            <div class="widget-item" draggable="true" data-widget-type="${widget.id}">
                                <div class="widget-icon">
                                    <i class="${widget.icon}"></i>
                                    ${customBadge}
                                </div>
                                <div class="widget-info">
                                    <div class="widget-name">${widget.name}</div>
                                    <div class="widget-description">${widget.description}</div>
                                </div>
                                <div class="widget-actions">
                                    ${actionsHtml}
                                    <button class="btn btn-sm" title="Ajouter">
                                        <i class="fas fa-plus"></i>
                                    </button>
                                </div>
                            </div>
                        `;
                    });

                    html += '</div>';
                });

                container.innerHTML = html;
                this.attachLibraryEvents();
            }

            // Rôle      : Attacher les événements à la bibliothèque de widgets
            // Type      : function
            // Unité     : sans unité
            // Formule   : addEventListener drag + click pour tous les widgets de la bibliothèque
            // Exemple   : Glisser-déposer widget ou clic pour ajout direct
            attachLibraryEvents() {
                const items = document.querySelectorAll('.widget-item[data-widget-type]');
                items.forEach(item => {
                    // Drag start
                    item.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/widget-type', item.dataset.widgetType);
                    });

                    // Click to add
                    item.addEventListener('click', (e) => {
                        if (!e.target.closest('.widget-actions')) {
                            this.addWidgetToCanvas(item.dataset.widgetType);
                        }
                    });
                });
            }

            // Rôle      : Sauvegarder le widget racine actuel (canvas + tous ses enfants)
            // Type      : function
            // Unité     : sans unité
            // Formule   : widget_complet = canvas.serialize() + save_localStorage
            // Exemple   : Sauvegarde "Mon Interface" avec canvas + logo + texte + boutons
            saveCurrentWidget() {
                if (!this.currentCanvas) {
                    this.showStatus('Aucun canvas à sauvegarder', 'error');
                    return;
                }

                const name = prompt('Nom de la sauvegarde:', this.currentCanvas.name || 'Mon Widget');
                if (!name) return;

                const saveData = {
                    name: name,
                    widget: this.currentCanvas.serialize(),
                    savedAt: new Date().toISOString()
                };

                const saves = JSON.parse(localStorage.getItem('savedWidgets') || '{}');
                const saveId = `save_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                saves[saveId] = saveData;
                
                localStorage.setItem('savedWidgets', JSON.stringify(saves));
                this.updateUI();
                this.showStatus(`Widget "${name}" sauvegardé`, 'success');
            }

            // Rôle      : Charger un widget sauvegardé
            // Type      : function
            // Unité     : sans unité
            // Formule   : load_widget = deserialize(savedData) + reconstruct_hierarchy
            // Exemple   : Chargement "Mon Interface" recrée le canvas avec tous ses enfants
            loadWidget() {
                const saves = JSON.parse(localStorage.getItem('savedWidgets') || '{}');
                const savesList = Object.entries(saves);

                if (savesList.length === 0) {
                    this.showStatus('Aucune sauvegarde trouvée', 'info');
                    return;
                }

                let options = savesList.map(([id, save], index) => 
                    `${index + 1}. ${save.name} (${new Date(save.savedAt).toLocaleString()})`
                ).join('\n');

                const choice = prompt(`Choisir une sauvegarde (numéro):\n${options}`);
                const index = parseInt(choice) - 1;

                if (index >= 0 && index < savesList.length) {
                    const [saveId, saveData] = savesList[index];
                    this.loadWidgetFromData(saveData.widget);
                    this.showStatus(`Widget "${saveData.name}" chargé`, 'success');
                }
            }

            // Rôle      : Charger un widget à partir de données sérialisées
            // Type      : function
            // Unité     : sans unité
            // Formule   : reconstruct_widget(data) + restore_hierarchy + set_as_current
            // Exemple   : Reconstruction complète de l'arbre de widgets depuis JSON
            loadWidgetFromData(widgetData) {
                const widget = this.deserializeWidget(widgetData);
                if (widget) {
                    this.currentCanvas = widget;
                    this.selectedWidget = widget;
                    this.renderCanvas();
                    this.updateProperties();
                    this.updatePreview();
                    this.updateUI();
                }
            }

            // Rôle      : Désérialiser un widget à partir de données JSON
            // Type      : function
            // Unité     : sans unité
            // Formule   : widget = new WidgetClass(data) + deserialize_children récursif
            // Exemple   : Reconstitution du canvas avec logo + texte à partir de données sauvées
            deserializeWidget(data) {
                const WidgetClass = this.findWidgetClass(data.type);
                if (!WidgetClass) return null;

                const widget = new WidgetClass();
                widget.id = data.id;
                widget.name = data.name || widget.name;
                widget.data = { ...widget.defaultData, ...data.data };

                // Reconstituer les enfants récursivement
                if (data.children && Array.isArray(data.children)) {
                    data.children.forEach(childData => {
                        const child = this.deserializeWidget(childData);
                        if (child) {
                            widget.addChild(child);
                        }
                    });
                }

                return widget;
            }

            // Rôle      : Vider le canvas actuel
            // Type      : function
            // Unité     : sans unité
            // Formule   : currentCanvas = null + clear_UI + reset_selection
            // Exemple   : Retour à l'état vide "Cliquez sur Nouveau Canevas"
            clearCanvas() {
                if (this.currentCanvas && confirm('Voulez-vous vraiment vider le canvas ?')) {
                    this.currentCanvas = null;
                    this.selectedWidget = null;
                    this.renderCanvas();
                    this.updateProperties();
                    this.updatePreview();
                    this.updateUI();
                    this.showStatus('Canvas vidé', 'info');
                }
            }

            // Rôle      : Mettre à jour l'aperçu temps réel
            // Type      : function
            // Unité     : sans unité
            // Formule   : preview_HTML = currentCanvas ? canvas.render() : vide
            // Exemple   : Aperçu final du canvas avec styles appliqués
            updatePreview() {
                const content = document.getElementById('viewerContent');
                
                if (this.currentCanvas) {
                    content.innerHTML = this.currentCanvas.render();
                } else {
                    content.innerHTML = '<div style="color: #9ca3af; text-align: center; padding: 2rem;">Aucun aperçu disponible</div>';
                }
            }

            // Rôle      : Mettre à jour l'état général de l'interface
            // Type      : function
            // Unité     : sans unité
            // Formule   : update_buttons + update_status + update_indicators
            // Exemple   : Bouton Sauvegarder activé si canvas présent
            updateUI() {
                // Activer/désactiver les boutons
                const saveBtn = document.getElementById('saveWidgetBtn');
                const clearBtn = document.getElementById('clearCanvasBtn');

                if (saveBtn) saveBtn.disabled = !this.currentCanvas;
                if (clearBtn) clearBtn.disabled = !this.currentCanvas;
            }

            // Construit le chemin hiérarchique depuis la page jusqu'au widget
            buildNavigationPath(widget) {
                const path = [];
                let current = widget;
                while (current) {
                    path.unshift(current);
                    current = current.parent;
                }
                this.navigationPath = path;
            }

            // Met à jour l'affichage du fil d'Ariane
            updateNavigationUI() {
                const breadcrumb = document.getElementById('hierarchyBreadcrumb');
                if (!breadcrumb) return;
                const labels = ['page', 'section', 'widget', 'sous-widget'];
                const text = this.navigationPath
                    .map((_, idx) => labels[idx] || 'sous-widget')
                    .join(' > ');
                breadcrumb.textContent = text;
            }

            // Charge un projet complet depuis le template JSON
            async loadTemplate() {
                try {
                    const res = await fetch('/presentation-template.json');
                    const data = await res.json();
                    console.log('Template chargé', data);
                } catch (e) {
                    console.warn('Impossible de charger le template', e);
                }
            }

            // Rôle      : Charger les widgets personnalisés depuis localStorage
            // Type      : function
            // Unité     : sans unité
            // Formule   : customWidgets = JSON.parse(localStorage) || {}
            // Exemple   : Chargement des widgets "Mon Logo", "Mon Titre" sauvés précédemment
            loadCustomWidgets() {
                try {
                    return JSON.parse(localStorage.getItem('customWidgets') || '{}');
                } catch (e) {
                    console.error('Erreur lors du chargement des widgets personnalisés:', e);
                    return {};
                }
            }

            // Rôle      : Sauvegarder les widgets personnalisés dans localStorage
            // Type      : function
            // Unité     : sans unité
            // Formule   : localStorage.setItem('customWidgets', JSON.stringify(widgets))
            // Exemple   : Persistance des widgets personnalisés pour prochaine session
            saveCustomWidgets() {
                try {
                    localStorage.setItem('customWidgets', JSON.stringify(this.customWidgets));
                } catch (e) {
                    console.error('Erreur lors de la sauvegarde des widgets personnalisés:', e);
                    this.showStatus('Erreur de sauvegarde', 'error');
                }
            }

            // Rôle      : Afficher un message de statut temporaire
            // Type      : function
            // Unité     : sans unité
            // Formule   : show_message + auto_hide après 3s
            // Exemple   : "Widget sauvegardé" en vert pendant 3 secondes
            showStatus(message, type = 'info') {
                const statusEl = document.getElementById('statusMessage');
                statusEl.textContent = message;
                statusEl.className = `status-message ${type}`;
                statusEl.classList.add('show');

                setTimeout(() => {
                    statusEl.classList.remove('show');
                }, 3000);
            }
        }

        // ================================================================================
        // INITIALISATION GLOBALE
        // ================================================================================

        // Instance globale de l'éditeur
        let widgetEditor;

        // Initialisation au chargement de la page
        document.addEventListener('DOMContentLoaded', () => {
            widgetEditor = new HierarchicalWidgetEditor();
        });
    </script>
    <script type="module">
        import stateManager from "../../../../../core/widget-state-manager.js";
        window.widgetStateManager = stateManager;
    </script>
</body>
</html>