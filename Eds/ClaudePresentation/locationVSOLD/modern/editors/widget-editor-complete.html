<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Éditeur de Widgets Complet - Li-CUBE PRO™</title>
    <link rel="stylesheet" href="../assets/css/themes.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Polices pour le style de prévisualisation finale -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <style>
        /* ============================================================================
         * ÉDITEUR DE WIDGETS COMPLET - INTERFACE AVANCÉE 
         * ============================================================================ */
        
        .widget-editor {
            display: grid;
            grid-template-areas: 
                "toolbar toolbar toolbar"
                "library canvas properties"
                "viewer viewer viewer"
                "footer footer footer";
            grid-template-columns: 280px 1fr var(--properties-width, 350px);
            grid-template-rows: 60px 1fr 200px 40px;
            height: 100vh;
            background: var(--bg-primary);
            font-family: var(--font-primary);
        }

        /* Barre d'outils */
        .editor-toolbar {
            grid-area: toolbar;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-lg);
            backdrop-filter: blur(10px);
        }

        .toolbar-left, .toolbar-center, .toolbar-right {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .toolbar-title {
            font-size: var(--text-xl);
            font-weight: var(--font-semibold);
            color: var(--text-white);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .toolbar-title i {
            color: var(--accent-green);
            font-size: var(--text-2xl);
        }

        /* Bibliothèque de widgets */
        .widget-library {
            grid-area: library;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .library-header {
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-card);
        }

        .library-title {
            font-size: var(--text-lg);
            font-weight: var(--font-semibold);
            color: var(--text-white);
            margin-bottom: var(--spacing-sm);
        }

        .library-search {
            width: 100%;
            padding: var(--spacing-sm);
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            color: var(--text-white);
            font-size: var(--text-sm);
        }

        .library-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
        }

        .widget-category {
            margin-bottom: var(--spacing-lg);
        }
        
        /* Système de dossiers hiérarchiques */
        .folder-structure {
            margin-bottom: var(--spacing-md);
        }
        
        .folder-item {
            display: flex;
            align-items: center;
            padding: var(--spacing-xs) var(--spacing-sm);
            cursor: pointer;
            border-radius: var(--border-radius);
            transition: var(--transition-normal);
            font-size: var(--text-sm);
            color: var(--text-muted);
            margin-bottom: 2px;
        }
        
        .folder-item:hover {
            background: rgba(16, 185, 129, 0.05);
            color: var(--text-white);
        }
        
        .folder-item.active {
            background: rgba(16, 185, 129, 0.1);
            color: var(--accent-green);
            border-left: 3px solid var(--accent-green);
        }
        
        .folder-icon {
            width: 16px;
            margin-right: var(--spacing-xs);
            text-align: center;
        }
        
        .folder-name {
            flex: 1;
            font-weight: var(--font-medium);
        }
        
        .folder-count {
            font-size: var(--text-xs);
            color: var(--text-muted);
            background: rgba(255, 255, 255, 0.05);
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 20px;
            text-align: center;
        }
        
        .folder-children {
            margin-left: var(--spacing-md);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding-left: var(--spacing-sm);
        }
        
        .folder-children.collapsed {
            display: none;
        }
        
        .saves-section {
            border-top: 1px solid var(--border-color);
            margin-top: var(--spacing-md);
            padding-top: var(--spacing-md);
        }
        
        .save-item {
            display: flex;
            align-items: center;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--border-radius);
            transition: var(--transition-normal);
            font-size: var(--text-sm);
            color: var(--text-muted);
            margin-bottom: 2px;
            cursor: pointer;
        }
        
        .save-item:hover {
            background: rgba(59, 130, 246, 0.1);
            color: var(--text-white);
        }
        
        .save-icon {
            width: 16px;
            margin-right: var(--spacing-xs);
            text-align: center;
            color: #3b82f6;
        }
        
        .save-name {
            flex: 1;
        }
        
        .save-date {
            font-size: var(--text-xs);
            color: var(--text-muted);
        }
        
        /* Contrôles de dossier */
        .folder-controls {
            display: flex;
            gap: 4px;
        }
        
        .folder-control-btn {
            width: 20px;
            height: 20px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-normal);
        }
        
        .folder-control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-white);
        }
        
        /* État de recherche actif */
        .search-active .folder-structure {
            opacity: 0.3;
            pointer-events: none;
        }
        
        .search-results {
            display: none;
        }
        
        .search-active .search-results {
            display: block;
        }
        
        /* Popup de prévisualisation plein écran */
        .preview-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--gradient-primary);
            z-index: 10000;
            display: none;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .preview-popup.active {
            display: flex;
        }
        
        /* Header de la popup */
        .preview-header {
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 10001;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            padding: 1rem 2rem;
            border-bottom: 1px solid rgba(16, 185, 129, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .preview-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-green);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .preview-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .preview-close {
            background: transparent;
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #ef4444;
            padding: 0.5rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .preview-close:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: #ef4444;
        }
        
        /* Contenu de la popup */
        .preview-content {
            margin-top: 80px;
            min-height: calc(100vh - 80px);
            background: var(--bg-primary);
            position: relative;
        }
        
        /* Grille de prévisualisation finale */
        .preview-grid {
            padding: 40px;
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(8, minmax(120px, auto));
            gap: 20px;
            min-height: calc(100vh - 160px);
        }
        
        /* Widget dans la prévisualisation finale */
        .preview-widget-final {
            border-radius: 16px;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(16, 185, 129, 0.2);
            padding: 2rem;
            transition: all 0.3s ease;
            position: relative;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .preview-widget-final:hover {
            transform: translateY(-5px);
            border-color: var(--accent-green);
            box-shadow: 0 20px 40px rgba(16, 185, 129, 0.2);
        }
        
        /* Styles spécifiques aux widgets dans la prévisualisation */
        .preview-widget-final .widget-content {
            color: var(--text-white);
            font-family: 'Inter', sans-serif;
        }
        
        .preview-widget-final h1,
        .preview-widget-final h2,
        .preview-widget-final h3 {
            color: var(--accent-green);
            font-family: 'Playfair Display', serif;
        }
        
        /* Animation d'apparition */
        @keyframes fadeInPreview {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .preview-popup.active {
            animation: fadeInPreview 0.3s ease-out;
        }
        
        /* Message si aucun widget */
        .preview-empty {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: var(--text-muted);
            font-size: 1.2rem;
        }
        
        .preview-empty i {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .category-title {
            font-size: var(--text-sm);
            font-weight: var(--font-semibold);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: var(--spacing-sm);
            padding: 0 var(--spacing-sm);
        }

        .widget-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            margin-bottom: var(--spacing-xs);
            background: var(--bg-card);
            border: 1px solid transparent;
            border-radius: var(--border-radius);
            cursor: grab;
            transition: var(--transition-normal);
            user-select: none;
        }

        .widget-item:hover {
            border-color: var(--border-hover);
            background: rgba(16, 185, 129, 0.05);
            transform: translateX(4px);
        }

        .widget-icon {
            font-size: var(--text-xl);
            width: 32px;
            text-align: center;
        }

        .widget-info {
            flex: 1;
        }

        .widget-name {
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            color: var(--text-white);
            margin-bottom: 2px;
        }

        .widget-description {
            font-size: var(--text-xs);
            color: var(--text-muted);
            line-height: 1.3;
        }
        
        .widget-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: var(--transition-normal);
        }
        
        .widget-item:hover .widget-actions {
            opacity: 1;
        }

        /* Canvas d'édition */
        .editor-canvas {
            grid-area: canvas;
            background: var(--bg-primary);
            position: relative;
            overflow: auto;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
        }

        .canvas-toolbar {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            padding: var(--spacing-sm) var(--spacing-md);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .canvas-workspace {
            flex: 1;
            padding: var(--spacing-lg);
            background: var(--bg-primary);
            color: var(--text-white);
            position: relative;
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(8, minmax(100px, 1fr));
            gap: 8px;
            grid-auto-rows: minmax(100px, auto);
        }
        
        /* Grille visible - lignes de la grille CSS */
        .canvas-workspace.show-grid {
            background-image: 
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent calc(100% / 12 - 1px),
                    rgba(16, 185, 129, 0.3) calc(100% / 12 - 1px),
                    rgba(16, 185, 129, 0.3) calc(100% / 12)
                ),
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent calc(100px - 1px),
                    rgba(16, 185, 129, 0.3) calc(100px - 1px),
                    rgba(16, 185, 129, 0.3) 100px
                );
        }
        
        /* Indicateurs de grille sur chaque cellule */
        .canvas-workspace.show-grid::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            background-image: 
                linear-gradient(rgba(16, 185, 129, 0.2) 1px, transparent 1px),
                linear-gradient(90deg, rgba(16, 185, 129, 0.2) 1px, transparent 1px);
            background-size: calc(100% / 12) 100px;
            z-index: 1;
        }

        /* Widget containers dans le canvas - Grille 2D */
        .widget-container {
            position: relative;
            padding: var(--spacing-md);
            background: var(--bg-card);
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius);
            transition: var(--transition-normal);
            cursor: move;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(5px);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            z-index: 10; /* Au-dessus de la grille */
        }
        
        .widget-container.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            z-index: 1000;
        }

        .widget-container:hover {
            border-color: var(--accent-green);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.2);
            border-style: solid;
        }

        .widget-container.selected {
            border-color: var(--accent-green);
            border-style: solid;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.4);
            background: rgba(16, 185, 129, 0.05);
        }
        
        /* Poignées de redimensionnement supprimées - utilisation des sliders dans l'onglet Organisation */
        
        /* Conteneur arrière-plan global adaptatif */
        .global-background-container {
            position: absolute;
            background: rgba(16, 185, 129, 0.05);
            border: 2px dashed rgba(16, 185, 129, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(2px);
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 0;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
        }
        
        .global-background-container.active {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.5);
            box-shadow: 0 0 30px rgba(16, 185, 129, 0.2);
        }

        .widget-container-header {
            position: absolute;
            top: -30px;
            left: 0;
            right: 0;
            background: var(--accent-green);
            color: white;
            padding: 4px 8px;
            border-radius: 4px 4px 0 0;
            font-size: var(--text-xs);
            font-weight: var(--font-bold);
            display: flex;
            align-items: center;
            justify-content: space-between;
            opacity: 0;
            transition: var(--transition-normal);
        }

        .widget-container:hover .widget-container-header,
        .widget-container.selected .widget-container-header {
            opacity: 1;
        }

        .widget-header-title {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .widget-header-controls {
            display: flex;
            gap: 4px;
        }

        .widget-control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .widget-control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Panneau de propriétés avancé */
        .properties-panel {
            grid-area: properties;
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            min-width: 280px;
            max-width: 600px;
            width: var(--properties-width, 350px);
            border-left: 1px solid var(--border-color);
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Handle de redimensionnement */
        .resize-handle {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--border-color);
            cursor: ew-resize;
            z-index: 10;
            opacity: 0;
            transition: all 0.2s ease;
            border-radius: 2px;
        }

        .resize-handle:hover,
        .resize-handle.resizing {
            opacity: 1;
            background: var(--accent-green);
            width: 6px;
            left: -1px;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.3);
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            left: -2px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 30px;
            background: transparent;
        }

        .properties-panel:hover .resize-handle {
            opacity: 0.6;
        }
        
        /* État collapsed du panneau propriétés */
        .properties-panel.collapsed {
            width: 40px !important;
            min-width: 40px;
            overflow: hidden;
        }
        
        .properties-panel.collapsed .properties-content {
            display: none;
        }
        
        .properties-panel.collapsed .properties-header {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            padding: var(--spacing-lg) var(--spacing-sm);
            justify-content: center;
            min-height: auto;
        }
        
        .properties-panel.collapsed .properties-title {
            font-size: var(--text-sm);
            writing-mode: vertical-rl;
        }
        
        .properties-panel.collapsed .properties-header-actions {
            position: absolute;
            top: var(--spacing-sm);
            left: 50%;
            transform: translateX(-50%);
        }
        
        .properties-panel.collapsed .properties-width-indicator {
            display: none;
        }

        .properties-header {
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, 
                rgba(30, 41, 59, 0.9) 0%, 
                rgba(30, 41, 59, 0.7) 100%);
            backdrop-filter: blur(15px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 60px;
        }

        .properties-title {
            font-size: var(--text-lg);
            font-weight: var(--font-semibold);
            color: var(--text-white);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .properties-header-actions {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .properties-collapse-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .properties-collapse-btn:hover {
            color: var(--text-white);
            background: rgba(255, 255, 255, 0.1);
        }

        .properties-width-indicator {
            font-size: var(--text-xs);
            color: var(--text-muted);
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
            min-width: 50px;
            text-align: center;
        }

        .properties-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            background: var(--bg-primary);
        }

        .properties-tabs {
            display: flex;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 5;
            margin: 0;
        }

        .properties-tab {
            flex: 1;
            padding: var(--spacing-md) var(--spacing-lg);
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-bottom: 3px solid transparent;
            font-size: var(--text-sm);
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .properties-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(16, 185, 129, 0.1) 0%, 
                rgba(16, 185, 129, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .properties-tab:hover {
            color: var(--text-white);
            transform: translateY(-1px);
        }

        .properties-tab:hover::before {
            opacity: 1;
        }

        .properties-tab.active {
            color: var(--accent-green);
            border-bottom-color: var(--accent-green);
            background: rgba(16, 185, 129, 0.15);
            font-weight: 600;
        }

        .properties-tab.active::before {
            opacity: 1;
        }

        .tab-content {
            display: none;
            padding: var(--spacing-lg);
            animation: fadeIn 0.3s ease-in-out;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .property-group {
            margin-bottom: var(--spacing-xl);
            background: var(--bg-card);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-lg);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .property-group:hover {
            border-color: var(--accent-green);
            box-shadow: 0 4px 20px rgba(16, 185, 129, 0.1);
        }

        .property-group h4 {
            color: var(--text-white);
            margin-bottom: var(--spacing-lg);
            font-size: var(--text-md);
            font-weight: var(--font-semibold);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            position: relative;
            padding-bottom: var(--spacing-sm);
        }

        .property-group h4::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-green), transparent);
            border-radius: 1px;
        }

        .property-group h4 i {
            color: var(--accent-green);
            font-size: 1.1em;
        }

        .property-field {
            margin-bottom: var(--spacing-md);
        }

        .property-label {
            display: block;
            color: var(--text-gray);
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            margin-bottom: var(--spacing-xs);
        }

        .property-control {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        /* 
        # Rôle      : Style spécialisé pour les contrôles de couleur verticaux
        # Type      : CSS classe
        # Unité     : sans unité 
        # Domaine   : éléments avec classe .property-color-control
        # Exemple   : bouton couleur au-dessus du champ hexadécimal
        */
        .property-color-control {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            align-items: stretch;
        }

        /* 
        # Rôle      : Bouton de sélection de couleur agrandi
        # Type      : CSS input[type="color"]
        # Unité     : pixels pour largeur/hauteur
        # Domaine   : 40px minimum pour accessibilité
        # Exemple   : 40x40px pour faciliter le clic
        */
        .property-color-control input[type="color"] {
            width: 100%;
            height: 40px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .property-color-control input[type="color"]:hover {
            border-color: var(--accent-green);
            transform: translateY(-1px);
        }

        .property-color-control input[type="color"]:focus {
            outline: none;
            border-color: var(--accent-green);
            box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.15);
        }

        .property-input {
            flex: 1;
            padding: var(--spacing-md);
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            color: var(--text-white);
            font-size: var(--text-sm);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .property-input:focus {
            outline: none;
            border-color: var(--accent-green);
            box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.15);
            transform: translateY(-1px);
        }

        .property-input:hover {
            border-color: rgba(16, 185, 129, 0.5);
        }

        .property-range {
            flex: 1;
            height: 6px;
            background: var(--bg-primary);
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }

        .property-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-green);
            border-radius: 50%;
            cursor: pointer;
        }

        .range-value {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: var(--border-radius);
            padding: 0.25rem 0.5rem;
            text-align: center;
            font-size: var(--text-xs);
            color: var(--accent-green);
            font-weight: var(--font-medium);
            min-width: 50px;
        }

        /* Viewer temps réel - Miroir du canvas */
        .editor-viewer {
            grid-area: viewer;
            background: var(--bg-card);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .viewer-header {
            padding: var(--spacing-sm) var(--spacing-md);
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .viewer-title {
            color: var(--text-white);
            font-weight: var(--font-semibold);
            font-size: var(--text-sm);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .viewer-controls {
            display: flex;
            gap: var(--spacing-xs);
        }

        .viewer-content {
            flex: 1;
            overflow: auto;
            padding: var(--spacing-md);
            background: var(--bg-primary);
            color: var(--text-white);
        }

        .presentation-preview {
            width: 100%;
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(8, minmax(80px, 1fr));
            gap: 6px;
            padding: 12px;
            min-height: 600px;
        }
        
        .preview-widget {
            border-radius: 6px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Boutons et contrôles */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-card);
            color: var(--text-white);
            cursor: pointer;
            transition: var(--transition-normal);
            text-decoration: none;
            min-height: 32px;
        }

        .btn:hover {
            border-color: var(--border-hover);
            background: var(--bg-secondary);
        }

        .btn.btn-primary {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }

        .btn.btn-primary:hover {
            background: #0d9488;
            border-color: #0d9488;
        }

        .btn.btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: var(--text-xs);
            min-height: 24px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* État vide */
        .empty-state {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: var(--text-muted);
        }

        .empty-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .empty-text {
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .empty-state.hidden {
            display: none;
        }

        /* Pied de page */
        .editor-footer {
            grid-area: footer;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-lg);
            font-size: var(--text-sm);
            color: var(--text-muted);
        }

        .footer-status {
            display: flex;
            align-items: center;
            gap: var(--spacing-lg);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success-green);
        }

        .status-indicator.error {
            background: var(--danger-red);
        }

        .status-indicator.warning {
            background: var(--warning-orange);
        }
        
        /* Animations */
        .widget-container {
            animation: slideInUp 0.3s ease-out;
        }
        
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .properties-panel {
                --properties-width: 300px;
                width: 300px;
            }
        }
        
        @media (max-width: 1024px) {
            .widget-editor {
                grid-template-areas: 
                    "toolbar toolbar"
                    "canvas properties"
                    "viewer viewer"
                    "footer footer";
                grid-template-columns: 1fr 280px;
            }
            
            .widget-library {
                display: none;
            }
            
            .properties-panel {
                --properties-width: 280px;
                width: 280px;
            }
            
            .properties-panel.collapsed {
                width: 30px !important;
            }
        }
        
        @media (max-width: 768px) {
            .widget-editor {
                grid-template-areas: 
                    "toolbar"
                    "canvas"
                    "properties"
                    "viewer"
                    "footer";
                grid-template-columns: 1fr;
                grid-template-rows: 60px 1fr 250px 150px 40px;
            }
            
            .properties-panel {
                --properties-width: 100%;
                width: 100% !important;
                height: 250px;
                border-left: none;
                border-top: 1px solid var(--border-color);
                position: relative;
            }
            
            .properties-panel.collapsed {
                height: 40px !important;
                width: 100% !important;
            }
            
            .properties-panel.collapsed .properties-header {
                writing-mode: horizontal-tb;
                text-orientation: mixed;
                padding: var(--spacing-sm) var(--spacing-lg);
                justify-content: space-between;
            }
            
            .properties-panel.collapsed .properties-title {
                writing-mode: horizontal-tb;
                font-size: var(--text-md);
            }
            
            .properties-panel.collapsed .properties-header-actions {
                position: relative;
                top: auto;
                left: auto;
                transform: none;
            }
            
            .resize-handle {
                display: none;
            }
        }
        
        @media (max-width: 480px) {
            .widget-editor {
                grid-template-rows: 50px 1fr 200px 120px 35px;
            }
            
            .toolbar-title {
                font-size: var(--text-md);
            }
            
            .properties-panel {
                height: 200px;
            }
            
            .properties-panel.collapsed {
                height: 35px !important;
            }
            
            .properties-header {
                padding: var(--spacing-sm);
                min-height: 35px;
            }
        }
    </style>
</head>
<body>
    <div class="widget-editor">
        <!-- Barre d'outils -->
        <div class="editor-toolbar">
            <div class="toolbar-left">
                <div class="toolbar-title">
                    <i class="fas fa-puzzle-piece"></i>
                    Éditeur de Widgets Complet
                </div>
            </div>
            
            <div class="toolbar-center">
                <button class="btn btn-primary" id="addWidgetBtn">
                    <i class="fas fa-plus"></i>
                    Ajouter Widget
                </button>
            </div>
            
            <div class="toolbar-right">
                <button class="btn btn-primary" id="saveBtn">
                    <i class="fas fa-save"></i>
                    Sauvegarder
                </button>
                <button class="btn" id="exportBtn">
                    <i class="fas fa-download"></i>
                    Exporter
                </button>
            </div>
        </div>

        <!-- Bibliothèque de widgets -->
        <div class="widget-library">
            <div class="library-header">
                <h3 class="library-title">Widgets Disponibles</h3>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="text" class="library-search" placeholder="Rechercher widgets et dossiers..." id="widgetSearch">
                    <button class="btn btn-sm" id="createFolderBtn" title="Créer un dossier">
                        <i class="fas fa-folder-plus"></i>
                    </button>
                </div>
            </div>
            
            <!-- Structure de dossiers -->
            <div class="library-content" id="widgetLibrary">
                <!-- Navigation par dossiers -->
                <div class="folder-structure" id="folderStructure">
                    <div class="folder-item active" data-folder="root">
                        <i class="fas fa-home folder-icon"></i>
                        <span class="folder-name">Tous les widgets</span>
                        <span class="folder-count" id="totalWidgetCount">5</span>
                    </div>
                    
                    <div class="folder-item" data-folder="favorites">
                        <i class="fas fa-star folder-icon"></i>
                        <span class="folder-name">Favoris</span>
                        <span class="folder-count">0</span>
                    </div>
                    
                    <div class="folder-item" data-folder="recent">
                        <i class="fas fa-clock folder-icon"></i>
                        <span class="folder-name">Récents</span>
                        <span class="folder-count">0</span>
                    </div>
                    
                    <!-- Dossiers personnalisés -->
                    <div id="customFolders">
                        <!-- Dossiers ajoutés dynamiquement -->
                    </div>
                </div>
                
                <!-- Section des sauvegardes -->
                <div class="saves-section" id="savesSection">
                    <div class="folder-item" style="font-weight: bold; color: var(--text-white);">
                        <i class="fas fa-save folder-icon"></i>
                        <span class="folder-name">Projets sauvegardés</span>
                        <span class="folder-count" id="savesCount">0</span>
                    </div>
                    
                    <div class="folder-children" id="savesList">
                        <!-- Projets sauvegardés -->
                    </div>
                </div>
                
                <!-- Widgets du dossier sélectionné -->
                <div id="widgetContent">
                    <!-- Widgets chargés dynamiquement selon le dossier -->
                </div>
                
                <!-- Résultats de recherche -->
                <div class="search-results" id="searchResults">
                    <!-- Résultats de recherche -->
                </div>
            </div>
        </div>

        <!-- Canvas d'édition -->
        <div class="editor-canvas">
            <div class="canvas-toolbar">
                <div class="canvas-tools">
                    <button class="btn btn-sm" id="selectModeBtn">
                        <i class="fas fa-mouse-pointer"></i>
                        Édition
                    </button>
                    <button class="btn btn-sm" id="gridToggleBtn" onclick="widgetEditor.toggleGrid()">
                        <i class="fas fa-th"></i>
                        Grille
                    </button>
                    <button class="btn btn-sm" id="backgroundToggleBtn" onclick="widgetEditor.toggleBackground()">
                        <i class="fas fa-square"></i>
                        Conteneur
                    </button>
                </div>
                
                <div class="canvas-info">
                    <span>Widgets: <span id="widgetCount">0</span></span>
                </div>
            </div>
            
            <div class="canvas-workspace" id="canvasWorkspace">
                <div class="empty-state" id="emptyState">
                    <div class="empty-icon">
                        <i class="fas fa-plus-circle"></i>
                    </div>
                    <div class="empty-text">
                        <strong>Canvas Vide</strong><br>
                        Cliquez sur "Ajouter Widget" ou glissez un widget depuis la bibliothèque
                    </div>
                    <button class="btn btn-primary" id="firstWidgetBtn">
                        <i class="fas fa-plus"></i>
                        Ajouter le premier widget
                    </button>
                </div>
            </div>
        </div>

        <!-- Panneau de propriétés -->
        <div class="properties-panel">
            <div class="resize-handle" id="propertiesResizeHandle"></div>
            <div class="properties-header">
                <div class="properties-title">
                    <i class="fas fa-sliders-h"></i>
                    Propriétés
                </div>
                <div class="properties-header-actions">
                    <div class="properties-width-indicator" id="widthIndicator">350px</div>
                    <button class="properties-collapse-btn" id="collapsePropertiesBtn" title="Réduire/Agrandir">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            </div>
            
            <div class="properties-content" id="propertiesContent">
                <div class="properties-tabs">
                    <button class="properties-tab active" data-tab="properties">Propriétés</button>
                    <button class="properties-tab" data-tab="elements">Éléments</button>
                    <button class="properties-tab" data-tab="organization">Organisation</button>
                </div>
                
                <div class="tab-content active" id="propertiesTab">
                    <div class="properties-empty">
                        <i class="fas fa-info-circle" style="font-size: 2rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                        <p>Sélectionnez un widget pour voir ses propriétés</p>
                    </div>
                </div>
                
                <div class="tab-content" id="elementsTab">
                    <div class="property-group">
                        <h4><i class="fas fa-list"></i> Éléments du Widget</h4>
                        <div id="elementsContainer">
                            <p style="color: var(--text-muted); font-style: italic;">Aucun widget sélectionné</p>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="organizationTab">
                    <div class="property-group">
                        <h4><i class="fas fa-expand-arrows-alt"></i> Taille & Position</h4>
                        
                        <div class="property-field">
                            <label class="property-label">Préréglages de taille</label>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <button class="btn btn-sm" id="fullScreenBtn" disabled>
                                    <i class="fas fa-expand"></i>
                                    Plein écran
                                </button>
                                <button class="btn btn-sm" id="fillParentBtn" disabled>
                                    <i class="fas fa-arrows-alt"></i>
                                    Remplir parent
                                </button>
                            </div>
                        </div>
                        
                        <div class="property-field">
                            <label class="property-label">Largeur (colonnes)</label>
                            <div class="property-control">
                                <input type="range" id="widthSlider" class="property-range" 
                                       min="1" max="12" value="3" disabled
                                       oninput="widgetEditor.updateWidgetSize('width', this.value)">
                                <input type="number" id="widthInput" class="property-input" 
                                       min="1" max="12" value="3" disabled
                                       style="width: 60px; text-align: center;"
                                       onchange="widgetEditor.updateWidgetSize('width', this.value)">
                            </div>
                        </div>
                        
                        <div class="property-field">
                            <label class="property-label">Hauteur (rangées)</label>
                            <div class="property-control">
                                <input type="range" id="heightSlider" class="property-range" 
                                       min="1" max="8" value="2" disabled
                                       oninput="widgetEditor.updateWidgetSize('height', this.value)">
                                <input type="number" id="heightInput" class="property-input" 
                                       min="1" max="8" value="2" disabled
                                       style="width: 60px; text-align: center;"
                                       onchange="widgetEditor.updateWidgetSize('height', this.value)">
                            </div>
                        </div>
                        
                        <div class="property-field">
                            <label class="property-label">Position - Colonne (1-12)</label>
                            <div class="property-control">
                                <input type="range" id="positionColSlider" class="property-range" 
                                       min="1" max="12" value="1" disabled
                                       oninput="widgetEditor.updateWidgetPosition('col', this.value)">
                                <input type="number" id="positionColInput" class="property-input" 
                                       min="1" max="12" value="1" disabled
                                       style="width: 60px; text-align: center;"
                                       onchange="widgetEditor.updateWidgetPosition('col', this.value)">
                            </div>
                        </div>
                        
                        <div class="property-field">
                            <label class="property-label">Position - Rangée (1-8)</label>
                            <div class="property-control">
                                <input type="range" id="positionRowSlider" class="property-range" 
                                       min="1" max="8" value="1" disabled
                                       oninput="widgetEditor.updateWidgetPosition('row', this.value)">
                                <input type="number" id="positionRowInput" class="property-input" 
                                       min="1" max="8" value="1" disabled
                                       style="width: 60px; text-align: center;"
                                       onchange="widgetEditor.updateWidgetPosition('row', this.value)">
                            </div>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <h4><i class="fas fa-arrows-alt"></i> Organisation</h4>
                        <div class="property-field">
                            <button class="btn btn-sm" id="moveUpBtn" disabled>
                                <i class="fas fa-arrow-up"></i>
                                Monter
                            </button>
                            <button class="btn btn-sm" id="moveDownBtn" disabled>
                                <i class="fas fa-arrow-down"></i>
                                Descendre
                            </button>
                        </div>
                        <div class="property-field">
                            <button class="btn btn-sm" id="duplicateBtn" disabled>
                                <i class="fas fa-copy"></i>
                                Dupliquer
                            </button>
                            <button class="btn btn-sm" id="deleteBtn" disabled>
                                <i class="fas fa-trash"></i>
                                Supprimer
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Viewer temps réel -->
        <div class="editor-viewer">
            <div class="viewer-header">
                <div class="viewer-title">
                    <i class="fas fa-desktop"></i>
                    Aperçu Temps Réel
                </div>
                <div class="viewer-controls">
                    <button class="btn btn-sm" id="refreshPreviewBtn">
                        <i class="fas fa-sync"></i>
                        Actualiser
                    </button>
                    <button class="btn btn-sm" id="fullscreenPreviewBtn">
                        <i class="fas fa-presentation"></i>
                        Prévisualisation finale
                    </button>
                </div>
            </div>
            
            <div class="viewer-content" id="viewerContent">
                <div class="presentation-preview" id="presentationPreview">
                    <div style="padding: 2rem; text-align: center; color: #6b7280;">
                        <i class="fas fa-eye" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;"></i>
                        <div>L'aperçu temps réel apparaîtra ici</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pied de page -->
        <div class="editor-footer">
            <div class="footer-status">
                <div class="status-item">
                    <div class="status-indicator" id="statusIndicator"></div>
                    <span id="statusText">Prêt</span>
                </div>
                <div class="status-item">
                    <span>Dernière sauvegarde: <span id="lastSave">Jamais</span></span>
                </div>
            </div>
            
            <div class="footer-actions">
                <span>Éditeur de Widgets Li-CUBE PRO™ v2.0</span>
            </div>
        </div>
    </div>

    <script>
        // ========================================================================
        // WIDGETS INTÉGRÉS - Tous les widgets du test-simple.html
        // ========================================================================
        
        class LogoWidget {
            constructor() {
                this.id = 'logo';
                this.name = 'Logo';
                this.category = 'Navigation';
                this.icon = '🏢';
                this.description = 'Logo avec image et effets hover';
                
                this.defaultData = {
                    imagePath: '../assets/images/logo-eds.png',
                    altText: 'Logo EDS Québec',
                    width: 60,
                    height: 60,
                    link: '#',
                    hoverEffect: true,
                    
                    // Propriétés d'arrière-plan avancées
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    backgroundOpacity: 10,
                    backgroundType: 'solid', // solid, gradient, transparent
                    gradientStart: '#10b981',
                    gradientEnd: '#065f46',
                    gradientDirection: 'to bottom',
                    
                    // Propriétés de bordure
                    borderColor: 'rgba(16, 185, 129, 0.3)',
                    borderWidth: 2,
                    borderStyle: 'solid', // solid, dashed, dotted, none
                    borderRadius: 12,
                    borderOpacity: 30,
                    
                    // Propriétés de l'image
                    imageSize: 80, // en pourcentage
                    imagePosition: 'center',
                    imageFit: 'contain', // contain, cover, fill
                    
                    // Propriétés d'ombrage
                    shadowEnabled: false,
                    shadowColor: '#000000',
                    shadowOpacity: 20,
                    shadowOffsetX: 0,
                    shadowOffsetY: 4,
                    shadowBlur: 8,
                    
                    // Propriétés de conteneur
                    containerPadding: 20,
                    containerAlignment: 'center'
                };
            }

            render(data = {}) {
                // Rôle      : Fusion des données par défaut avec les données fournies
                // Type      : Object
                // Unité     : sans unité
                // Domaine   : objet contenant toutes les propriétés du logo
                // Formule   : d = {...defaultData, ...data}
                // Exemple   : {width: 60, backgroundColor: '#ff0000', ...}
                const d = { ...this.defaultData, ...data };
                
                // Rôle      : Calcul de la couleur d'arrière-plan selon le type choisi
                // Type      : string (CSS)
                // Unité     : sans unité
                // Domaine   : couleur CSS valide ou transparent
                // Formule   : backgroundStyle = type === 'transparent' ? 'transparent' : (type === 'gradient' ? gradientCSS : solidColorCSS)
                // Exemple   : 'rgba(16, 185, 129, 0.1)' ou 'linear-gradient(to bottom, #10b981, #065f46)' ou 'transparent'
                let backgroundStyle;
                if (d.backgroundType === 'transparent') {
                    backgroundStyle = 'transparent';
                } else if (d.backgroundType === 'gradient') {
                    // Rôle      : Style CSS pour gradient linéaire
                    // Type      : string
                    // Unité     : sans unité
                    // Domaine   : gradient CSS valide
                    // Formule   : linear-gradient(direction, couleur_début, couleur_fin)
                    // Exemple   : 'linear-gradient(to bottom, #10b981, #065f46)'
                    backgroundStyle = `linear-gradient(${d.gradientDirection}, ${d.gradientStart}, ${d.gradientEnd})`;
                } else {
                    // Rôle      : Conversion de la couleur de base et opacité en rgba
                    // Type      : string
                    // Unité     : sans unité
                    // Domaine   : couleur rgba CSS
                    // Formule   : rgba basée sur backgroundColor et backgroundOpacity
                    // Exemple   : 'rgba(16, 185, 129, 0.1)' pour opacity=10%
                    const opacity = d.backgroundOpacity / 100;
                    if (d.backgroundColor.startsWith('#')) {
                        // Rôle      : Conversion hexadécimal vers RGB
                        // Type      : Object {r, g, b}
                        // Unité     : sans unité (valeurs 0-255)
                        // Domaine   : couleurs RGB valides
                        // Formule   : hex = parseInt(hex.slice(1,3), 16) pour chaque composante
                        // Exemple   : '#10b981' -> {r: 16, g: 185, b: 129}
                        const hex = d.backgroundColor.slice(1);
                        const r = parseInt(hex.slice(0, 2), 16);
                        const g = parseInt(hex.slice(2, 4), 16);
                        const b = parseInt(hex.slice(4, 6), 16);
                        backgroundStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    } else {
                        backgroundStyle = d.backgroundColor;
                    }
                }
                
                // Rôle      : Calcul de la couleur de bordure avec opacité
                // Type      : string (CSS)
                // Unité     : sans unité
                // Domaine   : couleur CSS avec opacité
                // Formule   : rgba basée sur borderColor et borderOpacity
                // Exemple   : 'rgba(16, 185, 129, 0.3)' pour borderOpacity=30%
                let borderColorStyle;
                const borderOpacity = d.borderOpacity / 100;
                if (d.borderColor.startsWith('#')) {
                    const hex = d.borderColor.slice(1);
                    const r = parseInt(hex.slice(0, 2), 16);
                    const g = parseInt(hex.slice(2, 4), 16);
                    const b = parseInt(hex.slice(4, 6), 16);
                    borderColorStyle = `rgba(${r}, ${g}, ${b}, ${borderOpacity})`;
                } else {
                    borderColorStyle = d.borderColor;
                }
                
                // Rôle      : Style de bordure complet selon les paramètres
                // Type      : string (CSS)
                // Unité     : pixels pour width, style et couleur
                // Domaine   : border CSS valide ou 'none'
                // Formule   : border = width + ' ' + style + ' ' + color ou 'none'
                // Exemple   : '2px solid rgba(16, 185, 129, 0.3)' ou 'none'
                const borderStyle = d.borderStyle === 'none' ? 'none' : `${d.borderWidth}px ${d.borderStyle} ${borderColorStyle}`;
                
                // Rôle      : Style d'ombrage si activé
                // Type      : string (CSS)
                // Unité     : pixels pour offset et blur, sans unité pour opacité
                // Domaine   : box-shadow CSS valide ou 'none'
                // Formule   : box-shadow = offsetX + 'px ' + offsetY + 'px ' + blur + 'px ' + color
                // Exemple   : '0px 4px 8px rgba(0, 0, 0, 0.2)' ou 'none'
                let shadowStyle = 'none';
                if (d.shadowEnabled) {
                    const shadowOpacity = d.shadowOpacity / 100;
                    let shadowColor;
                    if (d.shadowColor.startsWith('#')) {
                        const hex = d.shadowColor.slice(1);
                        const r = parseInt(hex.slice(0, 2), 16);
                        const g = parseInt(hex.slice(2, 4), 16);
                        const b = parseInt(hex.slice(4, 6), 16);
                        shadowColor = `rgba(${r}, ${g}, ${b}, ${shadowOpacity})`;
                    } else {
                        shadowColor = d.shadowColor;
                    }
                    shadowStyle = `${d.shadowOffsetX}px ${d.shadowOffsetY}px ${d.shadowBlur}px ${shadowColor}`;
                }
                
                return `
                    <div class="logo-container" style="text-align: ${d.containerAlignment}; 
                                                       padding: ${d.containerPadding}px; 
                                                       height: 100%;">
                        <a href="${d.link}" 
                           class="nav-logo logo-image ${d.hoverEffect ? 'hover-effect' : ''}"
                           style="display: inline-block; 
                                  width: ${d.width}px; 
                                  height: ${d.height}px; 
                                  border-radius: ${d.borderRadius}px; 
                                  background: ${backgroundStyle};
                                  border: ${borderStyle};
                                  background-image: url('${d.imagePath}');
                                  background-size: ${d.imageSize}%; 
                                  background-repeat: no-repeat; 
                                  background-position: ${d.imagePosition};
                                  object-fit: ${d.imageFit};
                                  box-shadow: ${shadowStyle};
                                  transition: all 0.3s ease;
                                  text-decoration: none;">
                            <span style="position: absolute; width: 1px; height: 1px; overflow: hidden;">
                                ${d.altText}
                            </span>
                        </a>
                    </div>
                `;
            }

            getEditableFields() {
                return [
                    // Configuration de base
                    { name: 'imagePath', label: 'Chemin de l\'image', type: 'text', category: 'Configuration' },
                    { name: 'altText', label: 'Texte alternatif', type: 'text', category: 'Configuration' },
                    { name: 'link', label: 'Lien de destination', type: 'text', category: 'Configuration' },
                    { name: 'hoverEffect', label: 'Effet au survol', type: 'checkbox', category: 'Configuration' },
                    
                    // Dimensions et position
                    { name: 'width', label: 'Largeur (px)', type: 'range', min: 30, max: 200, category: 'Dimensions' },
                    { name: 'height', label: 'Hauteur (px)', type: 'range', min: 30, max: 200, category: 'Dimensions' },
                    { name: 'containerPadding', label: 'Espacement conteneur (px)', type: 'range', min: 0, max: 50, category: 'Dimensions' },
                    { name: 'containerAlignment', label: 'Alignement', type: 'select', category: 'Dimensions', options: [
                        { value: 'left', label: 'Gauche' },
                        { value: 'center', label: 'Centre' },
                        { value: 'right', label: 'Droite' }
                    ]},
                    
                    // Arrière-plan
                    { name: 'backgroundType', label: 'Type d\'arrière-plan', type: 'select', category: 'Arrière-plan', options: [
                        { value: 'solid', label: 'Couleur unie' },
                        { value: 'gradient', label: 'Dégradé' },
                        { value: 'transparent', label: 'Transparent' }
                    ]},
                    { name: 'backgroundColor', label: 'Couleur de base', type: 'color', category: 'Arrière-plan' },
                    { name: 'backgroundOpacity', label: 'Opacité arrière-plan (%)', type: 'range', min: 0, max: 100, category: 'Arrière-plan' },
                    { name: 'gradientStart', label: 'Couleur début dégradé', type: 'color', category: 'Arrière-plan' },
                    { name: 'gradientEnd', label: 'Couleur fin dégradé', type: 'color', category: 'Arrière-plan' },
                    { name: 'gradientDirection', label: 'Direction dégradé', type: 'select', category: 'Arrière-plan', options: [
                        { value: 'to bottom', label: 'Vers le bas' },
                        { value: 'to top', label: 'Vers le haut' },
                        { value: 'to right', label: 'Vers la droite' },
                        { value: 'to left', label: 'Vers la gauche' },
                        { value: 'to bottom right', label: 'Diagonal bas-droite' },
                        { value: 'to bottom left', label: 'Diagonal bas-gauche' }
                    ]},
                    
                    // Bordures
                    { name: 'borderStyle', label: 'Style de bordure', type: 'select', category: 'Bordures', options: [
                        { value: 'none', label: 'Aucune' },
                        { value: 'solid', label: 'Solide' },
                        { value: 'dashed', label: 'Tirets' },
                        { value: 'dotted', label: 'Pointillés' }
                    ]},
                    { name: 'borderWidth', label: 'Épaisseur bordure (px)', type: 'range', min: 0, max: 10, category: 'Bordures' },
                    { name: 'borderColor', label: 'Couleur bordure', type: 'color', category: 'Bordures' },
                    { name: 'borderOpacity', label: 'Opacité bordure (%)', type: 'range', min: 0, max: 100, category: 'Bordures' },
                    { name: 'borderRadius', label: 'Arrondi des coins (px)', type: 'range', min: 0, max: 50, category: 'Bordures' },
                    
                    // Propriétés de l'image
                    { name: 'imageSize', label: 'Taille image (%)', type: 'range', min: 20, max: 100, category: 'Image' },
                    { name: 'imagePosition', label: 'Position de l\'image', type: 'select', category: 'Image', options: [
                        { value: 'center', label: 'Centre' },
                        { value: 'top', label: 'Haut' },
                        { value: 'bottom', label: 'Bas' },
                        { value: 'left', label: 'Gauche' },
                        { value: 'right', label: 'Droite' },
                        { value: 'top left', label: 'Haut-gauche' },
                        { value: 'top right', label: 'Haut-droite' },
                        { value: 'bottom left', label: 'Bas-gauche' },
                        { value: 'bottom right', label: 'Bas-droite' }
                    ]},
                    { name: 'imageFit', label: 'Ajustement image', type: 'select', category: 'Image', options: [
                        { value: 'contain', label: 'Contenir (proportions)' },
                        { value: 'cover', label: 'Couvrir (remplir)' },
                        { value: 'fill', label: 'Étirer (déformer)' }
                    ]},
                    
                    // Ombres
                    { name: 'shadowEnabled', label: 'Activer l\'ombre', type: 'checkbox', category: 'Ombres' },
                    { name: 'shadowColor', label: 'Couleur de l\'ombre', type: 'color', category: 'Ombres' },
                    { name: 'shadowOpacity', label: 'Opacité ombre (%)', type: 'range', min: 0, max: 100, category: 'Ombres' },
                    { name: 'shadowOffsetX', label: 'Décalage X (px)', type: 'range', min: -20, max: 20, category: 'Ombres' },
                    { name: 'shadowOffsetY', label: 'Décalage Y (px)', type: 'range', min: -20, max: 20, category: 'Ombres' },
                    { name: 'shadowBlur', label: 'Flou de l\'ombre (px)', type: 'range', min: 0, max: 30, category: 'Ombres' }
                ];
            }

            getElements() {
                return [
                    { id: 'container', name: 'Conteneur', editable: true },
                    { id: 'link', name: 'Lien', editable: true },
                    { id: 'image', name: 'Image', editable: true }
                ];
            }
        }

        class HeroTitleWidget {
            constructor() {
                this.id = 'hero-title';
                this.name = 'Titre Hero';
                this.category = 'Contenu';
                this.icon = '✨';
                this.description = 'Titre principal avec gradient';
                
                this.defaultData = {
                    title: 'Li-CUBE PRO™',
                    subtitle: 'LOCATION INTELLIGENTE ZÉRO RISQUE',
                    titleSize: 48,
                    subtitleSize: 24,
                    gradient: true,
                    animation: 'slide-up',
                    alignment: 'center',
                    backgroundColor: 'transparent',
                    borderRadius: 0
                };
            }

            render(data = {}) {
                const d = { ...this.defaultData, ...data };
                
                const gradientStyle = d.gradient ? 
                    'background: linear-gradient(135deg, #10b981, #0d9488); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;' : 
                    'color: #10b981;';
                
                const backgroundStyle = d.backgroundColor !== 'transparent' ? 
                    `background-color: ${d.backgroundColor}; ` : 
                    '';
                
                const borderRadiusStyle = d.borderRadius > 0 ? 
                    `border-radius: ${d.borderRadius}px; overflow: hidden; ` : 
                    '';
                
                return `
                    <div class="hero-section" style="text-align: ${d.alignment}; padding: 60px 20px; 
                                                   ${backgroundStyle}${borderRadiusStyle}
                                                   transition: all 0.3s ease;">
                        <h1 class="hero-title ${d.animation}" 
                            style="font-size: ${d.titleSize}px; font-weight: 900; 
                                   ${gradientStyle} margin-bottom: 20px; line-height: 1.1;
                                   animation-delay: 0.2s;">
                            ${d.title}
                        </h1>
                        <div class="hero-subtitle ${d.animation}"
                             style="font-size: ${d.subtitleSize}px; font-weight: 600; 
                                    color: #6b7280; line-height: 1.3; max-width: 600px; 
                                    margin: 0 auto; animation-delay: 0.4s;">
                            ${d.subtitle}
                        </div>
                    </div>
                `;
            }

            getEditableFields() {
                return [
                    { name: 'title', label: 'Titre', type: 'text', category: 'Contenu' },
                    { name: 'subtitle', label: 'Sous-titre', type: 'textarea', category: 'Contenu' },
                    { name: 'titleSize', label: 'Taille titre', type: 'range', min: 24, max: 72, category: 'Typographie' },
                    { name: 'subtitleSize', label: 'Taille sous-titre', type: 'range', min: 14, max: 36, category: 'Typographie' },
                    { name: 'gradient', label: 'Gradient', type: 'checkbox', category: 'Style' },
                    { name: 'alignment', label: 'Alignement', type: 'select', category: 'Layout', options: [
                        { value: 'left', label: 'Gauche' },
                        { value: 'center', label: 'Centre' },
                        { value: 'right', label: 'Droite' }
                    ]},
                    { name: 'backgroundColor', label: 'Couleur d\'arrière-plan', type: 'color', category: 'Style' },
                    { name: 'borderRadius', label: 'Arrondi des bords', type: 'range', min: 0, max: 50, category: 'Style' }
                ];
            }

            getElements() {
                return [
                    { id: 'section', name: 'Section Hero', editable: true },
                    { id: 'title', name: 'Titre principal', editable: true },
                    { id: 'subtitle', name: 'Sous-titre', editable: true }
                ];
            }
        }

        class PricingCardWidget {
            constructor() {
                this.id = 'pricing-card';
                this.name = 'Carte Tarification';
                this.category = 'Commerce';
                this.icon = '💰';
                this.description = 'Carte de prix complète';
                
                this.defaultData = {
                    planName: 'ESSENTIEL',
                    price: '299',
                    currency: '$',
                    period: '/mois',
                    ctaText: 'Choisir ce plan',
                    ctaLink: '#contact',
                    featured: false,
                    badge: '',
                    accentColor: '#10b981',
                    backgroundColor: '#1f2937',
                    textColor: '#ffffff',
                    features: [
                        'Installation gratuite',
                        'Maintenance incluse',
                        'Support par email',
                        'Jusqu\'à 50 équipements'
                    ]
                };
            }

            render(data = {}) {
                const d = { ...this.defaultData, ...data };
                
                const featuresHtml = d.features.map(feature => 
                    `<li style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; color: ${d.textColor || '#6b7280'};">
                        <span style="color: ${d.accentColor || '#10b981'}; font-size: 14px;">✓</span>
                        <span>${feature}</span>
                    </li>`
                ).join('');

                const badgeHtml = d.badge ? 
                    `<div class="pricing-badge" style="position: absolute; top: -10px; left: 50%; 
                                                      transform: translateX(-50%); background: ${d.accentColor || '#10b981'}; 
                                                      color: white; padding: 4px 12px; border-radius: 6px; 
                                                      font-size: 12px; font-weight: bold;">
                        ${d.badge}
                    </div>` : '';

                return `
                    <div class="pricing-card ${d.featured ? 'featured' : ''}" 
                         style="background: ${d.backgroundColor || '#1f2937'}; 
                                border: 2px solid ${d.featured ? (d.accentColor || '#10b981') : '#374151'}; 
                                border-radius: 12px; padding: 32px; text-align: center; position: relative; 
                                backdrop-filter: blur(10px); margin: 20px; color: ${d.textColor || '#ffffff'};">
                        ${badgeHtml}
                        
                        <div style="margin-bottom: 32px;">
                            <h3 style="font-size: 1.25rem; font-weight: bold; color: ${d.textColor || 'white'}; margin-bottom: 20px; 
                                       text-transform: uppercase; letter-spacing: 0.05em;">
                                ${d.planName}
                            </h3>
                            
                            <div style="display: flex; align-items: baseline; justify-content: center; gap: 8px; margin-bottom: 20px;">
                                <span style="font-size: 2rem; font-weight: 600; color: ${d.accentColor || '#10b981'};">${d.currency}</span>
                                <span style="font-size: 3.5rem; font-weight: 900; color: ${d.textColor || 'white'}; line-height: 1;">${d.price}</span>
                                <span style="font-size: 1.125rem; color: #9ca3af; font-weight: 500;">${d.period}</span>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 32px;">
                            <ul style="list-style: none; padding: 0; margin: 0; text-align: left;">
                                ${featuresHtml}
                            </ul>
                        </div>
                        
                        <div>
                            <a href="${d.ctaLink}" 
                               style="width: 100%; padding: 16px 24px; background: ${d.accentColor || '#10b981'}; color: white;
                                      border: none; border-radius: 8px; font-size: 1rem; font-weight: 600;
                                      text-transform: uppercase; letter-spacing: 0.05em; transition: all 0.3s;
                                      text-decoration: none; display: inline-block; cursor: pointer;">
                                ${d.ctaText}
                            </a>
                        </div>
                    </div>
                `;
            }

            getEditableFields() {
                return [
                    { name: 'planName', label: 'Nom du plan', type: 'text', category: 'Contenu' },
                    { name: 'price', label: 'Prix', type: 'text', category: 'Contenu' },
                    { name: 'currency', label: 'Devise', type: 'text', category: 'Contenu' },
                    { name: 'period', label: 'Période', type: 'text', category: 'Contenu' },
                    { name: 'ctaText', label: 'Texte bouton', type: 'text', category: 'Contenu' },
                    { name: 'ctaLink', label: 'Lien bouton', type: 'text', category: 'Contenu' },
                    { name: 'featured', label: 'Plan vedette', type: 'checkbox', category: 'Contenu' },
                    { name: 'badge', label: 'Badge', type: 'text', category: 'Contenu' },
                    { name: 'accentColor', label: 'Couleur principale', type: 'color', category: 'Style' },
                    { name: 'backgroundColor', label: 'Couleur de fond', type: 'color', category: 'Style' },
                    { name: 'textColor', label: 'Couleur du texte', type: 'color', category: 'Style' }
                ];
            }

            getElements() {
                return [
                    { id: 'card', name: 'Carte principale', editable: true },
                    { id: 'header', name: 'En-tête', editable: true },
                    { id: 'price', name: 'Prix', editable: true },
                    { id: 'features', name: 'Fonctionnalités', editable: true, manageable: true },
                    { id: 'cta', name: 'Bouton action', editable: true }
                ];
            }
            
            // Méthodes pour gestion dynamique des fonctionnalités
            addFeature(newFeature) {
                if (!newFeature || newFeature.trim() === '') return;
                this.defaultData.features.push(newFeature.trim());
            }
            
            removeFeature(index) {
                if (index >= 0 && index < this.defaultData.features.length) {
                    this.defaultData.features.splice(index, 1);
                }
            }
            
            updateFeature(index, newText) {
                if (index >= 0 && index < this.defaultData.features.length) {
                    this.defaultData.features[index] = newText;
                }
            }
        }

        class CallToActionWidget {
            constructor() {
                this.id = 'call-to-action';
                this.name = 'Call to Action';
                this.category = 'Action';
                this.icon = '🎯';
                this.description = 'Section d\'appel à l\'action';
                
                this.defaultData = {
                    title: 'Prêt à commencer ?',
                    description: 'Contactez-nous dès aujourd\'hui pour une consultation gratuite',
                    primaryButtonText: 'Nous Contacter',
                    primaryButtonLink: '#contact',
                    secondaryButtonText: 'En savoir plus',
                    secondaryButtonLink: '#info',
                    backgroundColor: '#10b981',
                    showSecondaryButton: true
                };
            }

            render(data = {}) {
                const d = { ...this.defaultData, ...data };
                
                const secondaryButton = d.showSecondaryButton ? 
                    `<a href="${d.secondaryButtonLink}" 
                       style="padding: 12px 24px; background: transparent; color: white; 
                              border: 2px solid white; border-radius: 8px; font-weight: 600; 
                              text-decoration: none; margin-left: 16px; display: inline-block;">
                        ${d.secondaryButtonText}
                    </a>` : '';

                return `
                    <div class="cta-section" 
                         style="background: ${d.backgroundColor}; color: white; padding: 80px 20px; 
                                text-align: center; margin: 40px 0;">
                        <h2 style="font-size: 2.5rem; font-weight: bold; margin-bottom: 20px;">
                            ${d.title}
                        </h2>
                        <p style="font-size: 1.25rem; margin-bottom: 40px; max-width: 600px; margin-left: auto; margin-right: auto;">
                            ${d.description}
                        </p>
                        <div class="cta-buttons">
                            <a href="${d.primaryButtonLink}" 
                               style="padding: 16px 32px; background: white; color: ${d.backgroundColor}; 
                                      border-radius: 8px; font-size: 1.125rem; font-weight: 600; 
                                      text-decoration: none; display: inline-block;">
                                ${d.primaryButtonText}
                            </a>
                            ${secondaryButton}
                        </div>
                    </div>
                `;
            }

            getEditableFields() {
                return [
                    { name: 'title', label: 'Titre', type: 'text' },
                    { name: 'description', label: 'Description', type: 'textarea' },
                    { name: 'primaryButtonText', label: 'Texte bouton principal', type: 'text' },
                    { name: 'primaryButtonLink', label: 'Lien bouton principal', type: 'text' },
                    { name: 'secondaryButtonText', label: 'Texte bouton secondaire', type: 'text' },
                    { name: 'secondaryButtonLink', label: 'Lien bouton secondaire', type: 'text' },
                    { name: 'showSecondaryButton', label: 'Afficher bouton secondaire', type: 'checkbox' },
                    { name: 'backgroundColor', label: 'Couleur de fond', type: 'color' }
                ];
            }

            getElements() {
                return [
                    { id: 'section', name: 'Section CTA', editable: true },
                    { id: 'title', name: 'Titre', editable: true },
                    { id: 'description', name: 'Description', editable: true },
                    { id: 'buttons', name: 'Boutons', editable: true }
                ];
            }
        }

        class FeatureGridWidget {
            constructor() {
                this.id = 'feature-grid';
                this.name = 'Grille de Fonctionnalités';
                this.category = 'Contenu';
                this.icon = '⭐';
                this.description = 'Grille de fonctionnalités avec icônes éditables';
                
                this.defaultData = {
                    title: 'Pourquoi Nous Choisir ?',
                    features: [
                        {
                            icon: '🚀',
                            title: 'Performance',
                            description: 'Des solutions rapides et efficaces',
                            iconSize: '3rem',
                            titleColor: 'white',
                            titleSize: '1.5rem',
                            descriptionColor: 'var(--text-gray)',
                            descriptionSize: '0.95rem',
                            backgroundColor: 'var(--bg-card)',
                            borderColor: 'var(--border-color)'
                        },
                        {
                            icon: '🔒',
                            title: 'Sécurité',
                            description: 'Protection maximale de vos données',
                            iconSize: '3rem',
                            titleColor: 'white',
                            titleSize: '1.5rem',
                            descriptionColor: 'var(--text-gray)',
                            descriptionSize: '0.95rem',
                            backgroundColor: 'var(--bg-card)',
                            borderColor: 'var(--border-color)'
                        },
                        {
                            icon: '💡',
                            title: 'Innovation',
                            description: 'Technologies de pointe',
                            iconSize: '3rem',
                            titleColor: 'white',
                            titleSize: '1.5rem',
                            descriptionColor: 'var(--text-gray)',
                            descriptionSize: '0.95rem',
                            backgroundColor: 'var(--bg-card)',
                            borderColor: 'var(--border-color)'
                        },
                        {
                            icon: '🤝',
                            title: 'Support',
                            description: 'Équipe dédiée à votre service',
                            iconSize: '3rem',
                            titleColor: 'white',
                            titleSize: '1.5rem',
                            descriptionColor: 'var(--text-gray)',
                            descriptionSize: '0.95rem',
                            backgroundColor: 'var(--bg-card)',
                            borderColor: 'var(--border-color)'
                        },
                        {
                            icon: '🎯',
                            title: 'Précision',
                            description: 'Résultats ciblés et mesurables',
                            iconSize: '3rem',
                            titleColor: 'white',
                            titleSize: '1.5rem',
                            descriptionColor: 'var(--text-gray)',
                            descriptionSize: '0.95rem',
                            backgroundColor: 'var(--bg-card)',
                            borderColor: 'var(--border-color)'
                        },
                        {
                            icon: '🌟',
                            title: 'Excellence',
                            description: 'Standards de qualité élevés',
                            iconSize: '3rem',
                            titleColor: 'white',
                            titleSize: '1.5rem',
                            descriptionColor: 'var(--text-gray)',
                            descriptionSize: '0.95rem',
                            backgroundColor: 'var(--bg-card)',
                            borderColor: 'var(--border-color)'
                        }
                    ],
                    columns: 3,
                    featuresCount: 4
                };
            }

            render(data = {}) {
                const d = { ...this.defaultData, ...data };
                
                // Limiter les features affichées selon featuresCount
                const displayedFeatures = d.features.slice(0, d.featuresCount || 4);
                
                const featuresHtml = displayedFeatures.map(feature => 
                    `<div class="feature-card" 
                          style="background: ${feature.backgroundColor || 'var(--bg-card)'}; 
                                 padding: 32px; border-radius: 12px; 
                                 text-align: center; 
                                 border: 1px solid ${feature.borderColor || 'var(--border-color)'}; 
                                 transition: transform 0.3s ease, box-shadow 0.3s ease;">
                        <div style="font-size: ${feature.iconSize || '3rem'}; margin-bottom: 20px; line-height: 1;">${feature.icon || '⭐'}</div>
                        <h3 style="color: ${feature.titleColor || 'white'}; 
                                   font-size: ${feature.titleSize || '1.5rem'}; 
                                   margin-bottom: 16px; font-weight: bold;">
                            ${feature.title || 'Titre'}
                        </h3>
                        <p style="color: ${feature.descriptionColor || 'var(--text-gray)'}; 
                                  line-height: 1.6; 
                                  font-size: ${feature.descriptionSize || '0.95rem'};">
                            ${feature.description || 'Description de la fonctionnalité'}
                        </p>
                    </div>`
                ).join('');

                return `
                    <div class="features-section" style="padding: 80px 20px; background: var(--bg-primary);">
                        <h2 style="text-align: center; font-size: 2.5rem; font-weight: bold; 
                                   color: white; margin-bottom: 60px; line-height: 1.2;">
                            ${d.title}
                        </h2>
                        <div class="features-grid" 
                             style="display: grid; grid-template-columns: repeat(${d.columns}, 1fr); 
                                    gap: 32px; max-width: 1400px; margin: 0 auto; width: 100%;">
                            ${featuresHtml}
                        </div>
                    </div>
                `;
            }

            getEditableFields() {
                return [
                    { name: 'title', label: 'Titre principal', type: 'text' },
                    { name: 'featuresCount', label: 'Nombre de fonctionnalités', type: 'range', min: 1, max: 12 },
                    { name: 'columns', label: 'Colonnes dans la grille', type: 'range', min: 1, max: 4 }
                ];
            }

            getElements() {
                return [
                    { id: 'section', name: 'Section fonctionnalités', editable: true },
                    { id: 'title', name: 'Titre principal', editable: true },
                    { id: 'grid', name: 'Grille', editable: true },
                    { id: 'features', name: 'Fonctionnalités individuelles', editable: true }
                ];
            }
            
            // Méthodes pour gérer les fonctionnalités
            addFeature() {
                if (!this.defaultData.features) this.defaultData.features = [];
                this.defaultData.features.push({
                    icon: '⭐',
                    title: 'Nouvelle fonctionnalité',
                    description: 'Description de la fonctionnalité'
                });
            }
            
            removeFeature(index) {
                if (this.defaultData.features && index >= 0 && index < this.defaultData.features.length) {
                    this.defaultData.features.splice(index, 1);
                }
            }
            
            updateFeature(index, field, value) {
                if (this.defaultData.features && index >= 0 && index < this.defaultData.features.length) {
                    this.defaultData.features[index][field] = value;
                }
            }
        }

        // ========================================================================
        // ÉDITEUR DE WIDGETS COMPLET
        // ========================================================================

        class WidgetEditorComplete {
            constructor() {
                this.widgets = [];
                this.selectedWidget = null;
                
                // Widgets disponibles
                this.availableWidgets = [
                    LogoWidget,
                    HeroTitleWidget,
                    PricingCardWidget,
                    CallToActionWidget,
                    FeatureGridWidget
                ];
                
                // Système de dossiers et de recherche
                this.currentFolder = 'root';
                this.searchTerm = '';
                this.folders = {
                    root: { name: 'Tous les widgets', widgets: [], type: 'system' },
                    favorites: { name: 'Favoris', widgets: [], type: 'system' },
                    recent: { name: 'Récents', widgets: [], type: 'system' }
                };
                this.savedProjects = [];
                this.recentWidgets = new Set();
                this.favoriteWidgets = new Set();
                
                this.widgetCategories = {
                    'Navigation': [],
                    'Contenu': [],
                    'Commerce': [],
                    'Action': []
                };
                
                this.init();
            }

            init() {
                this.setupWidgetCategories();
                this.setupEventListeners();
                this.renderWidgetLibrary();
                this.updatePreview();
                this.setStatus('Éditeur prêt', 'success');
            }

            setupWidgetCategories() {
                this.availableWidgets.forEach(WidgetClass => {
                    const instance = new WidgetClass();
                    if (!this.widgetCategories[instance.category]) {
                        this.widgetCategories[instance.category] = [];
                    }
                    this.widgetCategories[instance.category].push(instance);
                });
            }

            setupEventListeners() {
                // Boutons principaux
                document.getElementById('addWidgetBtn').addEventListener('click', () => this.showAddWidgetDialog());
                document.getElementById('firstWidgetBtn').addEventListener('click', () => this.showAddWidgetDialog());
                document.getElementById('saveBtn').addEventListener('click', () => this.saveProject());
                document.getElementById('exportBtn').addEventListener('click', () => this.exportProject());
                
                // Onglets propriétés
                document.querySelectorAll('.properties-tab').forEach(tab => {
                    tab.addEventListener('click', () => this.switchPropertiesTab(tab.dataset.tab));
                });
                
                // Boutons organisation
                document.getElementById('moveUpBtn').addEventListener('click', () => this.moveWidget(-1));
                document.getElementById('moveDownBtn').addEventListener('click', () => this.moveWidget(1));
                document.getElementById('duplicateBtn').addEventListener('click', () => this.duplicateWidget());
                document.getElementById('deleteBtn').addEventListener('click', () => this.deleteWidget());
                
                // Boutons préréglages de taille
                document.getElementById('fullScreenBtn').addEventListener('click', () => this.setFullScreen());
                document.getElementById('fillParentBtn').addEventListener('click', () => this.fillParent());
                
                // Recherche et navigation par dossiers
                const searchInput = document.getElementById('widgetSearch');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => this.handleSearch(e.target.value));
                }
                
                // Gestion des dossiers
                document.addEventListener('click', (e) => {
                    if (e.target.closest('.folder-item')) {
                        const folderItem = e.target.closest('.folder-item');
                        const folderId = folderItem.dataset.folder;
                        if (folderId) {
                            this.selectFolder(folderId);
                        }
                    }
                });
                
                // Création de dossier
                const createFolderBtn = document.getElementById('createFolderBtn');
                if (createFolderBtn) {
                    createFolderBtn.addEventListener('click', () => this.createNewFolder());
                }
                
                // Chargement des données locales
                this.loadLocalData();
                
                // Refresh preview
                document.getElementById('refreshPreviewBtn').addEventListener('click', () => this.updatePreview());
                
                // Prévisualisation plein écran
                document.getElementById('fullscreenPreviewBtn').addEventListener('click', () => this.openFullscreenPreview());
                document.getElementById('closePreviewBtn').addEventListener('click', () => this.closeFullscreenPreview());
                
                // Fermer la popup avec Échap
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.closeFullscreenPreview();
                    }
                });
                
                // Système de redimensionnement du panneau propriétés
                this.setupPropertiesResize();
                
                // Bouton de collapse du panneau propriétés
                document.getElementById('collapsePropertiesBtn').addEventListener('click', () => this.togglePropertiesPanel());
                
                // Event pour clic sur workspace (désélection)
                const workspace = document.getElementById('canvasWorkspace');
                if (workspace) {
                    workspace.addEventListener('click', (e) => {
                        if (e.target === workspace) {
                            this.selectWidget(null);
                        }
                    });
                }
            }

            // Nouvelle méthode : rendu de la bibliothèque avec dossiers
            renderWidgetLibrary() {
                this.updateFolderStructure();
                this.renderCurrentFolder();
                this.loadSavedProjects();
            }
            
            // Mise à jour de la structure des dossiers
            updateFolderStructure() {
                // Mettre à jour les compteurs
                const totalWidgetCountEl = document.getElementById('totalWidgetCount');
                if (totalWidgetCountEl) {
                    totalWidgetCountEl.textContent = this.availableWidgets.length;
                }
                
                // Répartir les widgets dans les dossiers
                this.folders.root.widgets = this.availableWidgets;
                this.folders.favorites.widgets = this.availableWidgets.filter(w => this.favoriteWidgets.has(w.id));
                this.folders.recent.widgets = Array.from(this.recentWidgets).map(id => 
                    this.availableWidgets.find(w => w.id === id)).filter(Boolean);
                    
                // Mettre à jour les compteurs dans l'UI
                const favoritesCountEl = document.querySelector('.folder-item[data-folder="favorites"] .folder-count');
                if (favoritesCountEl) {
                    favoritesCountEl.textContent = this.folders.favorites.widgets.length || '0';
                }
                const recentCountEl = document.querySelector('.folder-item[data-folder="recent"] .folder-count');
                if (recentCountEl) {
                    recentCountEl.textContent = this.folders.recent.widgets.length || '0';
                }
            }
            
            // Rendu du dossier actuel
            renderCurrentFolder() {
                const content = document.getElementById('widgetContent');
                if (!content) return;
                
                const currentFolderData = this.folders[this.currentFolder];
                
                if (!currentFolderData) {
                    content.innerHTML = '<div style="padding: 1rem; color: var(--text-muted);">Dossier introuvable</div>';
                    return;
                }
                
                content.innerHTML = '';
                
                if (this.currentFolder === 'root') {
                    // Afficher par catégories pour "Tous les widgets"
                    Object.entries(this.widgetCategories).forEach(([category, widgets]) => {
                        if (widgets.length === 0) return;
                        
                        const categoryDiv = document.createElement('div');
                        categoryDiv.className = 'widget-category';
                        
                        const categoryTitle = document.createElement('div');
                        categoryTitle.className = 'category-title';
                        categoryTitle.textContent = category;
                        categoryDiv.appendChild(categoryTitle);
                        
                        widgets.forEach(widget => {
                            const widgetItem = this.createWidgetItem(widget);
                            categoryDiv.appendChild(widgetItem);
                        });
                        
                        content.appendChild(categoryDiv);
                    });
                } else {
                    // Afficher les widgets du dossier sélectionné
                    const widgets = currentFolderData.widgets;
                    if (widgets.length === 0) {
                        content.innerHTML = `
                            <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
                                <i class="fas fa-inbox" style="font-size: 2rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                                <div>Aucun widget dans ce dossier</div>
                            </div>
                        `;
                        return;
                    }
                    
                    widgets.forEach(widget => {
                        const widgetItem = this.createWidgetItem(widget);
                        content.appendChild(widgetItem);
                    });
                }
            }

            createWidgetItem(widget) {
                const item = document.createElement('div');
                item.className = 'widget-item';
                item.dataset.widgetType = widget.id;
                
                const isFavorite = this.favoriteWidgets.has(widget.id);
                const isRecent = this.recentWidgets.has(widget.id);
                
                item.innerHTML = `
                    <div class="widget-icon">
                        <i class="${widget.icon || 'fas fa-puzzle-piece'}"></i>
                    </div>
                    <div class="widget-info">
                        <div class="widget-name">${widget.name}</div>
                        <div class="widget-description">${widget.description}</div>
                    </div>
                    <div class="widget-actions">
                        <button class="btn btn-sm" onclick="event.stopPropagation(); widgetEditor.toggleFavorite('${widget.id}')" 
                                title="${isFavorite ? 'Retirer des favoris' : 'Ajouter aux favoris'}">
                            <i class="fas fa-star" style="color: ${isFavorite ? '#fbbf24' : 'var(--text-muted)'}"></i>
                        </button>
                        <button class="btn btn-sm" onclick="event.stopPropagation(); widgetEditor.addWidget('${widget.id}')" title="Ajouter">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                `;
                
                // Clic sur l'item entier = ajouter le widget
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.widget-actions')) {
                        this.addWidget(widget.id);
                    }
                });
                
                return item;
            }

            showAddWidgetDialog() {
                // Pour simplifier, ajouter directement un widget par défaut
                this.addWidget('hero-title');
            }

            addWidget(widgetType) {
                const WidgetClass = this.availableWidgets.find(w => new w().id === widgetType);
                if (!WidgetClass) return;
                
                // Ajouter aux récents
                this.addToRecent(widgetType);
                
                const widgetInstance = new WidgetClass();
                
                // Position sera définie après la taille
                let position;
                
                // Définir une taille par défaut selon le type de widget
                let defaultSize = { width: 3, height: 2 };
                switch (widgetType) {
                    case 'feature-grid':
                        defaultSize = { width: 8, height: 4 }; // Plus large pour éviter le crop
                        break;
                    case 'hero-title':
                        defaultSize = { width: 6, height: 3 };
                        break;
                    case 'pricing-card':
                        defaultSize = { width: 4, height: 4 };
                        break;
                    case 'call-to-action':
                        defaultSize = { width: 8, height: 2 };
                        break;
                    case 'logo':
                        defaultSize = { width: 2, height: 1 };
                        break;
                    default:
                        defaultSize = { width: 3, height: 2 };
                }
                
                // Trouver une position libre avec la taille appropriée (centre vers l'extérieur)
                position = this.findFreeGridPosition(defaultSize.width, defaultSize.height);
                
                const widgetData = {
                    id: `widget-${Date.now()}`,
                    type: widgetType,
                    instance: widgetInstance,
                    data: { ...widgetInstance.defaultData },
                    position: position,
                    size: defaultSize
                };
                
                this.widgets.push(widgetData);
                this.saveToHistory('Ajout widget');
                this.renderCanvas();
                this.selectWidget(widgetData.id);
                this.updatePreview();
                
                // Masquer l'état vide
                const emptyState = document.getElementById('emptyState');
                if (emptyState) {
                    emptyState.classList.add('hidden');
                    emptyState.style.display = 'none';
                }
                
                document.getElementById('widgetCount').textContent = this.widgets.length;
                
                // Mettre à jour le conteneur arrière-plan si activé
                this.updateBackgroundContainer();
                
                this.setStatus(`Widget ${widgetInstance.name} ajouté`, 'success');
            }

            renderCanvas() {
                const workspace = document.getElementById('canvasWorkspace');
                const emptyState = document.getElementById('emptyState');
                
                // Toujours supprimer les widgets existants du DOM en premier
                workspace.querySelectorAll('.widget-container').forEach(w => w.remove());
                
                if (this.widgets.length === 0) {
                    emptyState.classList.remove('hidden');
                    emptyState.style.display = 'flex';
                    return;
                }
                
                emptyState.classList.add('hidden');
                emptyState.style.display = 'none';
                
                this.widgets.forEach((widget, index) => {
                    const container = this.createWidgetContainer(widget, index);
                    workspace.appendChild(container);
                });
            }

            createWidgetContainer(widget, index) {
                const container = document.createElement('div');
                container.className = 'widget-container';
                container.dataset.widgetId = widget.id;
                
                // Position sur la grille
                const pos = widget.position || { col: 1, row: 1 };
                const size = widget.size || { width: 3, height: 2 };
                
                container.style.gridColumnStart = pos.col;
                container.style.gridColumnEnd = pos.col + size.width;
                container.style.gridRowStart = pos.row;
                container.style.gridRowEnd = pos.row + size.height;
                
                const headerContent = `
                    <div class="widget-header-title">
                        <span>${widget.instance.icon}</span>
                        <span>${widget.instance.name}</span>
                    </div>
                    <div class="widget-header-controls">
                        <button class="widget-control-btn" onclick="widgetEditor.duplicateWidget('${widget.id}')" title="Dupliquer">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="widget-control-btn" onclick="widgetEditor.deleteWidget('${widget.id}')" title="Supprimer">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
                
                container.innerHTML = `
                    <div class="widget-container-header">${headerContent}</div>
                    <div class="widget-content" style="flex: 1;">${widget.instance.render(widget.data)}</div>
                `;
                
                // Events
                container.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectWidget(widget.id);
                });
                
                // Drag & drop pour placement libre
                this.setupDragDrop(container, widget);
                
                return container;
            }

            selectWidget(widgetId) {
                // Désélectionner l'ancien
                document.querySelectorAll('.widget-container.selected').forEach(w => {
                    w.classList.remove('selected');
                });
                
                if (widgetId) {
                    // Sélectionner le nouveau
                    const container = document.querySelector(`[data-widget-id="${widgetId}"]`);
                    if (container) {
                        container.classList.add('selected');
                        this.selectedWidget = this.widgets.find(w => w.id === widgetId);
                        this.updatePropertiesPanel();
                    }
                } else {
                    // Désélection
                    this.selectedWidget = null;
                    this.updatePropertiesPanel();
                }
            }

            updatePropertiesPanel() {
                if (!this.selectedWidget) {
                    document.getElementById('propertiesTab').innerHTML = `
                        <div class="properties-empty">
                            <i class="fas fa-info-circle" style="font-size: 2rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                            <p>Sélectionnez un widget pour voir ses propriétés</p>
                        </div>
                    `;
                    return;
                }
                
                const widget = this.selectedWidget;
                const fields = widget.instance.getEditableFields();
                
                let propertiesHtml = `
                    <div class="property-group">
                        <h4><i class="fas fa-info-circle"></i> Informations</h4>
                        <div style="color: var(--text-muted); margin-bottom: 1rem;">
                            Type: ${widget.instance.name}<br>
                            ID: ${widget.id}
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <h4><i class="fas fa-sliders-h"></i> Propriétés</h4>
                `;
                
                fields.forEach(field => {
                    propertiesHtml += this.createPropertyField(field, widget);
                });
                
                propertiesHtml += '</div>';
                
                document.getElementById('propertiesTab').innerHTML = propertiesHtml;
                
                // Update elements tab
                this.updateElementsTab();
            }

            createPropertyField(field, widget) {
                const value = widget.data[field.name];
                const fieldId = `prop-${field.name}`;
                
                let inputHtml = '';
                
                switch (field.type) {
                    case 'text':
                        inputHtml = `
                            <input type="text" id="${fieldId}" class="property-input" 
                                   value="${value}" 
                                   onchange="widgetEditor.updateProperty('${field.name}', this.value)"
                                   oninput="widgetEditor.updateProperty('${field.name}', this.value)">
                        `;
                        break;
                        
                    case 'textarea':
                        inputHtml = `
                            <textarea id="${fieldId}" class="property-input" rows="3"
                                      onchange="widgetEditor.updateProperty('${field.name}', this.value)"
                                      oninput="widgetEditor.updateProperty('${field.name}', this.value)">${value}</textarea>
                        `;
                        break;
                        
                    case 'range':
                        inputHtml = `
                            <div class="property-control">
                                <input type="range" id="${fieldId}" class="property-range" 
                                       min="${field.min || 0}" max="${field.max || 100}" value="${value}"
                                       oninput="widgetEditor.updateProperty('${field.name}', this.value)"
                                       onchange="widgetEditor.updateProperty('${field.name}', this.value)">
                                <span class="range-value" id="${fieldId}-value">${value}</span>
                            </div>
                        `;
                        break;
                        
                    case 'checkbox':
                        inputHtml = `
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="${fieldId}" ${value ? 'checked' : ''} 
                                       onchange="widgetEditor.updateProperty('${field.name}', this.checked)">
                                <span>Activé</span>
                            </label>
                        `;
                        break;
                        
                    case 'select':
                        const options = field.options.map(opt => 
                            `<option value="${opt.value}" ${opt.value === value ? 'selected' : ''}>${opt.label}</option>`
                        ).join('');
                        inputHtml = `
                            <select id="${fieldId}" class="property-input" 
                                    onchange="widgetEditor.updateProperty('${field.name}', this.value)"
                                    oninput="widgetEditor.updateProperty('${field.name}', this.value)">
                                ${options}
                            </select>
                        `;
                        break;
                        
                    case 'color':
                        /* 
                        # Rôle      : Génération HTML pour contrôle de couleur vertical
                        # Type      : string (HTML)
                        # Unité     : sans unité
                        # Formule   : bouton_couleur + champ_hexadecimal en colonne
                        # Exemple   : bouton 40px au-dessus, puis input hex en dessous
                        */
                        inputHtml = `
                            <div class="property-color-control">
                                <input type="color" id="${fieldId}" value="${value}" 
                                       onchange="widgetEditor.updateProperty('${field.name}', this.value)"
                                       oninput="widgetEditor.updateProperty('${field.name}', this.value)"
                                       title="Cliquer pour ouvrir le sélecteur de couleur">
                                <input type="text" class="property-input" 
                                       value="${value}" 
                                       onchange="widgetEditor.updateProperty('${field.name}', this.value)"
                                       oninput="widgetEditor.updateProperty('${field.name}', this.value)"
                                       placeholder="#FFFFFF"
                                       title="Code hexadécimal de la couleur">
                            </div>
                        `;
                        break;
                        
                    default:
                        inputHtml = `
                            <input type="text" id="${fieldId}" class="property-input" 
                                   value="${value}" 
                                   onchange="widgetEditor.updateProperty('${field.name}', this.value)"
                                   oninput="widgetEditor.updateProperty('${field.name}', this.value)">
                        `;
                }
                
                return `
                    <div class="property-field">
                        <label class="property-label" for="${fieldId}">${field.label}</label>
                        ${inputHtml}
                    </div>
                `;
            }

            updateElementsTab() {
                if (!this.selectedWidget) {
                    document.getElementById('elementsContainer').innerHTML = `
                        <p style="color: var(--text-muted); font-style: italic;">Aucun widget sélectionné</p>
                    `;
                    return;
                }
                
                const elements = this.selectedWidget.instance.getElements();
                let elementsHtml = '';
                
                elements.forEach(element => {
                    const isPricingFeatures = element.id === 'features' && this.selectedWidget.type === 'pricing-card';
                    const isGridFeatures = element.id === 'features' && this.selectedWidget.type === 'feature-grid';
                    
                    if (isPricingFeatures) {
                        // Interface spéciale pour les fonctionnalités du Pricing Card
                        const features = this.selectedWidget.data.features || [];
                        
                        elementsHtml += `
                            <div class="element-item" style="padding: 12px; background: var(--bg-card); 
                                                            border-radius: 8px; margin-bottom: 8px;">
                                <div style="margin-bottom: 12px;">
                                    <div style="color: white; font-weight: 500; margin-bottom: 8px;">
                                        <i class="fas fa-list"></i> ${element.name} (${features.length})
                                    </div>
                                    <div style="color: var(--text-muted); font-size: 12px;">Gestion dynamique des fonctionnalités</div>
                                </div>
                                
                                <div class="features-manager" style="margin-bottom: 12px;">
                                    <div class="feature-input-group" style="display: flex; gap: 8px; margin-bottom: 12px;">
                                        <input type="text" id="newFeatureInput" placeholder="✓ Nouvelle fonctionnalité..." 
                                               style="flex: 1; padding: 8px 12px; background: var(--bg-primary); 
                                                      border: 1px solid var(--border-color); border-radius: 6px; 
                                                      color: var(--text-white); font-size: 14px;">
                                        <button onclick="widgetEditor.addFeatureToSelected()" 
                                                style="padding: 8px 16px; background: var(--accent-green); 
                                                       color: white; border: none; border-radius: 6px; 
                                                       cursor: pointer; font-size: 14px; font-weight: 500;">
                                            <i class="fas fa-plus"></i> Ajouter
                                        </button>
                                    </div>
                                    
                                    <div class="features-list" style="max-height: 200px; overflow-y: auto;">
                                        ${features.map((feature, index) => `
                                            <div class="feature-item" style="display: flex; align-items: center; gap: 8px; 
                                                                           padding: 8px 12px; background: rgba(16, 185, 129, 0.1); 
                                                                           border: 1px solid rgba(16, 185, 129, 0.3); 
                                                                           border-radius: 6px; margin-bottom: 6px;">
                                                <span style="color: var(--accent-green); font-weight: bold; min-width: 16px;">✓</span>
                                                <input type="text" value="${feature}" 
                                                       onchange="widgetEditor.updateFeatureAtIndex(${index}, this.value)"
                                                       oninput="widgetEditor.updateFeatureAtIndex(${index}, this.value)"
                                                       style="flex: 1; background: transparent; border: none; 
                                                              color: var(--text-white); font-size: 14px; outline: none;">
                                                <button onclick="widgetEditor.removeFeatureAtIndex(${index})" 
                                                        title="Supprimer cette fonctionnalité"
                                                        style="background: rgba(239, 68, 68, 0.2); color: var(--danger-red); 
                                                               border: 1px solid var(--danger-red); border-radius: 4px; 
                                                               width: 24px; height: 24px; cursor: pointer; font-size: 12px;">
                                                    <i class="fas fa-times"></i>
                                                </button>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (isGridFeatures) {
                        // Interface spéciale pour les fonctionnalités de la Grille
                        const features = this.selectedWidget.data.features || [];
                        const featuresCount = this.selectedWidget.data.featuresCount || 4;
                        
                        elementsHtml += `
                            <div class="element-item" style="padding: 12px; background: var(--bg-card); 
                                                            border-radius: 8px; margin-bottom: 8px;">
                                <div style="margin-bottom: 12px;">
                                    <div style="color: white; font-weight: 500; margin-bottom: 8px;">
                                        <i class="fas fa-th-large"></i> ${element.name} (${featuresCount} actives sur ${features.length} disponibles)
                                    </div>
                                    <div style="color: var(--text-muted); font-size: 12px;">Édition avancée des fonctionnalités avec icônes</div>
                                </div>
                                
                                <div class="features-manager" style="margin-bottom: 12px;">
                                    <div class="feature-actions" style="display: flex; gap: 8px; margin-bottom: 12px;">
                                        <button onclick="widgetEditor.addFeatureToGrid()" 
                                                style="flex: 1; padding: 8px 16px; background: var(--accent-green); 
                                                       color: white; border: none; border-radius: 6px; 
                                                       cursor: pointer; font-size: 14px; font-weight: 500;">
                                            <i class="fas fa-plus"></i> Ajouter Fonctionnalité
                                        </button>
                                    </div>
                                    
                                    <div class="features-list" style="max-height: 300px; overflow-y: auto;">
                                        ${features.map((feature, index) => `
                                            <div class="feature-grid-item" style="padding: 12px; background: ${index < featuresCount ? 'rgba(16, 185, 129, 0.1)' : 'rgba(107, 114, 128, 0.1)'}; 
                                                                           border: 1px solid ${index < featuresCount ? 'rgba(16, 185, 129, 0.3)' : 'rgba(107, 114, 128, 0.3)'}; 
                                                                           border-radius: 8px; margin-bottom: 8px;">
                                                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                                                    <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                                                        <span style="color: var(--text-muted); font-size: 12px; font-weight: bold;">#${index + 1}</span>
                                                        <span style="color: ${index < featuresCount ? 'var(--accent-green)' : 'var(--text-muted)'}; font-weight: bold;">
                                                            ${index < featuresCount ? 'ACTIVE' : 'INACTIVE'}
                                                        </span>
                                                    </div>
                                                    <button onclick="widgetEditor.removeGridFeature(${index})" 
                                                            title="Supprimer cette fonctionnalité"
                                                            style="background: rgba(239, 68, 68, 0.2); color: var(--danger-red); 
                                                                   border: 1px solid var(--danger-red); border-radius: 4px; 
                                                                   width: 24px; height: 24px; cursor: pointer; font-size: 12px;">
                                                        <i class="fas fa-times"></i>
                                                    </button>
                                                </div>
                                                
                                                <div class="feature-fields">
                                                    <!-- Contenu Principal -->
                                                    <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 8px; margin-bottom: 8px; align-items: center;">
                                                        <label style="color: var(--text-gray); font-size: 12px;">Icône:</label>
                                                        <input type="text" value="${feature.icon || '⭐'}" maxlength="2" 
                                                               onchange="widgetEditor.updateGridFeature(${index}, 'icon', this.value)"
                                                               oninput="widgetEditor.updateGridFeature(${index}, 'icon', this.value)"
                                                               style="padding: 6px 8px; background: var(--bg-primary); 
                                                                      border: 1px solid var(--border-color); border-radius: 4px; 
                                                                      color: var(--text-white); font-size: 16px; text-align: center; width: 50px;">
                                                        <select onchange="widgetEditor.updateGridFeature(${index}, 'iconSize', this.value)"
                                                                style="padding: 4px; background: var(--bg-primary); border: 1px solid var(--border-color); 
                                                                       border-radius: 4px; color: var(--text-white); font-size: 11px;">
                                                            <option value="2rem" ${(feature.iconSize || '3rem') === '2rem' ? 'selected' : ''}>Petite</option>
                                                            <option value="3rem" ${(feature.iconSize || '3rem') === '3rem' ? 'selected' : ''}>Normale</option>
                                                            <option value="4rem" ${(feature.iconSize || '3rem') === '4rem' ? 'selected' : ''}>Grande</option>
                                                        </select>
                                                    </div>
                                                    
                                                    <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 8px; margin-bottom: 8px; align-items: center;">
                                                        <label style="color: var(--text-gray); font-size: 12px;">Titre:</label>
                                                        <input type="text" value="${feature.title || 'Titre'}" 
                                                               onchange="widgetEditor.updateGridFeature(${index}, 'title', this.value)"
                                                               oninput="widgetEditor.updateGridFeature(${index}, 'title', this.value)"
                                                               style="padding: 6px 8px; background: var(--bg-primary); 
                                                                      border: 1px solid var(--border-color); border-radius: 4px; 
                                                                      color: var(--text-white); font-size: 14px;">
                                                        <input type="color" value="${feature.titleColor?.replace('var(--text-white)', '#ffffff') || '#ffffff'}" 
                                                               onchange="widgetEditor.updateGridFeature(${index}, 'titleColor', this.value)"
                                                               style="width: 30px; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                                                    </div>
                                                    
                                                    <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 8px; margin-bottom: 8px;">
                                                        <label style="color: var(--text-gray); font-size: 12px; align-self: start; padding-top: 6px;">Description:</label>
                                                        <textarea rows="2" placeholder="Description de la fonctionnalité"
                                                                  onchange="widgetEditor.updateGridFeature(${index}, 'description', this.value)"
                                                                  oninput="widgetEditor.updateGridFeature(${index}, 'description', this.value)"
                                                                  style="padding: 6px 8px; background: var(--bg-primary); 
                                                                         border: 1px solid var(--border-color); border-radius: 4px; 
                                                                         color: var(--text-white); font-size: 13px; resize: vertical; min-height: 40px;">${feature.description || 'Description'}</textarea>
                                                        <input type="color" value="${feature.descriptionColor?.replace('var(--text-gray)', '#94a3b8') || '#94a3b8'}" 
                                                               onchange="widgetEditor.updateGridFeature(${index}, 'descriptionColor', this.value)"
                                                               style="width: 30px; height: 30px; border: none; border-radius: 4px; cursor: pointer; align-self: start;">
                                                    </div>
                                                    
                                                    <!-- Couleurs de fond et bordure -->
                                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-color);">
                                                        <div>
                                                            <label style="color: var(--text-gray); font-size: 11px; margin-bottom: 4px; display: block;">Fond:</label>
                                                            <input type="color" value="${feature.backgroundColor?.replace('var(--bg-card)', '#374151') || '#374151'}" 
                                                                   onchange="widgetEditor.updateGridFeature(${index}, 'backgroundColor', this.value)"
                                                                   style="width: 100%; height: 28px; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer;">
                                                        </div>
                                                        <div>
                                                            <label style="color: var(--text-gray); font-size: 11px; margin-bottom: 4px; display: block;">Bordure:</label>
                                                            <input type="color" value="${feature.borderColor?.replace('var(--border-color)', '#4b5563') || '#4b5563'}" 
                                                                   onchange="widgetEditor.updateGridFeature(${index}, 'borderColor', this.value)"
                                                                   style="width: 100%; height: 28px; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer;">
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // Interface standard pour les autres éléments
                        elementsHtml += `
                            <div class="element-item" style="padding: 12px; background: var(--bg-card); 
                                                            border-radius: 8px; margin-bottom: 8px; 
                                                            display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <div style="color: white; font-weight: 500;">${element.name}</div>
                                    <div style="color: var(--text-muted); font-size: 12px;">ID: ${element.id}</div>
                                </div>
                                <div class="element-controls" style="display: flex; gap: 4px; color: var(--text-muted); font-size: 12px;">
                                    <span>Éditible via propriétés</span>
                                </div>
                            </div>
                        `;
                    }
                });
                
                document.getElementById('elementsContainer').innerHTML = elementsHtml;
            }

            updateProperty(propertyName, value) {
                if (!this.selectedWidget) return;
                
                // Conversion des types
                if (value === 'true') value = true;
                if (value === 'false') value = false;
                if (!isNaN(value) && value !== '' && typeof this.selectedWidget.data[propertyName] === 'number') {
                    value = parseFloat(value);
                }
                
                // Gestion spéciale pour featuresCount dans feature-grid
                if (propertyName === 'featuresCount' && this.selectedWidget.type === 'feature-grid') {
                    const currentCount = parseInt(value, 10);
                    const features = this.selectedWidget.data.features || [];
                    
                    // Si on augmente le nombre, ajouter des fonctionnalités vides
                    while (features.length < currentCount) {
                        features.push({
                            icon: '⭐',
                            title: `Fonctionnalité ${features.length + 1}`,
                            description: 'Description de cette fonctionnalité',
                            iconSize: '3rem',
                            titleColor: 'white',
                            titleSize: '1.5rem',
                            descriptionColor: 'var(--text-gray)',
                            descriptionSize: '0.95rem',
                            backgroundColor: 'var(--bg-card)',
                            borderColor: 'var(--border-color)'
                        });
                    }
                    
                    // Mettre à jour le tableau des features
                    this.selectedWidget.data.features = features;
                    
                    // Mettre à jour l'onglet Elements pour refléter les changements
                    this.updateElementsTab();
                }
                
                // Sauvegarder la valeur
                this.selectedWidget.data[propertyName] = value;
                
                // Mettre à jour l'affichage de la valeur pour les ranges
                const valueDisplay = document.getElementById(`prop-${propertyName}-value`);
                if (valueDisplay) {
                    const unit = propertyName.includes('Size') || propertyName.includes('width') || propertyName.includes('height') || propertyName.includes('Width') || propertyName.includes('Height') ? 'px' : '';
                    valueDisplay.textContent = value + unit;
                }
                
                // Mise à jour temps réel spécifique par type de widget et propriété
                const container = document.querySelector(`[data-widget-id="${this.selectedWidget.id}"]`);
                if (container) {
                    this.updateWidgetRealTime(container, propertyName, value);
                }
                
                // Mettre à jour aussi le viewer
                this.updatePreview();
                
                // Pas de setStatus pour éviter le spam lors de l'input continu
            }
            
            // Mise à jour temps réel spécifique selon le type de widget
            updateWidgetRealTime(container, propertyName, value) {
                const widgetType = this.selectedWidget.type;
                
                switch (widgetType) {
                    case 'logo':
                        this.updateLogoRealTime(container, propertyName, value);
                        break;
                    case 'hero-title':
                        this.updateHeroTitleRealTime(container, propertyName, value);
                        break;
                    case 'pricing-card':
                        this.updatePricingCardRealTime(container, propertyName, value);
                        break;
                    case 'call-to-action':
                        this.updateCTARealTime(container, propertyName, value);
                        break;
                    case 'feature-grid':
                        this.updateFeatureGridRealTime(container, propertyName, value);
                        break;
                }
            }
            
            // Mise à jour temps réel pour le logo
            updateLogoRealTime(container, propertyName, value) {
                const logoImage = container.querySelector('.logo-image, .nav-logo');
                
                switch (propertyName) {
                    case 'imagePath':
                        if (logoImage) {
                            logoImage.style.backgroundImage = `url('${value}')`;
                        }
                        break;
                    case 'width':
                        if (logoImage) {
                            logoImage.style.width = `${value}px`;
                        }
                        break;
                    case 'height':
                        if (logoImage) {
                            logoImage.style.height = `${value}px`;
                        }
                        break;
                    case 'link':
                        if (logoImage) {
                            logoImage.href = value;
                        }
                        break;
                }
            }
            
            // Mise à jour temps réel pour le hero title
            updateHeroTitleRealTime(container, propertyName, value) {
                const title = container.querySelector('.hero-title, h1');
                const subtitle = container.querySelector('.hero-subtitle, .hero-section div');
                const section = container.querySelector('.hero-section');
                
                switch (propertyName) {
                    case 'title':
                        if (title) {
                            title.textContent = value;
                        }
                        break;
                    case 'subtitle':
                        if (subtitle) {
                            subtitle.innerHTML = value;
                        }
                        break;
                    case 'titleSize':
                        if (title) {
                            title.style.fontSize = `${value}px`;
                        }
                        break;
                    case 'subtitleSize':
                        if (subtitle) {
                            subtitle.style.fontSize = `${value}px`;
                        }
                        break;
                    case 'alignment':
                        if (section) {
                            section.style.textAlign = value;
                        }
                        break;
                    case 'backgroundColor':
                        if (section) {
                            if (value === 'transparent' || value === '') {
                                section.style.backgroundColor = 'transparent';
                            } else {
                                section.style.backgroundColor = value;
                            }
                        }
                        break;
                    case 'borderRadius':
                        if (section) {
                            if (parseInt(value) > 0) {
                                section.style.borderRadius = `${value}px`;
                                section.style.overflow = 'hidden';
                            } else {
                                section.style.borderRadius = '0px';
                                section.style.overflow = 'visible';
                            }
                        }
                        break;
                    case 'gradient':
                        if (title) {
                            if (value) {
                                title.style.background = 'linear-gradient(135deg, #10b981, #0d9488)';
                                title.style.webkitBackgroundClip = 'text';
                                title.style.webkitTextFillColor = 'transparent';
                                title.style.backgroundClip = 'text';
                            } else {
                                title.style.background = 'none';
                                title.style.webkitBackgroundClip = 'initial';
                                title.style.webkitTextFillColor = 'initial';
                                title.style.backgroundClip = 'initial';
                                title.style.color = '#10b981';
                            }
                        }
                        break;
                }
            }
            
            // Mise à jour temps réel pour pricing card
            updatePricingCardRealTime(container, propertyName, value) {
                const planName = container.querySelector('h3');
                const price = container.querySelector('.pricing-amount, [style*="font-size: 3.5rem"]');
                const currency = container.querySelector('[style*="font-size: 2rem"]');
                const ctaButton = container.querySelector('a[style*="width: 100%"]');
                const card = container.querySelector('.pricing-card');
                const badge = container.querySelector('.pricing-badge');
                const featuresList = container.querySelector('ul');
                
                switch (propertyName) {
                    case 'planName':
                        if (planName) {
                            planName.textContent = value;
                        }
                        break;
                    case 'price':
                        if (price) {
                            price.textContent = value;
                        }
                        break;
                    case 'currency':
                        if (currency) {
                            currency.textContent = value;
                        }
                        break;
                    case 'ctaText':
                        if (ctaButton) {
                            ctaButton.textContent = value;
                        }
                        break;
                    case 'ctaLink':
                        if (ctaButton) {
                            ctaButton.href = value;
                        }
                        break;
                    case 'accentColor':
                        if (currency) {
                            currency.style.color = value;
                        }
                        if (ctaButton) {
                            ctaButton.style.background = value;
                        }
                        if (badge) {
                            badge.style.background = value;
                        }
                        if (card) {
                            const isFeatured = this.selectedWidget.data.featured;
                            if (isFeatured) {
                                card.style.borderColor = value;
                            }
                        }
                        // Mettre à jour les checkmarks des fonctionnalités
                        if (featuresList) {
                            const checkmarks = featuresList.querySelectorAll('span[style*="color"]');
                            checkmarks.forEach(check => {
                                check.style.color = value;
                            });
                        }
                        break;
                    case 'backgroundColor':
                        if (card) {
                            card.style.background = value;
                        }
                        break;
                    case 'textColor':
                        if (card) {
                            card.style.color = value;
                        }
                        if (planName) {
                            planName.style.color = value;
                        }
                        if (featuresList) {
                            const textElements = featuresList.querySelectorAll('span:not([style*="color: #10b981"])');
                            textElements.forEach(el => {
                                if (!el.textContent.includes('✓')) {
                                    el.style.color = value;
                                }
                            });
                        }
                        break;
                    case 'badge':
                        // Re-render complet pour le badge car il peut être ajouté/supprimé
                        this.renderSelectedWidget();
                        break;
                    case 'featured':
                        if (card) {
                            const accentColor = this.selectedWidget.data.accentColor || '#10b981';
                            card.style.borderColor = value ? accentColor : '#374151';
                            if (value) {
                                card.classList.add('featured');
                            } else {
                                card.classList.remove('featured');
                            }
                        }
                        break;
                }
            }
            
            // Mise à jour temps réel pour CTA
            updateCTARealTime(container, propertyName, value) {
                const title = container.querySelector('h2');
                const description = container.querySelector('p');
                const primaryBtn = container.querySelector('a[style*="background: white"]');
                const secondaryBtn = container.querySelector('a[style*="background: transparent"]');
                const section = container.querySelector('.cta-section');
                
                switch (propertyName) {
                    case 'title':
                        if (title) title.textContent = value;
                        break;
                    case 'description':
                        if (description) description.textContent = value;
                        break;
                    case 'primaryButtonText':
                        if (primaryBtn) primaryBtn.textContent = value;
                        break;
                    case 'primaryButtonLink':
                        if (primaryBtn) primaryBtn.href = value;
                        break;
                    case 'secondaryButtonText':
                        if (secondaryBtn) secondaryBtn.textContent = value;
                        break;
                    case 'secondaryButtonLink':
                        if (secondaryBtn) secondaryBtn.href = value;
                        break;
                    case 'backgroundColor':
                        if (section) section.style.background = value;
                        break;
                }
            }
            
            // Mise à jour temps réel pour feature grid
            updateFeatureGridRealTime(container, propertyName, value) {
                const title = container.querySelector('h2');
                const grid = container.querySelector('.features-grid');
                
                switch (propertyName) {
                    case 'title':
                        if (title) title.textContent = value;
                        break;
                    case 'columns':
                        if (grid) {
                            grid.style.gridTemplateColumns = `repeat(${value}, 1fr)`;
                        }
                        break;
                }
            }

            switchPropertiesTab(tabName) {
                // Mettre à jour les boutons
                document.querySelectorAll('.properties-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                
                // Mettre à jour le contenu
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName + 'Tab').classList.add('active');
            }

            moveWidget(direction, widgetId = null) {
                const id = widgetId || (this.selectedWidget ? this.selectedWidget.id : null);
                if (!id) return;
                
                const currentIndex = this.widgets.findIndex(w => w.id === id);
                const newIndex = currentIndex + direction;
                
                if (newIndex < 0 || newIndex >= this.widgets.length) return;
                
                // Échanger les widgets dans la liste de rendu
                [this.widgets[currentIndex], this.widgets[newIndex]] = [this.widgets[newIndex], this.widgets[currentIndex]];
                
                this.renderCanvas();
                this.selectWidget(id);
                this.updatePreview();
                
                this.setStatus('Ordre des widgets modifié', 'success');
            }

            duplicateWidget(widgetId = null) {
                const id = widgetId || (this.selectedWidget ? this.selectedWidget.id : null);
                if (!id) return;
                
                const originalWidget = this.widgets.find(w => w.id === id);
                if (!originalWidget) return;
                
                const duplicatedWidget = {
                    id: `widget-${Date.now()}`,
                    type: originalWidget.type,
                    instance: originalWidget.instance,
                    data: { ...originalWidget.data }
                };
                
                // Insérer après l'original
                const index = this.widgets.findIndex(w => w.id === id);
                this.widgets.splice(index + 1, 0, duplicatedWidget);
                
                this.saveToHistory('Duplication widget');
                this.renderCanvas();
                this.selectWidget(duplicatedWidget.id);
                this.updatePreview();
                
                document.getElementById('widgetCount').textContent = this.widgets.length;
                this.setStatus('Widget dupliqué', 'success');
            }

            deleteWidget(widgetId = null) {
                const id = widgetId || (this.selectedWidget ? this.selectedWidget.id : null);
                if (!id) return;
                
                if (!confirm('Êtes-vous sûr de vouloir supprimer ce widget ?')) return;
                
                // Supprimer le widget
                this.widgets = this.widgets.filter(w => w.id !== id);
                
                // Réinitialiser la sélection
                this.selectedWidget = null;
                
                // Sauvegarder dans l'historique
                this.saveToHistory('Suppression widget');
                
                // Mettre à jour l'interface
                this.renderCanvas();
                this.updatePropertiesPanel();
                this.updateOrganizationButtons();
                this.updatePreview();
                
                // Mettre à jour le compteur
                document.getElementById('widgetCount').textContent = this.widgets.length;
                
                // Afficher l'état vide si nécessaire
                const emptyState = document.getElementById('emptyState');
                if (this.widgets.length === 0 && emptyState) {
                    emptyState.classList.remove('hidden');
                    emptyState.style.display = 'flex';
                }
                
                this.setStatus('Widget supprimé', 'success');
            }

            updatePreview() {
                const preview = document.getElementById('presentationPreview');
                
                if (this.widgets.length === 0) {
                    preview.innerHTML = `
                        <div style="grid-column: 1 / -1; grid-row: 1 / -1; display: flex; 
                                    flex-direction: column; align-items: center; justify-content: center; 
                                    text-align: center; color: #6b7280;">
                            <i class="fas fa-eye" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;"></i>
                            <div>L'aperçu temps réel apparaîtra ici</div>
                        </div>
                    `;
                    return;
                }
                
                let previewHtml = '';
                this.widgets.forEach(widget => {
                    const pos = widget.position || { col: 1, row: 1 };
                    const size = widget.size || { width: 3, height: 2 };
                    
                    previewHtml += `
                        <div class="preview-widget" 
                             style="grid-column: ${pos.col} / ${pos.col + size.width}; 
                                    grid-row: ${pos.row} / ${pos.row + size.height}; 
                                    background: rgba(248, 250, 252, 0.95); 
                                    border: 1px solid #e5e7eb;">
                            ${widget.instance.render(widget.data)}
                        </div>
                    `;
                });
                
                preview.innerHTML = previewHtml;
                
                // Mettre à jour aussi la prévisualisation plein écran si elle est ouverte
                this.updateFullscreenPreviewIfOpen();
            }

            // Gestion de la recherche dynamique
            handleSearch(term) {
                this.searchTerm = term.toLowerCase().trim();
                const library = document.getElementById('widgetLibrary');
                
                if (this.searchTerm === '') {
                    // Retour à l'affichage normal
                    library.classList.remove('search-active');
                    this.renderCurrentFolder();
                    return;
                }
                
                // Mode recherche actif
                library.classList.add('search-active');
                this.renderSearchResults();
            }
            
            // Rendu des résultats de recherche
            renderSearchResults() {
                const searchResults = document.getElementById('searchResults');
                if (!searchResults) return;
                
                const results = [];
                
                // Rechercher dans tous les widgets
                this.availableWidgets.forEach(widget => {
                    const name = widget.name.toLowerCase();
                    const description = (widget.description || '').toLowerCase();
                    const category = (widget.category || '').toLowerCase();
                    
                    if (name.includes(this.searchTerm) || 
                        description.includes(this.searchTerm) ||
                        category.includes(this.searchTerm)) {
                        results.push(widget);
                    }
                });
                
                // Rechercher dans les noms de dossiers
                const folderResults = [];
                Object.entries(this.folders).forEach(([id, folder]) => {
                    if (folder.name.toLowerCase().includes(this.searchTerm)) {
                        folderResults.push({ id, ...folder });
                    }
                });
                
                // Afficher les résultats
                searchResults.innerHTML = '';
                
                if (folderResults.length > 0) {
                    const foldersSection = document.createElement('div');
                    foldersSection.innerHTML = `
                        <div style="font-weight: bold; color: var(--text-white); margin-bottom: 8px; padding: 4px 8px;">
                            <i class="fas fa-folder"></i> Dossiers (${folderResults.length})
                        </div>
                    `;
                    
                    folderResults.forEach(folder => {
                        const folderItem = document.createElement('div');
                        folderItem.className = 'folder-item';
                        folderItem.dataset.folder = folder.id;
                        folderItem.innerHTML = `
                            <i class="fas fa-folder folder-icon"></i>
                            <span class="folder-name">${folder.name}</span>
                            <span class="folder-count">${folder.widgets.length}</span>
                        `;
                        foldersSection.appendChild(folderItem);
                    });
                    
                    searchResults.appendChild(foldersSection);
                }
                
                if (results.length > 0) {
                    const widgetsSection = document.createElement('div');
                    widgetsSection.innerHTML = `
                        <div style="font-weight: bold; color: var(--text-white); margin-bottom: 8px; padding: 4px 8px; margin-top: 16px;">
                            <i class="fas fa-puzzle-piece"></i> Widgets (${results.length})
                        </div>
                    `;
                    
                    results.forEach(widget => {
                        const widgetItem = this.createWidgetItem(widget);
                        widgetsSection.appendChild(widgetItem);
                    });
                    
                    searchResults.appendChild(widgetsSection);
                }
                
                if (results.length === 0 && folderResults.length === 0) {
                    searchResults.innerHTML = `
                        <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
                            <i class="fas fa-search" style="font-size: 2rem; margin-bottom: 1rem; opacity: 0.3;"></i>
                            <div>Aucun résultat pour "${this.searchTerm}"</div>
                        </div>
                    `;
                }
            }

            // Historique simplifié
            saveToHistory(action) {
                // Sauvegarde simple pour référence future
                console.log(`Action: ${action} - ${new Date().toLocaleTimeString()}`);
            }

            updateHistoryButtons() {
                document.getElementById('undoBtn').disabled = this.historyIndex <= 0;
                document.getElementById('redoBtn').disabled = this.historyIndex >= this.history.length - 1;
            }

            // Sauvegarde complète du conteneur avec tous les widgets et leur configuration
            saveProject() {
                // Vérifier si le conteneur arrière-plan est activé
                const workspace = document.getElementById('canvasWorkspace');
                const hasContainer = workspace?.querySelector('.global-background-container') !== null;
                
                // Données complètes du projet incluant le conteneur
                const projectData = {
                    version: '2.1.0', // Version mise à jour pour inclure le conteneur
                    timestamp: new Date().toISOString(),
                    
                    // Configuration du conteneur global
                    container: {
                        enabled: hasContainer,
                        type: 'adaptive-background',
                        style: {
                            background: 'rgba(16, 185, 129, 0.1)',
                            border: '2px dashed rgba(16, 185, 129, 0.5)',
                            borderRadius: '12px'
                        }
                    },
                    
                    // Widgets avec toutes leurs propriétés (récursif)
                    widgets: this.widgets.map(w => ({
                        id: w.id,
                        type: w.type,
                        data: { ...w.data }, // Copie profonde des données
                        position: { ...w.position } || { col: 1, row: 1 },
                        size: { ...w.size } || { width: 3, height: 2 },
                        
                        // Métadonnées pour la reconstruction
                        metadata: {
                            created: w.created || new Date().toISOString(),
                            modified: new Date().toISOString(),
                            category: w.instance?.category || 'Général',
                            name: w.instance?.name || 'Widget'
                        }
                    })),
                    
                    // Configuration de la grille
                    grid: {
                        columns: 12,
                        rows: 8,
                        gap: 8,
                        visible: workspace?.classList.contains('show-grid') || false
                    },
                    
                    // Statistiques du projet
                    stats: {
                        totalWidgets: this.widgets.length,
                        widgetsByType: this.getWidgetStats(),
                        gridUsage: this.calculateGridUsage()
                    }
                };
                
                const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `widget-project-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                document.getElementById('lastSave').textContent = new Date().toLocaleString();
                this.setStatus('Conteneur et widgets sauvegardés avec succès', 'success');
                
                // Sauvegarder aussi dans la liste des projets pour pouvoir recharger
                const projectForList = {
                    name: `Projet-${new Date().toISOString().split('T')[0]}`,
                    timestamp: new Date().toISOString(),
                    widgets: projectData.widgets,
                    container: projectData.container,
                    stats: projectData.stats
                };
                
                this.savedProjects.unshift(projectForList);
                if (this.savedProjects.length > 20) {
                    this.savedProjects = this.savedProjects.slice(0, 20);
                }
                localStorage.setItem('widgetEditor_savedProjects', JSON.stringify(this.savedProjects));
                
                // Rafraîchir la liste des projets sauvegardés
                this.loadSavedProjects();
            }
            
            // Calculer les statistiques des widgets par type
            getWidgetStats() {
                const stats = {};
                this.widgets.forEach(widget => {
                    const type = widget.type;
                    stats[type] = (stats[type] || 0) + 1;
                });
                return stats;
            }
            
            // Calculer l'utilisation de la grille
            calculateGridUsage() {
                let usedCells = 0;
                const totalCells = 12 * 8; // 96 cellules totales
                
                this.widgets.forEach(widget => {
                    const pos = widget.position || { col: 1, row: 1 };
                    const size = widget.size || { width: 3, height: 2 };
                    usedCells += size.width * size.height;
                });
                
                return {
                    used: usedCells,
                    total: totalCells,
                    percentage: Math.round((usedCells / totalCells) * 100)
                };
            }
            
            // ============= NOUVELLES MÉTHODES DOSSIERS ET RECHERCHE =============
            
            // Sélection d'un dossier
            selectFolder(folderId) {
                // Mettre à jour l'UI
                document.querySelectorAll('.folder-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelector(`[data-folder="${folderId}"]`)?.classList.add('active');
                
                this.currentFolder = folderId;
                this.renderCurrentFolder();
                this.setStatus(`Dossier "${this.folders[folderId]?.name || folderId}" sélectionné`, 'info');
            }
            
            // Gestion des favoris
            toggleFavorite(widgetId) {
                if (this.favoriteWidgets.has(widgetId)) {
                    this.favoriteWidgets.delete(widgetId);
                } else {
                    this.favoriteWidgets.add(widgetId);
                }
                
                this.saveLocalData();
                this.updateFolderStructure();
                
                // Re-rendre si on est dans les favoris
                if (this.currentFolder === 'favorites') {
                    this.renderCurrentFolder();
                }
                
                // Rafraîchir les résultats de recherche si actifs
                if (this.searchTerm) {
                    this.renderSearchResults();
                } else {
                    this.renderCurrentFolder();
                }
            }
            
            // Ajouter aux récents
            addToRecent(widgetId) {
                this.recentWidgets.delete(widgetId); // Supprimer s'il existe déjà
                this.recentWidgets.add(widgetId); // Ajouter en premier
                
                // Garder seulement les 10 plus récents
                if (this.recentWidgets.size > 10) {
                    const items = Array.from(this.recentWidgets);
                    this.recentWidgets = new Set(items.slice(-10));
                }
                
                this.saveLocalData();
                this.updateFolderStructure();
            }
            
            // Créer un nouveau dossier
            createNewFolder() {
                const name = prompt('Nom du nouveau dossier :');
                if (!name || name.trim() === '') return;
                
                const folderId = 'custom_' + Date.now();
                this.folders[folderId] = {
                    name: name.trim(),
                    widgets: [],
                    type: 'custom'
                };
                
                this.saveLocalData();
                this.renderCustomFolders();
                this.selectFolder(folderId);
                
                this.setStatus(`Dossier "${name}" créé`, 'success');
            }
            
            // Rendu des dossiers personnalisés
            renderCustomFolders() {
                const container = document.getElementById('customFolders');
                const customFolders = Object.entries(this.folders).filter(([id, folder]) => folder.type === 'custom');
                
                container.innerHTML = '';
                
                customFolders.forEach(([id, folder]) => {
                    const folderItem = document.createElement('div');
                    folderItem.className = 'folder-item';
                    folderItem.dataset.folder = id;
                    folderItem.innerHTML = `
                        <i class="fas fa-folder folder-icon"></i>
                        <span class="folder-name">${folder.name}</span>
                        <span class="folder-count">${folder.widgets.length}</span>
                        <div class="folder-controls">
                            <button class="folder-control-btn" onclick="widgetEditor.renameFol

Folder('${id}')" title="Renommer">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="folder-control-btn" onclick="widgetEditor.deleteFolder('${id}')" title="Supprimer">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
                    container.appendChild(folderItem);
                });
            }
            
            // Renommer un dossier
            renameFolder(folderId) {
                const folder = this.folders[folderId];
                if (!folder || folder.type !== 'custom') return;
                
                const newName = prompt('Nouveau nom :', folder.name);
                if (!newName || newName.trim() === '' || newName.trim() === folder.name) return;
                
                folder.name = newName.trim();
                this.saveLocalData();
                this.renderCustomFolders();
                
                this.setStatus(`Dossier renommé en "${newName}"`, 'success');
            }
            
            // Supprimer un dossier
            deleteFolder(folderId) {
                const folder = this.folders[folderId];
                if (!folder || folder.type !== 'custom') return;
                
                if (!confirm(`Supprimer le dossier "${folder.name}" ?\nLes widgets ne seront pas supprimés.`)) return;
                
                delete this.folders[folderId];
                this.saveLocalData();
                this.renderCustomFolders();
                
                // Retourner à "Tous les widgets" si on était dans ce dossier
                if (this.currentFolder === folderId) {
                    this.selectFolder('root');
                }
                
                this.setStatus(`Dossier "${folder.name}" supprimé`, 'success');
            }
            
            // Charger les projets sauvegardés
            loadSavedProjects() {
                // Simuler quelques projets sauvegardés
                this.savedProjects = JSON.parse(localStorage.getItem('widgetEditor_savedProjects') || '[]');
                
                const savesContainer = document.getElementById('savesList');
                const savesCount = document.getElementById('savesCount');
                
                savesCount.textContent = this.savedProjects.length;
                savesContainer.innerHTML = '';
                
                if (this.savedProjects.length === 0) {
                    savesContainer.innerHTML = `
                        <div style="padding: 1rem; color: var(--text-muted); font-size: 0.8rem; text-align: center;">
                            Aucun projet sauvegardé
                        </div>
                    `;
                    return;
                }
                
                this.savedProjects.forEach(project => {
                    const saveItem = document.createElement('div');
                    saveItem.className = 'save-item';
                    saveItem.innerHTML = `
                        <i class="fas fa-file-code save-icon"></i>
                        <div class="save-name">${project.name || 'Projet sans nom'}</div>
                        <div class="save-date">${new Date(project.timestamp).toLocaleDateString()}</div>
                    `;
                    
                    saveItem.addEventListener('click', () => this.loadProject(project));
                    savesContainer.appendChild(saveItem);
                });
            }
            
            // Charger les données locales
            loadLocalData() {
                const data = JSON.parse(localStorage.getItem('widgetEditor_userData') || '{}');
                this.favoriteWidgets = new Set(data.favorites || []);
                this.recentWidgets = new Set(data.recent || []);
                this.folders = { ...this.folders, ...(data.customFolders || {}) };
                
                this.renderCustomFolders();
            }
            
            // Sauvegarder les données locales
            saveLocalData() {
                const data = {
                    favorites: Array.from(this.favoriteWidgets),
                    recent: Array.from(this.recentWidgets),
                    customFolders: Object.fromEntries(
                        Object.entries(this.folders).filter(([id, folder]) => folder.type === 'custom')
                    )
                };
                localStorage.setItem('widgetEditor_userData', JSON.stringify(data));
            }
            
            // Charger un projet
            loadProject(project) {
                if (!confirm(`Charger le projet "${project.name}" ?\nLe projet actuel sera perdu.`)) return;
                
                try {
                    // Réinitialiser l'éditeur
                    this.widgets = [];
                    this.selectedWidget = null;
                    
                    // Charger les widgets
                    if (project.widgets && Array.isArray(project.widgets)) {
                        project.widgets.forEach(widgetData => {
                            const WidgetClass = this.availableWidgets.find(w => w.id === widgetData.type);
                            if (WidgetClass) {
                                const widget = {
                                    id: widgetData.id || this.generateId(),
                                    type: widgetData.type,
                                    data: widgetData.data || {},
                                    position: widgetData.position || { col: 1, row: 1 },
                                    size: widgetData.size || { width: 3, height: 2 },
                                    instance: new WidgetClass()
                                };
                                this.widgets.push(widget);
                            }
                        });
                    }
                    
                    // Charger le conteneur si présent
                    if (project.container && project.container.enabled) {
                        this.createBackgroundContainer();
                    }
                    
                    // Mettre à jour l'interface
                    this.renderCanvas();
                    this.updatePreview();
                    
                    this.setStatus(`Projet "${project.name}" chargé`, 'success');
                } catch (error) {
                    this.setStatus('Erreur lors du chargement du projet', 'error');
                    console.error('Erreur chargement projet:', error);
                }
            }
            
            // ============= MÉTHODES DE PRÉVISUALISATION PLEIN ÉCRAN =============
            
            // Ouvrir la popup de prévisualisation plein écran
            openFullscreenPreview() {
                const popup = document.getElementById('previewPopup');
                popup.classList.add('active');
                
                // Empêcher le scroll sur le body
                document.body.style.overflow = 'hidden';
                
                // Rendre la prévisualisation
                this.renderFullscreenPreview();
                
                this.setStatus('Prévisualisation plein écran ouverte', 'info');
            }
            
            // Fermer la popup de prévisualisation
            closeFullscreenPreview() {
                const popup = document.getElementById('previewPopup');
                popup.classList.remove('active');
                
                // Réactiver le scroll sur le body
                document.body.style.overflow = 'auto';
                
                this.setStatus('Prévisualisation fermée', 'info');
            }
            
            // Rendre la prévisualisation finale avec le style du viewer exporté
            renderFullscreenPreview() {
                const previewGrid = document.getElementById('previewGrid');
                
                if (this.widgets.length === 0) {
                    previewGrid.innerHTML = `
                        <div class="preview-empty">
                            <i class="fas fa-cube"></i>
                            <div>Aucun widget à prévisualiser</div>
                            <div style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.7;">
                                Ajoutez des widgets pour voir la prévisualisation
                            </div>
                        </div>
                    `;
                    return;
                }
                
                let previewHtml = '';
                
                // Rendu de chaque widget avec le style final
                this.widgets.forEach(widget => {
                    const pos = widget.position || { col: 1, row: 1 };
                    const size = widget.size || { width: 3, height: 2 };
                    
                    // Contenu du widget rendu avec le style final
                    const widgetContent = widget.instance.render(widget.data);
                    
                    previewHtml += `
                        <div class="preview-widget-final" 
                             style="grid-column: ${pos.col} / ${pos.col + size.width}; 
                                    grid-row: ${pos.row} / ${pos.row + size.height};">
                            <div class="widget-content">
                                ${widgetContent}
                            </div>
                        </div>
                    `;
                });
                
                previewGrid.innerHTML = previewHtml;
                
                // Appliquer les animations d'entrée
                const widgets = previewGrid.querySelectorAll('.preview-widget-final');
                widgets.forEach((widget, index) => {
                    widget.style.opacity = '0';
                    widget.style.transform = 'translateY(20px)';
                    
                    setTimeout(() => {
                        widget.style.transition = 'all 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
                        widget.style.opacity = '1';
                        widget.style.transform = 'translateY(0)';
                    }, index * 100);
                });
            }
            
            // Mettre à jour la prévisualisation si elle est ouverte
            updateFullscreenPreviewIfOpen() {
                const popup = document.getElementById('previewPopup');
                if (popup && popup.classList.contains('active')) {
                    this.renderFullscreenPreview();
                }
            }

            exportProject() {
                let html = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Présentation - Li-CUBE PRO™</title>
    <style>
        body { font-family: system-ui, sans-serif; margin: 0; padding: 0; }
        .presentation { max-width: 1200px; margin: 0 auto; }
    </style>
</head>
<body>
    <div class="presentation">
`;
                
                this.widgets.forEach(widget => {
                    html += widget.instance.render(widget.data);
                });
                
                html += `
    </div>
</body>
</html>`;
                
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `presentation-${new Date().toISOString().split('T')[0]}.html`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.setStatus('Export HTML généré', 'success');
            }


            // Trouver une position libre sur la grille (placement intelligent centre-vers-extérieur)
            findFreeGridPosition(width = 3, height = 2) {
                // Positions prioritaires : centre vers l'extérieur
                const centerCol = Math.floor(12 / 2) - Math.floor(width / 2) + 1;
                const centerRow = Math.floor(8 / 2) - Math.floor(height / 2) + 1;
                
                // Positions candidates par priorité (centre vers extérieur)
                const candidates = [];
                
                // Ajouter le centre en premier
                candidates.push({ col: centerCol, row: centerRow });
                
                // Puis ajouter les positions en spirale depuis le centre
                for (let radius = 1; radius <= 6; radius++) {
                    for (let row = Math.max(1, centerRow - radius); row <= Math.min(8, centerRow + radius); row++) {
                        for (let col = Math.max(1, centerCol - radius); col <= Math.min(12, centerCol + radius); col++) {
                            // Éviter les positions déjà ajoutées
                            if (!candidates.some(c => c.col === col && c.row === row)) {
                                candidates.push({ col, row });
                            }
                        }
                    }
                }
                
                // Tester chaque position candidate
                for (const pos of candidates) {
                    if (this.isPositionFree(pos.col, pos.row, width, height)) {
                        return pos;
                    }
                }
                
                // Fallback : première position disponible
                for (let row = 1; row <= 8; row++) {
                    for (let col = 1; col <= 12; col++) {
                        if (this.isPositionFree(col, row, width, height)) {
                            return { col, row };
                        }
                    }
                }
                
                // Si vraiment pas de place, placer au centre avec chevauchement
                return { col: centerCol, row: centerRow };
            }
            
            // Vérifier si une position est libre
            isPositionFree(col, row, width, height) {
                // Vérifier les limites de grille
                if (col + width - 1 > 12 || row + height - 1 > 8) {
                    return false;
                }
                
                // Vérifier les collisions avec d'autres widgets
                for (const widget of this.widgets) {
                    const pos = widget.position || { col: 1, row: 1 };
                    const size = widget.size || { width: 3, height: 2 };
                    
                    // Vérifier si les rectangles se chevauchent
                    if (!(col >= pos.col + size.width || 
                          col + width <= pos.col || 
                          row >= pos.row + size.height || 
                          row + height <= pos.row)) {
                        return false;
                    }
                }
                
                return true;
            }
            
            // Configuration du drag & drop
            // Fonction de drag & drop fonctionnelle avec sauvegarde de position
            setupDragDrop(container, widget) {
                let isDragging = false;
                let startX, startY;
                let originalPosition = { ...widget.position } || { col: 1, row: 1 };
                
                const onMouseDown = (e) => {
                    // Ignorer les clics sur les boutons
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button') || e.target.closest('.widget-container-header')) {
                        return;
                    }
                    
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    originalPosition = { ...widget.position } || { col: 1, row: 1 };
                    
                    container.classList.add('dragging');
                    container.style.opacity = '0.8';
                    container.style.zIndex = '1000';
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };
                
                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    
                    const workspace = document.getElementById('canvasWorkspace');
                    if (!workspace) return;
                    
                    const rect = workspace.getBoundingClientRect();
                    const padding = 32; // Padding de la grille
                    
                    // Dimensions réelles de la grille utilisable
                    const gridWidth = rect.width - (padding * 2);
                    const gridHeight = rect.height - (padding * 2);
                    
                    // Taille d'une cellule (en tenant compte du gap de 8px)
                    const cellWidth = (gridWidth - (11 * 8)) / 12; // 11 gaps entre 12 colonnes
                    const cellHeight = (gridHeight - (7 * 8)) / 8;   // 7 gaps entre 8 rangées
                    
                    // Calcul du déplacement
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    // Conversion en déplacement de grille
                    const deltaCol = Math.round(deltaX / (cellWidth + 8)); // +8 pour le gap
                    const deltaRow = Math.round(deltaY / (cellHeight + 8)); // +8 pour le gap
                    
                    // Nouvelle position avec contraintes
                    const size = widget.size || { width: 3, height: 2 };
                    let newCol = Math.max(1, Math.min(12 - size.width + 1, originalPosition.col + deltaCol));
                    let newRow = Math.max(1, Math.min(8 - size.height + 1, originalPosition.row + deltaRow));
                    
                    // Mise à jour visuelle temporaire
                    container.style.gridColumnStart = newCol;
                    container.style.gridColumnEnd = newCol + size.width;
                    container.style.gridRowStart = newRow;
                    container.style.gridRowEnd = newRow + size.height;
                };
                
                const onMouseUp = (e) => {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    container.classList.remove('dragging');
                    container.style.opacity = '';
                    container.style.zIndex = '10';
                    
                    // Calculer la position finale définitive
                    const workspace = document.getElementById('canvasWorkspace');
                    if (!workspace) return;
                    
                    const rect = workspace.getBoundingClientRect();
                    const padding = 32;
                    const gridWidth = rect.width - (padding * 2);
                    const gridHeight = rect.height - (padding * 2);
                    const cellWidth = (gridWidth - (11 * 8)) / 12;
                    const cellHeight = (gridHeight - (7 * 8)) / 8;
                    
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    const deltaCol = Math.round(deltaX / (cellWidth + 8));
                    const deltaRow = Math.round(deltaY / (cellHeight + 8));
                    
                    const size = widget.size || { width: 3, height: 2 };
                    let newCol = Math.max(1, Math.min(12 - size.width + 1, originalPosition.col + deltaCol));
                    let newRow = Math.max(1, Math.min(8 - size.height + 1, originalPosition.row + deltaRow));
                    
                    // CRUCIAL: Sauvegarder définitivement la nouvelle position
                    widget.position = { col: newCol, row: newRow };
                    
                    // Appliquer la position finale CSS
                    container.style.gridColumnStart = newCol;
                    container.style.gridColumnEnd = newCol + size.width;
                    container.style.gridRowStart = newRow;
                    container.style.gridRowEnd = newRow + size.height;
                    
                    // Synchroniser avec le widget sélectionné si c'est le cas
                    if (this.selectedWidget && this.selectedWidget.id === widget.id) {
                        this.selectedWidget.position = { col: newCol, row: newRow };
                        
                        // Mettre à jour les sliders de position dans l'onglet Organisation
                        const colSlider = document.getElementById('positionColSlider');
                        const rowSlider = document.getElementById('positionRowSlider');
                        if (colSlider) colSlider.value = newCol;
                        if (rowSlider) rowSlider.value = newRow;
                        
                    }
                    
                    // Mettre à jour l'aperçu
                    this.updatePreview();
                    
                    // Mettre à jour le conteneur arrière-plan si activé
                    this.updateBackgroundContainer();
                    
                    // Message de confirmation
                    this.setStatus(`Widget repositionné: colonne ${newCol}, rangée ${newRow}`, 'success');
                    
                    // Nettoyer les événements
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                // Attacher l'événement mousedown
                container.addEventListener('mousedown', onMouseDown);
            }
            
            // Configuration du redimensionnement
            setupResize(container, widget) {
                const handles = container.querySelectorAll('.resize-handle');
                
                handles.forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        this.startResize(e, handle, container, widget);
                    });
                });
            }
            
            // Démarrer le redimensionnement
            startResize(e, handle, container, widget) {
                const direction = handle.dataset.direction;
                const startX = e.clientX;
                const startY = e.clientY;
                const startSize = { ...widget.size } || { width: 3, height: 2 };
                const startPos = { ...widget.position } || { col: 1, row: 1 };
                
                const handleMouseMove = (e) => {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    // Calculer la nouvelle taille selon la direction
                    let newSize = { ...startSize };
                    let newPos = { ...startPos };
                    
                    if (direction.includes('e')) {
                        newSize.width = Math.max(1, startSize.width + Math.round(deltaX / 60));
                    }
                    if (direction.includes('w')) {
                        const deltaWidth = Math.round(deltaX / -60);
                        newSize.width = Math.max(1, startSize.width + deltaWidth);
                        newPos.col = Math.max(1, startPos.col - deltaWidth);
                    }
                    if (direction.includes('s')) {
                        newSize.height = Math.max(1, startSize.height + Math.round(deltaY / 60));
                    }
                    if (direction.includes('n')) {
                        const deltaHeight = Math.round(deltaY / -60);
                        newSize.height = Math.max(1, startSize.height + deltaHeight);
                        newPos.row = Math.max(1, startPos.row - deltaHeight);
                    }
                    
                    // Vérifier les limites
                    if (newPos.col + newSize.width - 1 <= 12 && newPos.row + newSize.height - 1 <= 8) {
                        widget.size = newSize;
                        widget.position = newPos;
                        
                        // Mettre à jour le style du conteneur
                        container.style.gridColumnStart = newPos.col;
                        container.style.gridColumnEnd = newPos.col + newSize.width;
                        container.style.gridRowStart = newPos.row;
                        container.style.gridRowEnd = newPos.row + newSize.height;
                    }
                };
                
                const handleMouseUp = () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                    
                    this.updatePreview();
                    this.setStatus('Widget redimensionné', 'success');
                };
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            }
            
            setStatus(message, type = 'info') {
                const statusText = document.getElementById('statusText');
                const statusIndicator = document.getElementById('statusIndicator');
                
                if (statusText) statusText.textContent = message;
                if (statusIndicator) statusIndicator.className = `status-indicator ${type}`;
                
                if (type === 'success' || type === 'info') {
                    setTimeout(() => {
                        if (statusText && statusText.textContent === message) {
                            this.setStatus('Prêt', 'success');
                        }
                    }, 3000);
                }
                
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
            
            // Gestion dynamique des fonctionnalités pour Pricing Card
            addFeatureToSelected() {
                if (!this.selectedWidget || this.selectedWidget.type !== 'pricing-card') return;
                
                const input = document.getElementById('newFeatureInput');
                if (!input || !input.value.trim()) return;
                
                const newFeature = input.value.trim();
                this.selectedWidget.data.features.push(newFeature);
                
                // Vider l'input
                input.value = '';
                
                // Mettre à jour l'interface
                this.updateElementsTab();
                this.renderSelectedWidget();
                this.updatePreview();
                
                this.setStatus(`Fonctionnalité "${newFeature}" ajoutée`, 'success');
            }
            
            removeFeatureAtIndex(index) {
                if (!this.selectedWidget || this.selectedWidget.type !== 'pricing-card') return;
                
                const features = this.selectedWidget.data.features;
                if (index < 0 || index >= features.length) return;
                
                const removedFeature = features[index];
                features.splice(index, 1);
                
                // Mettre à jour l'interface
                this.updateElementsTab();
                this.renderSelectedWidget();
                this.updatePreview();
                
                this.setStatus(`Fonctionnalité "${removedFeature}" supprimée`, 'success');
            }
            
            updateFeatureAtIndex(index, newValue) {
                if (!this.selectedWidget || this.selectedWidget.type !== 'pricing-card') return;
                
                const features = this.selectedWidget.data.features;
                if (index < 0 || index >= features.length) return;
                
                features[index] = newValue.trim();
                
                // Mettre à jour uniquement l'affichage (pas l'onglet Elements pour éviter la perte de focus)
                this.renderSelectedWidget();
                this.updatePreview();
            }
            
            // Fonction pour re-render un widget spécifique
            renderSelectedWidget() {
                if (!this.selectedWidget) return;
                
                const container = document.querySelector(`[data-widget-id="${this.selectedWidget.id}"]`);
                if (!container) return;
                
                const contentDiv = container.querySelector('.widget-content');
                if (contentDiv) {
                    contentDiv.innerHTML = this.selectedWidget.instance.render(this.selectedWidget.data);
                }
            }

            // ================================================================
            // NOUVELLES FONCTIONS - GESTION TAILLE ET POSITION
            // ================================================================
            
            // Mettre à jour la taille d'un widget
            updateWidgetSize(dimension, value) {
                if (!this.selectedWidget) return;
                
                const numValue = parseInt(value, 10);
                if (isNaN(numValue)) return;
                
                // Initialiser size si nécessaire
                if (!this.selectedWidget.size) {
                    this.selectedWidget.size = { width: 3, height: 2 };
                }
                
                // Mettre à jour la dimension
                this.selectedWidget.size[dimension] = numValue;
                
                // Synchroniser les contrôles
                this.syncSizeControls(dimension, numValue);
                
                // Vérifier que le widget reste dans les limites de la grille
                this.constrainWidgetToGrid();
                
                // Mettre à jour l'affichage
                this.renderCanvas();
                this.updatePreview();
                
                this.setStatus(`${dimension === 'width' ? 'Largeur' : 'Hauteur'} mise à jour: ${numValue}`, 'info');
            }
            
            // Mettre à jour la position d'un widget
            updateWidgetPosition(dimension, value) {
                if (!this.selectedWidget) return;
                
                const numValue = parseInt(value, 10);
                if (isNaN(numValue)) return;
                
                // Initialiser position si nécessaire
                if (!this.selectedWidget.position) {
                    this.selectedWidget.position = { col: 1, row: 1 };
                }
                
                // Mettre à jour la dimension
                this.selectedWidget.position[dimension] = numValue;
                
                // Vérifier que le widget reste dans les limites de la grille
                this.constrainWidgetToGrid();
                
                // Mettre à jour l'affichage
                this.renderCanvas();
                this.updatePreview();
                
                this.setStatus(`Position ${dimension === 'col' ? 'colonne' : 'rangée'} mise à jour: ${numValue}`, 'info');
            }
            
            // Synchroniser les contrôles de taille
            syncSizeControls(changedDimension, value) {
                if (changedDimension === 'width') {
                    const widthSlider = document.getElementById('widthSlider');
                    const widthInput = document.getElementById('widthInput');
                    if (widthSlider && widthSlider.value != value) widthSlider.value = value;
                    if (widthInput && widthInput.value != value) widthInput.value = value;
                } else if (changedDimension === 'height') {
                    const heightSlider = document.getElementById('heightSlider');
                    const heightInput = document.getElementById('heightInput');
                    if (heightSlider && heightSlider.value != value) heightSlider.value = value;
                    if (heightInput && heightInput.value != value) heightInput.value = value;
                }
            }
            
            // Contraindre le widget aux limites de la grille
            constrainWidgetToGrid() {
                if (!this.selectedWidget) return;
                
                const size = this.selectedWidget.size || { width: 3, height: 2 };
                const position = this.selectedWidget.position || { col: 1, row: 1 };
                
                // Limiter la taille maximale
                size.width = Math.max(1, Math.min(12, size.width));
                size.height = Math.max(1, Math.min(8, size.height));
                
                // Ajuster la position si le widget dépasse
                position.col = Math.max(1, Math.min(12 - size.width + 1, position.col));
                position.row = Math.max(1, Math.min(8 - size.height + 1, position.row));
                
                // Mettre à jour l'objet
                this.selectedWidget.size = size;
                this.selectedWidget.position = position;
                
                // Mettre à jour les contrôles
            }
            
            // Définir un widget en plein écran
            setFullScreen() {
                if (!this.selectedWidget) return;
                
                this.selectedWidget.size = { width: 12, height: 8 };
                this.selectedWidget.position = { col: 1, row: 1 };
                
                this.renderCanvas();
                this.updatePreview();
                
                this.setStatus('Widget mis en plein écran', 'success');
            }
            
            // Remplir le conteneur parent (version simplifiée - toute la largeur, hauteur adaptative)
            fillParent() {
                if (!this.selectedWidget) return;
                
                // Pour cette version, "remplir parent" = largeur maximale avec hauteur de 4 rangées
                this.selectedWidget.size = { width: 12, height: 4 };
                
                // Garder la position actuelle en colonne, mais vérifier les limites
                const currentPosition = this.selectedWidget.position || { col: 1, row: 1 };
                this.selectedWidget.position = { col: 1, row: currentPosition.row };
                
                this.constrainWidgetToGrid();
                this.renderCanvas();
                this.updatePreview();
                
                this.setStatus('Widget configuré pour remplir le conteneur parent', 'success');
            }

            // ================================================================
            // GESTION DES FONCTIONNALITÉS DE LA GRILLE
            // ================================================================
            
            // Ajouter une nouvelle fonctionnalité à la grille
            addFeatureToGrid() {
                if (!this.selectedWidget || this.selectedWidget.type !== 'feature-grid') return;
                
                if (!this.selectedWidget.data.features) {
                    this.selectedWidget.data.features = [];
                }
                
                this.selectedWidget.data.features.push({
                    icon: '⭐',
                    title: 'Nouvelle fonctionnalité',
                    description: 'Description de la nouvelle fonctionnalité',
                    iconSize: '3rem',
                    titleColor: 'white',
                    titleSize: '1.5rem',
                    descriptionColor: 'var(--text-gray)',
                    descriptionSize: '0.95rem',
                    backgroundColor: 'var(--bg-card)',
                    borderColor: 'var(--border-color)'
                });
                
                // Mettre à jour l'interface
                this.updateElementsTab();
                this.renderCanvas();
                this.updatePreview();
                
                this.setStatus('Nouvelle fonctionnalité ajoutée', 'success');
            }
            
            // Supprimer une fonctionnalité de la grille
            removeGridFeature(index) {
                if (!this.selectedWidget || this.selectedWidget.type !== 'feature-grid') return;
                
                const features = this.selectedWidget.data.features;
                if (!features || index < 0 || index >= features.length) return;
                
                if (confirm(`Supprimer la fonctionnalité "${features[index].title}" ?`)) {
                    features.splice(index, 1);
                    
                    // Ajuster le nombre de fonctionnalités actives si nécessaire
                    if (this.selectedWidget.data.featuresCount > features.length) {
                        this.selectedWidget.data.featuresCount = features.length;
                    }
                    
                    // Mettre à jour l'interface
                    this.updateElementsTab();
                    this.renderCanvas();
                    this.updatePreview();
                    
                    this.setStatus('Fonctionnalité supprimée', 'success');
                }
            }
            
            // Mettre à jour une fonctionnalité de la grille
            updateGridFeature(index, field, value) {
                if (!this.selectedWidget || this.selectedWidget.type !== 'feature-grid') return;
                
                const features = this.selectedWidget.data.features;
                if (!features || index < 0 || index >= features.length) return;
                
                features[index][field] = value;
                
                // Mettre à jour le rendu en temps réel
                this.renderCanvas();
                this.updatePreview();
                
                // Message de statut discret uniquement pour les changements importants
                if (field === 'title') {
                    this.setStatus(`Titre mis à jour: ${value}`, 'info');
                }
            }

            // Fonction toggle conteneur arrière-plan global adaptatif
            toggleBackground() {
                const workspace = document.getElementById('canvasWorkspace');
                const backgroundButton = document.getElementById('backgroundToggleBtn');
                
                if (!workspace) return;
                
                let container = workspace.querySelector('.global-background-container');
                const isActive = container !== null;
                
                if (isActive) {
                    // Désactiver le conteneur
                    if (container) {
                        container.remove();
                    }
                    
                    if (backgroundButton) {
                        backgroundButton.classList.remove('btn-primary');
                        backgroundButton.innerHTML = '<i class="fas fa-square"></i> Conteneur';
                        backgroundButton.style.background = '';
                        backgroundButton.style.borderColor = '';
                    }
                    
                    this.setStatus('Conteneur arrière-plan désactivé', 'info');
                } else {
                    // Activer le conteneur
                    container = document.createElement('div');
                    container.className = 'global-background-container active';
                    workspace.appendChild(container);
                    
                    if (backgroundButton) {
                        backgroundButton.classList.add('btn-primary');
                        backgroundButton.innerHTML = '<i class="fas fa-square"></i> Masquer Conteneur';
                        backgroundButton.style.background = 'var(--accent-green)';
                        backgroundButton.style.borderColor = 'var(--accent-green)';
                    }
                    
                    // Calculer et appliquer les dimensions
                    this.updateBackgroundContainer();
                    
                    this.setStatus('Conteneur arrière-plan adaptatif activé', 'success');
                }
            }
            
            // Mettre à jour le conteneur arrière-plan pour qu'il englobe tous les widgets
            updateBackgroundContainer() {
                const workspace = document.getElementById('canvasWorkspace');
                const container = workspace?.querySelector('.global-background-container');
                
                if (!container || this.widgets.length === 0) return;
                
                // Calculer les dimensions englobantes de tous les widgets
                let minCol = 12, maxCol = 1, minRow = 8, maxRow = 1;
                
                this.widgets.forEach(widget => {
                    const pos = widget.position || { col: 1, row: 1 };
                    const size = widget.size || { width: 3, height: 2 };
                    
                    minCol = Math.min(minCol, pos.col);
                    maxCol = Math.max(maxCol, pos.col + size.width - 1);
                    minRow = Math.min(minRow, pos.row);
                    maxRow = Math.max(maxRow, pos.row + size.height - 1);
                });
                
                // Ajouter une marge de padding autour des widgets
                const padding = 1;
                minCol = Math.max(1, minCol - padding);
                maxCol = Math.min(12, maxCol + padding);
                minRow = Math.max(1, minRow - padding);
                maxRow = Math.min(8, maxRow + padding);
                
                // Appliquer les dimensions CSS Grid au conteneur
                container.style.gridColumnStart = minCol;
                container.style.gridColumnEnd = maxCol + 1;
                container.style.gridRowStart = minRow;
                container.style.gridRowEnd = maxRow + 1;
                
                // Ajouter du contenu visuel au conteneur
                container.innerHTML = `
                    <div style="position: absolute; top: 8px; left: 12px; 
                                background: rgba(16, 185, 129, 0.8); color: white; 
                                padding: 4px 8px; border-radius: 4px; font-size: 10px; 
                                font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">
                        Conteneur Global (${maxCol - minCol + 1}×${maxRow - minRow + 1})
                    </div>
                `;
            }

            // Fonction toggle grille avec indicateur visuel
            toggleGrid() {
                const workspace = document.getElementById('canvasWorkspace');
                const gridButton = document.getElementById('gridToggleBtn');
                
                if (workspace) {
                    const isGridVisible = workspace.classList.toggle('show-grid');
                    
                    // Mettre à jour l'apparence du bouton
                    if (gridButton) {
                        if (isGridVisible) {
                            gridButton.classList.add('btn-primary');
                            gridButton.innerHTML = '<i class="fas fa-th"></i> Masquer Grille';
                            gridButton.style.background = 'var(--accent-green)';
                            gridButton.style.borderColor = 'var(--accent-green)';
                        } else {
                            gridButton.classList.remove('btn-primary');
                            gridButton.innerHTML = '<i class="fas fa-th"></i> Grille';
                            gridButton.style.background = '';
                            gridButton.style.borderColor = '';
                        }
                    }
                    
                    // Message de statut informatif
                    const statusMessage = isGridVisible ? 
                        'Grille 12×8 affichée - Positionnement visuel activé' : 
                        'Grille masquée - Mode édition normal';
                    
                    this.setStatus(statusMessage, 'info');
                }
            }
            
            // Rôle      : Configuration du système de redimensionnement du panneau propriétés
            // Type      : méthode (sans paramètres)
            // Unité     : sans unité
            // Domaine   : méthode d'initialisation
            // Formule   : configuration des event listeners pour le handle de redimensionnement
            // Exemple   : setupPropertiesResize() - active le redimensionnement par glisser-déposer
            setupPropertiesResize() {
                // Rôle      : Handle de redimensionnement du panneau
                // Type      : HTMLElement
                // Unité     : sans unité  
                // Domaine   : élément DOM existant ou null
                // Formule   : sélecteur CSS .resize-handle
                // Exemple   : <div class="resize-handle"></div>
                const resizeHandle = document.querySelector('.resize-handle');
                if (!resizeHandle) return;
                
                // Rôle      : Indicateur de redimensionnement actif
                // Type      : boolean
                // Unité     : sans unité
                // Domaine   : true/false
                // Formule   : état = mousedown && mousemove
                // Exemple   : true pendant le glisser-déposer
                let isResizing = false;
                
                // Rôle      : Position initiale de la souris
                // Type      : number
                // Unité     : pixels (px)
                // Domaine   : coordonnées écran >= 0
                // Formule   : position = event.clientX
                // Exemple   : 1200 (pixels depuis le bord gauche de l'écran)
                let startX = 0;
                
                // Rôle      : Largeur initiale du panneau
                // Type      : number  
                // Unité     : pixels (px)
                // Domaine   : largeur >= 250px et <= 600px
                // Formule   : largeur = getComputedStyle(panel).width
                // Exemple   : 350 (largeur par défaut)
                let startWidth = 0;
                
                // Gestionnaire de début de redimensionnement
                resizeHandle.addEventListener('mousedown', (e) => {
                    // Rôle      : Activation du mode redimensionnement
                    // Type      : opération (changement d'état)
                    // Unité     : sans unité
                    // Domaine   : isResizing = false -> true
                    // Formule   : état = true + capture position/taille initiales
                    // Exemple   : mousedown -> isResizing=true, startX=1200, startWidth=350
                    isResizing = true;
                    startX = e.clientX;
                    
                    const propertiesPanel = document.querySelector('.properties-panel');
                    if (propertiesPanel) {
                        // Rôle      : Récupération largeur actuelle
                        // Type      : number (conversion string->number)
                        // Unité     : pixels (px)
                        // Domaine   : largeur >= 0
                        // Formule   : parseInt(getComputedStyle().width)
                        // Exemple   : "350px" -> 350
                        startWidth = parseInt(getComputedStyle(propertiesPanel).width);
                    }
                    
                    // Ajout des classes visuelles
                    resizeHandle.classList.add('resizing');
                    document.body.style.cursor = 'ew-resize';
                    document.body.style.userSelect = 'none';
                    
                    e.preventDefault();
                });
                
                // Gestionnaire de mouvement de redimensionnement
                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    
                    // Rôle      : Calcul du déplacement de la souris
                    // Type      : number (différence)
                    // Unité     : pixels (px)
                    // Domaine   : delta peut être négatif ou positif
                    // Formule   : delta = position_actuelle - position_initiale
                    // Exemple   : 1150 - 1200 = -50 (souris vers la gauche)
                    const deltaX = e.clientX - startX;
                    
                    // Rôle      : Nouvelle largeur calculée
                    // Type      : number (soustraction car handle à gauche)
                    // Unité     : pixels (px)  
                    // Domaine   : 250 <= newWidth <= 600
                    // Formule   : nouvelle_largeur = largeur_initiale - déplacement
                    // Exemple   : 350 - (-50) = 400 (panneau plus large)
                    const newWidth = startWidth - deltaX;
                    
                    // Rôle      : Largeur contrainte dans les limites
                    // Type      : number (application des bornes min/max)
                    // Unité     : pixels (px)
                    // Domaine   : 250 <= constrainedWidth <= 600
                    // Formule   : width = Math.max(min_width, Math.min(max_width, calculated_width))
                    // Exemple   : Math.max(250, Math.min(600, 400)) = 400
                    const constrainedWidth = Math.max(250, Math.min(600, newWidth));
                    
                    const propertiesPanel = document.querySelector('.properties-panel');
                    const widgetEditor = document.querySelector('.widget-editor');
                    if (propertiesPanel && widgetEditor) {
                        // Application de la nouvelle largeur
                        const rootStyle = document.documentElement.style;
                        rootStyle.setProperty('--properties-width', `${constrainedWidth}px`);
                        propertiesPanel.style.width = `${constrainedWidth}px`;
                        
                        // Mise à jour du grid-template-columns
                        widgetEditor.style.gridTemplateColumns = `280px 1fr ${constrainedWidth}px`;
                        
                        // Mise à jour de l'indicateur de largeur
                        const widthIndicator = document.querySelector('.properties-width-indicator');
                        if (widthIndicator) {
                            widthIndicator.textContent = `${constrainedWidth}px`;
                        }
                    }
                });
                
                // Gestionnaire de fin de redimensionnement
                document.addEventListener('mouseup', () => {
                    if (!isResizing) return;
                    
                    // Rôle      : Désactivation du mode redimensionnement
                    // Type      : opération (remise à l'état initial)
                    // Unité     : sans unité
                    // Domaine   : isResizing = true -> false
                    // Formule   : état = false + suppression classes/styles temporaires
                    // Exemple   : mouseup -> isResizing=false, cursor=default
                    isResizing = false;
                    resizeHandle.classList.remove('resizing');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                });
            }
            
            // Rôle      : Basculement de l'état collapsed/expanded du panneau propriétés  
            // Type      : méthode (sans paramètres)
            // Unité     : sans unité
            // Domaine   : méthode de toggle UI
            // Formule   : état = !état_actuel
            // Exemple   : togglePropertiesPanel() - panneau ouvert -> fermé ou fermé -> ouvert
            togglePropertiesPanel() {
                // Rôle      : Panneau de propriétés à basculer
                // Type      : HTMLElement
                // Unité     : sans unité
                // Domaine   : élément DOM existant ou null
                // Formule   : sélecteur CSS .properties-panel
                // Exemple   : <div class="properties-panel">...</div>
                const propertiesPanel = document.querySelector('.properties-panel');
                if (!propertiesPanel) return;
                
                // Rôle      : État collapsed actuel du panneau
                // Type      : boolean
                // Unité     : sans unité
                // Domaine   : true/false
                // Formule   : isCollapsed = panel.classList.contains('collapsed')
                // Exemple   : false (panneau ouvert)
                const isCollapsed = propertiesPanel.classList.contains('collapsed');
                
                if (isCollapsed) {
                    // Rôle      : Expansion du panneau (ouverture)
                    // Type      : opération (changement de classe CSS)
                    // Unité     : sans unité
                    // Domaine   : suppression classe 'collapsed'
                    // Formule   : panel.classList.remove('collapsed')
                    // Exemple   : panneau fermé -> panneau ouvert (largeur normale)
                    propertiesPanel.classList.remove('collapsed');
                    propertiesPanel.style.width = propertiesPanel.style.getPropertyValue('--properties-width') || '350px';
                } else {
                    // Rôle      : Collapse du panneau (fermeture)
                    // Type      : opération (ajout de classe CSS)
                    // Unité     : sans unité
                    // Domaine   : ajout classe 'collapsed'
                    // Formule   : panel.classList.add('collapsed')
                    // Exemple   : panneau ouvert -> panneau fermé (largeur minimale 40px)
                    propertiesPanel.classList.add('collapsed');
                    propertiesPanel.style.width = '40px';
                }
                
                // Rôle      : Icône du bouton de collapse
                // Type      : HTMLElement
                // Unité     : sans unité
                // Domaine   : élément DOM existant ou null
                // Formule   : sélecteur CSS du bouton collapse
                // Exemple   : <i class="fas fa-chevron-right"></i>
                const collapseIcon = document.querySelector('.properties-collapse-btn i');
                if (collapseIcon) {
                    // Rôle      : Rotation de l'icône selon l'état
                    // Type      : string (classe CSS)
                    // Unité     : sans unité
                    // Domaine   : 'fa-chevron-right' ou 'fa-chevron-left'
                    // Formule   : classe = isCollapsed ? 'fa-chevron-left' : 'fa-chevron-right'
                    // Exemple   : panneau fermé -> 'fa-chevron-left' (flèche vers la gauche pour ouvrir)
                    collapseIcon.className = isCollapsed ? 'fas fa-chevron-left' : 'fas fa-chevron-right';
                }
            }
        }

        // Initialisation
        const widgetEditor = new WidgetEditorComplete();
        
        // Exposition globale
        window.widgetEditor = widgetEditor;
        
        // CSS pour les animations
        const style = document.createElement('style');
        style.textContent = `
            .slide-up {
                opacity: 0;
                transform: translateY(30px);
                animation: slideUp 0.6s ease-out forwards;
            }
            
            @keyframes slideUp {
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            
            .hover-effect:hover {
                transform: scale(1.1) !important;
                box-shadow: 0 10px 25px rgba(16, 185, 129, 0.3) !important;
            }
        `;
        document.head.appendChild(style);
        
    </script>
    
    <!-- Popup de prévisualisation plein écran -->
    <div class="preview-popup" id="previewPopup">
        <!-- Header avec contrôles -->
        <div class="preview-header">
            <div class="preview-title">
                <i class="fas fa-eye"></i>
                Prévisualisation temps réel
            </div>
            <div class="preview-controls">
                <div style="color: var(--text-muted); font-size: 0.9rem; margin-right: 1rem;">
                    <i class="fas fa-info-circle"></i>
                    Rendu final tel qu'il apparaîtra dans la présentation exportée
                </div>
                <button class="preview-close" id="closePreviewBtn">
                    <i class="fas fa-times"></i>
                    Fermer
                </button>
            </div>
        </div>
        
        <!-- Contenu de prévisualisation -->
        <div class="preview-content">
            <div class="preview-grid" id="previewGrid">
                <!-- Widgets générés dynamiquement -->
            </div>
        </div>
    </div>
    
</body>
</html>