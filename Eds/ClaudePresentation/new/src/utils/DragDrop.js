/**
 * Utilitaires pour le syst√®me de glisser-d√©poser
 * 
 * R√¥le : Gestion des interactions drag & drop dans l'√©diteur
 * Type : Module utilitaire pour interactions tactiles/souris
 * Usage : Facilite l'impl√©mentation du drag & drop pour widgets et sections
 */

/**
 * Classe utilitaire pour le drag & drop
 * 
 * R√¥le : Abstraction des √©v√©nements de glisser-d√©poser
 * Type : Utilitaire de gestion d'√©v√©nements
 * Usage : Simplifie l'ajout de fonctionnalit√©s drag & drop
 */
class DragDropHelper {
    /**
     * Constructeur du helper drag & drop
     * 
     * R√¥le : Initialisation du gestionnaire de drag & drop
     * Type : Constructeur de classe utilitaire
     */
    constructor() {
        // Configuration par d√©faut
        this.config = {
            dragClass: 'dragging',
            dragOverClass: 'drag-over',
            dropZoneClass: 'drop-zone',
            dragHandle: '.drag-handle'
        };

        // √âtat du drag & drop
        this.dragState = {
            isDragging: false,
            dragElement: null,
            dragData: null,
            startPosition: { x: 0, y: 0 },
            currentPosition: { x: 0, y: 0 }
        };

        // Callbacks
        this.callbacks = {
            onDragStart: null,
            onDragMove: null,
            onDragEnd: null,
            onDrop: null
        };
    }

    /**
     * Active le drag & drop sur un √©l√©ment
     * 
     * R√¥le : Configuration d'un √©l√©ment comme draggable
     * Type : M√©thode de configuration
     * Param√®tres : element - Element √† rendre draggable, options - Configuration
     * Effet de bord : Ajoute les √©v√©nements de drag & drop
     */
    makeDraggable(element, options = {}) {
        if (!element) return;

        // Fusion des options
        const config = { ...this.config, ...options };

        // Ajout des attributs
        element.draggable = true;
        element.classList.add('draggable');

        // √âv√©nements de drag
        element.addEventListener('dragstart', (e) => this.handleDragStart(e, config));
        element.addEventListener('dragend', (e) => this.handleDragEnd(e, config));

        console.log('üéØ √âl√©ment rendu draggable:', element);
    }

    /**
     * Active une zone de drop
     * 
     * R√¥le : Configuration d'un √©l√©ment comme zone de d√©p√¥t
     * Type : M√©thode de configuration
     * Param√®tres : element - Element zone de drop, options - Configuration
     * Effet de bord : Ajoute les √©v√©nements de r√©ception de drop
     */
    makeDropZone(element, options = {}) {
        if (!element) return;

        // Fusion des options
        const config = { ...this.config, ...options };

        // Ajout de la classe
        element.classList.add(config.dropZoneClass);

        // √âv√©nements de drop
        element.addEventListener('dragover', (e) => this.handleDragOver(e, config));
        element.addEventListener('drop', (e) => this.handleDrop(e, config));
        element.addEventListener('dragenter', (e) => this.handleDragEnter(e, config));
        element.addEventListener('dragleave', (e) => this.handleDragLeave(e, config));

        console.log('üì• Zone de drop activ√©e:', element);
    }

    /**
     * Gestionnaire de d√©but de drag
     * 
     * R√¥le : Traitement du d√©but d'un glisser-d√©poser
     * Type : Gestionnaire d'√©v√©nement
     * Param√®tres : e - √âv√©nement drag, config - Configuration
     * Effet de bord : Initialise l'√©tat de drag
     */
    handleDragStart(e, config) {
        const element = e.currentTarget;
        
        // Mise √† jour de l'√©tat
        this.dragState.isDragging = true;
        this.dragState.dragElement = element;
        this.dragState.startPosition = { x: e.clientX, y: e.clientY };

        // Ajout de la classe CSS
        element.classList.add(config.dragClass);

        // Donn√©es de transfer (pour compatibilit√© navigateurs)
        const dragData = this.extractDragData(element);
        this.dragState.dragData = dragData;
        e.dataTransfer.setData('text/plain', JSON.stringify(dragData));

        // Callback personnalis√©
        if (this.callbacks.onDragStart) {
            this.callbacks.onDragStart(element, dragData, e);
        }

        console.log('üéØ D√©but de drag:', dragData);
    }

    /**
     * Gestionnaire de fin de drag
     * 
     * R√¥le : Traitement de la fin d'un glisser-d√©poser
     * Type : Gestionnaire d'√©v√©nement
     * Param√®tres : e - √âv√©nement drag, config - Configuration
     * Effet de bord : Nettoie l'√©tat de drag
     */
    handleDragEnd(e, config) {
        const element = e.currentTarget;
        
        // Nettoyage des classes CSS
        element.classList.remove(config.dragClass);
        document.querySelectorAll(`.${config.dragOverClass}`).forEach(el => {
            el.classList.remove(config.dragOverClass);
        });

        // Callback personnalis√©
        if (this.callbacks.onDragEnd) {
            this.callbacks.onDragEnd(element, this.dragState.dragData, e);
        }

        // R√©initialisation de l'√©tat
        this.dragState.isDragging = false;
        this.dragState.dragElement = null;
        this.dragState.dragData = null;

        console.log('üèÅ Fin de drag');
    }

    /**
     * Gestionnaire de survol de zone de drop
     * 
     * R√¥le : Traitement du survol d'une zone de d√©p√¥t
     * Type : Gestionnaire d'√©v√©nement
     * Param√®tres : e - √âv√©nement dragover, config - Configuration
     * Effet de bord : Autorise le drop et met √† jour l'affichage
     */
    handleDragOver(e, config) {
        e.preventDefault(); // Autoriser le drop
        
        // Mise √† jour de la position
        this.dragState.currentPosition = { x: e.clientX, y: e.clientY };

        // Callback personnalis√©
        if (this.callbacks.onDragMove) {
            this.callbacks.onDragMove(e.currentTarget, this.dragState.dragData, e);
        }
    }

    /**
     * Gestionnaire d'entr√©e dans zone de drop
     * 
     * R√¥le : Traitement de l'entr√©e dans une zone de d√©p√¥t
     * Type : Gestionnaire d'√©v√©nement
     * Param√®tres : e - √âv√©nement dragenter, config - Configuration
     * Effet de bord : Ajoute la classe CSS de survol
     */
    handleDragEnter(e, config) {
        e.preventDefault();
        e.currentTarget.classList.add(config.dragOverClass);
    }

    /**
     * Gestionnaire de sortie de zone de drop
     * 
     * R√¥le : Traitement de la sortie d'une zone de d√©p√¥t
     * Type : Gestionnaire d'√©v√©nement
     * Param√®tres : e - √âv√©nement dragleave, config - Configuration
     * Effet de bord : Supprime la classe CSS de survol
     */
    handleDragLeave(e, config) {
        // V√©rifier si on sort vraiment de l'√©l√©ment (pas juste un enfant)
        if (!e.currentTarget.contains(e.relatedTarget)) {
            e.currentTarget.classList.remove(config.dragOverClass);
        }
    }

    /**
     * Gestionnaire de drop
     * 
     * R√¥le : Traitement du d√©p√¥t d'un √©l√©ment
     * Type : Gestionnaire d'√©v√©nement
     * Param√®tres : e - √âv√©nement drop, config - Configuration
     * Effet de bord : Ex√©cute l'action de d√©p√¥t
     */
    handleDrop(e, config) {
        e.preventDefault();
        
        const dropZone = e.currentTarget;
        
        // Nettoyage des classes CSS
        dropZone.classList.remove(config.dragOverClass);

        // R√©cup√©ration des donn√©es
        let dragData;
        try {
            dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
        } catch (error) {
            dragData = this.dragState.dragData;
        }

        // Callback personnalis√©
        if (this.callbacks.onDrop) {
            this.callbacks.onDrop(dropZone, dragData, e);
        }

        console.log('üì• Drop effectu√©:', { dropZone, dragData });
    }

    /**
     * Extrait les donn√©es de drag d'un √©l√©ment
     * 
     * R√¥le : R√©cup√©ration des m√©tadonn√©es pour le drag & drop
     * Type : M√©thode utilitaire
     * Param√®tre : element - √âl√©ment source
     * Retour : Object - Donn√©es de drag
     */
    extractDragData(element) {
        return {
            type: element.dataset.dragType || 'unknown',
            id: element.dataset.dragId || element.id || null,
            sourceIndex: Array.from(element.parentElement?.children || []).indexOf(element),
            metadata: {
                widgetType: element.dataset.widgetType,
                sectionType: element.dataset.sectionType,
                content: element.dataset.dragContent
            }
        };
    }

    /**
     * Configure les callbacks
     * 
     * R√¥le : D√©finition des fonctions de rappel personnalis√©es
     * Type : M√©thode de configuration
     * Param√®tre : callbacks - Objet contenant les callbacks
     * Effet de bord : Met √† jour les callbacks internes
     */
    setCallbacks(callbacks) {
        this.callbacks = { ...this.callbacks, ...callbacks };
        console.log('üîó Callbacks drag & drop configur√©s');
    }

    /**
     * Active le drag & drop sur une collection d'√©l√©ments
     * 
     * R√¥le : Configuration en lot d'√©l√©ments draggable
     * Type : M√©thode utilitaire de configuration
     * Param√®tres : elements - Collection d'√©l√©ments, options - Configuration
     * Effet de bord : Active le drag & drop sur tous les √©l√©ments
     */
    makeBatchDraggable(elements, options = {}) {
        const elementsArray = Array.from(elements);
        elementsArray.forEach(element => {
            this.makeDraggable(element, options);
        });
        
        console.log(`üéØ ${elementsArray.length} √©l√©ments rendus draggable`);
    }

    /**
     * Active les zones de drop sur une collection
     * 
     * R√¥le : Configuration en lot de zones de d√©p√¥t
     * Type : M√©thode utilitaire de configuration
     * Param√®tres : elements - Collection d'√©l√©ments, options - Configuration
     * Effet de bord : Active les zones de drop sur tous les √©l√©ments
     */
    makeBatchDropZone(elements, options = {}) {
        const elementsArray = Array.from(elements);
        elementsArray.forEach(element => {
            this.makeDropZone(element, options);
        });
        
        console.log(`üì• ${elementsArray.length} zones de drop activ√©es`);
    }
}

// Instance globale pour faciliter l'utilisation
const dragDropHelper = new DragDropHelper();

// Export pour utilisation en module
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { DragDropHelper, dragDropHelper };
} else if (typeof window !== 'undefined') {
    window.DragDropHelper = DragDropHelper;
    window.dragDropHelper = dragDropHelper;
}