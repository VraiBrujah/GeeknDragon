#!/usr/bin/env php
<?php
/**
 * Script de Test du Syst√®me de Monitoring - Geek & Dragon
 *
 * Script CLI pour tester et valider le fonctionnement du syst√®me de monitoring.
 * Tests automatis√©s de tous les composants et g√©n√©ration de rapport de validation.
 *
 * Usage:
 *   php scripts/test-monitoring.php [--verbeux] [--quick] [--rapport]
 *
 * @author Brujah
 * @version 1.0.0
 * @since 2025-09-27
 */

// V√©rifier que le script est ex√©cut√© en CLI
if (php_sapi_name() !== 'cli') {
    http_response_code(403);
    exit('Ce script doit √™tre ex√©cut√© en ligne de commande uniquement.');
}

// Initialisation
$scriptDir = dirname(__DIR__);
require_once $scriptDir . '/bootstrap.php';

// Configuration des tests
$config = [
    'verbeux' => in_array('--verbeux', $argv),
    'quick' => in_array('--quick', $argv),
    'rapport' => in_array('--rapport', $argv),
    'repertoire_logs' => $scriptDir . '/logs'
];

// R√©sultats des tests
$r√©sultatsTests = [
    'd√©but' => microtime(true),
    'tests_pass√©s' => 0,
    'tests_√©chou√©s' => 0,
    'erreurs' => [],
    'm√©triques' => []
];

/**
 * Affiche un message si le mode verbeux est activ√©
 *
 * @param string $message Message √† afficher
 * @param string $niveau Niveau (INFO, WARN, ERROR, SUCCESS)
 * @return void
 */
function afficherVerbeux(string $message, string $niveau = 'INFO'): void
{
    global $config;

    if (!$config['verbeux']) {
        return;
    }

    $icones = [
        'INFO' => 'üí°',
        'WARN' => '‚ö†Ô∏è',
        'ERROR' => '‚ùå',
        'SUCCESS' => '‚úÖ',
        'TEST' => 'üß™'
    ];

    echo ($icones[$niveau] ?? '‚Ä¢') . " {$message}\n";
}

/**
 * Ex√©cute un test et enregistre le r√©sultat
 *
 * @param string $nom Nom du test
 * @param callable $fonction Fonction de test
 * @return bool R√©sultat du test
 */
function ex√©cuterTest(string $nom, callable $fonction): bool
{
    global $r√©sultatsTests;

    afficherVerbeux("Test : {$nom}", 'TEST');

    try {
        $d√©but = microtime(true);
        $r√©sultat = $fonction();
        $dur√©e = microtime(true) - $d√©but;

        $r√©sultatsTests['m√©triques'][$nom] = [
            'dur√©e_ms' => round($dur√©e * 1000, 2),
            'm√©moire_mb' => round(memory_get_usage(true) / 1024 / 1024, 2)
        ];

        if ($r√©sultat) {
            $r√©sultatsTests['tests_pass√©s']++;
            afficherVerbeux("  ‚úÖ {$nom} r√©ussi ({$r√©sultatsTests['m√©triques'][$nom]['dur√©e_ms']}ms)", 'SUCCESS');
            return true;
        } else {
            $r√©sultatsTests['tests_√©chou√©s']++;
            $r√©sultatsTests['erreurs'][] = "Test {$nom} a √©chou√© sans exception";
            afficherVerbeux("  ‚ùå {$nom} √©chou√©", 'ERROR');
            return false;
        }

    } catch (Exception $e) {
        $dur√©e = microtime(true) - $d√©but;
        $r√©sultatsTests['tests_√©chou√©s']++;
        $r√©sultatsTests['erreurs'][] = "Test {$nom} : " . $e->getMessage();
        $r√©sultatsTests['m√©triques'][$nom] = [
            'dur√©e_ms' => round($dur√©e * 1000, 2),
            'erreur' => $e->getMessage()
        ];

        afficherVerbeux("  ‚ùå {$nom} √©chou√© : " . $e->getMessage(), 'ERROR');
        return false;
    }
}

/**
 * Test 1: Initialisation du syst√®me de logs
 *
 * @return bool Succ√®s du test
 */
function testInitialisationLogs(): bool
{
    // Tenter d'obtenir l'instance du syst√®me de logs
    $systemeLog = LogManager::getInstance();

    if (!$systemeLog instanceof SystemeLogsGeekDragon) {
        throw new Exception('Instance du syst√®me de logs invalide');
    }

    // V√©rifier que les fonctions globales sont disponibles
    if (!function_exists('log_gd') || !function_exists('log_info')) {
        throw new Exception('Fonctions globales de logging non disponibles');
    }

    return true;
}

/**
 * Test 2: √âcriture et lecture des logs
 *
 * @return bool Succ√®s du test
 */
function testEcritureLecture(): bool
{
    $messageTest = 'Test du syst√®me de logs - ' . uniqid();

    // √âcrire un log de test
    log_info($messageTest, ['test' => true, 'timestamp' => time()]);

    // Attendre un peu pour que l'√©criture soit effectu√©e
    usleep(100000); // 100ms

    // V√©rifier que le fichier de log existe
    $fichierLog = __DIR__ . '/../logs/app.log';
    if (!file_exists($fichierLog)) {
        throw new Exception('Fichier de log non cr√©√©');
    }

    // Lire le contenu et v√©rifier la pr√©sence du message
    $contenu = file_get_contents($fichierLog);
    if (strpos($contenu, $messageTest) === false) {
        throw new Exception('Message de test non trouv√© dans les logs');
    }

    return true;
}

/**
 * Test 3: Niveaux de logs diff√©rents
 *
 * @return bool Succ√®s du test
 */
function testNiveauxLogs(): bool
{
    $systemeLog = log_gd();

    // Tester tous les niveaux
    $niveaux = ['debug', 'info', 'warn', 'error', 'critical'];

    foreach ($niveaux as $niveau) {
        $message = "Test niveau {$niveau} - " . uniqid();
        $systemeLog->$niveau($message, ['niveau_test' => $niveau]);
    }

    // V√©rifier que les fichiers appropri√©s existent
    $fichierApp = __DIR__ . '/../logs/app.log';
    $fichierErreurs = __DIR__ . '/../logs/erreurs.log';

    if (!file_exists($fichierApp)) {
        throw new Exception('Fichier app.log non cr√©√©');
    }

    // Le fichier d'erreurs doit exister car on a logu√© ERROR et CRITICAL
    if (!file_exists($fichierErreurs)) {
        throw new Exception('Fichier erreurs.log non cr√©√©');
    }

    return true;
}

/**
 * Test 4: M√©triques de performance
 *
 * @return bool Succ√®s du test
 */
function testMetriques(): bool
{
    $systemeLog = log_gd();

    // Enregistrer diff√©rents types de m√©triques
    $systemeLog->metrique('test_counter', 42, 'count', ['test' => 'metric']);
    $systemeLog->metrique('test_timer', 123.45, 'ms', ['test' => 'timer']);
    $systemeLog->metrique('test_gauge', 67.89, 'percent', ['test' => 'gauge']);

    // V√©rifier que le fichier de m√©triques existe
    $fichierMetriques = __DIR__ . '/../logs/metriques.log';
    if (!file_exists($fichierMetriques)) {
        throw new Exception('Fichier m√©triques.log non cr√©√©');
    }

    // V√©rifier le contenu
    $contenu = file_get_contents($fichierMetriques);
    if (strpos($contenu, 'test_counter') === false) {
        throw new Exception('M√©trique test_counter non trouv√©e');
    }

    return true;
}

/**
 * Test 5: Rotation des logs
 *
 * @return bool Succ√®s du test
 */
function testRotation(): bool
{
    $systemeLog = log_gd();

    // Obtenir le nombre de fichiers avant nettoyage
    $avantNettoyage = count(glob(__DIR__ . '/../logs/*.log*'));

    // Effectuer le nettoyage
    $fichiersSupprimes = $systemeLog->nettoyerAnciennesLogs();

    // Le nombre peut √™tre 0 si aucun fichier √† nettoyer, c'est normal
    if (!is_int($fichiersSupprimes) || $fichiersSupprimes < 0) {
        throw new Exception('R√©sultat de nettoyage invalide');
    }

    return true;
}

/**
 * Test 6: Statistiques syst√®me
 *
 * @return bool Succ√®s du test
 */
function testStatistiques(): bool
{
    $systemeLog = log_gd();
    $stats = $systemeLog->obtenirStatistiques();

    // V√©rifier la structure des statistiques
    $champsRequis = ['systeme', 'logs', 'metriques_cache'];

    foreach ($champsRequis as $champ) {
        if (!isset($stats[$champ])) {
            throw new Exception("Champ statistique manquant : {$champ}");
        }
    }

    // V√©rifier les sous-champs syst√®me
    $champsSysteme = ['php_version', 'memoire_utilisee_mb'];
    foreach ($champsSysteme as $champ) {
        if (!isset($stats['systeme'][$champ])) {
            throw new Exception("Champ syst√®me manquant : {$champ}");
        }
    }

    return true;
}

/**
 * Test 7: Export des logs
 *
 * @return bool Succ√®s du test
 */
function testExport(): bool
{
    global $config;

    if ($config['quick']) {
        // En mode rapide, on ne teste que le JSON
        $formats = ['json'];
    } else {
        $formats = ['json', 'csv', 'txt'];
    }

    $systemeLog = log_gd();

    foreach ($formats as $format) {
        $export = $systemeLog->exporterLogs($format);

        if (empty($export)) {
            throw new Exception("Export {$format} vide");
        }

        // Validation basique du format
        switch ($format) {
            case 'json':
                $decoded = json_decode($export, true);
                if (json_last_error() !== JSON_ERROR_NONE) {
                    throw new Exception("Export JSON invalide : " . json_last_error_msg());
                }
                break;

            case 'csv':
                if (strpos($export, 'Timestamp,Date,Niveau,Message') === false) {
                    throw new Exception("En-t√™tes CSV manquants");
                }
                break;

            case 'txt':
                if (strlen($export) < 10) {
                    throw new Exception("Export TXT trop court");
                }
                break;
        }
    }

    return true;
}

/**
 * Test 8: Gestion des exceptions
 *
 * @return bool Succ√®s du test
 */
function testGestionExceptions(): bool
{
    $systemeLog = log_gd();

    // Cr√©er une exception de test
    $exception = new RuntimeException('Exception de test pour monitoring', 12345);

    // L'enregistrer
    $systemeLog->exception($exception, ['test' => 'exception_handling']);

    // V√©rifier qu'elle appara√Æt dans les logs d'erreur
    $fichierErreurs = __DIR__ . '/../logs/erreurs.log';
    if (!file_exists($fichierErreurs)) {
        throw new Exception('Fichier erreurs.log non cr√©√© pour exception');
    }

    $contenu = file_get_contents($fichierErreurs);
    if (strpos($contenu, 'Exception de test pour monitoring') === false) {
        throw new Exception('Exception non trouv√©e dans erreurs.log');
    }

    return true;
}

/**
 * Test 9: API de synchronisation monitoring (simulation)
 *
 * @return bool Succ√®s du test
 */
function testAPISynchronisation(): bool
{
    // V√©rifier que le fichier API existe
    $fichierAPI = __DIR__ . '/../api/monitoring/sync.php';
    if (!file_exists($fichierAPI)) {
        throw new Exception('Fichier API de synchronisation manquant');
    }

    // V√©rifier que le r√©pertoire api/monitoring existe
    $repertoireAPI = dirname($fichierAPI);
    if (!is_dir($repertoireAPI)) {
        throw new Exception('R√©pertoire API monitoring manquant');
    }

    // Test basique de parsing du fichier
    $contenuAPI = file_get_contents($fichierAPI);
    if (strpos($contenuAPI, 'MonitoringSystemeGeekDragon') === false) {
        throw new Exception('Contenu API invalide ou corrompu');
    }

    return true;
}

/**
 * Test 10: Interface de visualisation
 *
 * @return bool Succ√®s du test
 */
function testInterfaceVisualisation(): bool
{
    // V√©rifier que le dashboard admin existe
    $dashboardFile = __DIR__ . '/../admin/monitoring-dashboard.php';
    if (!file_exists($dashboardFile)) {
        throw new Exception('Dashboard de monitoring manquant');
    }

    // V√©rifier le contenu basique
    $contenu = file_get_contents($dashboardFile);
    if (strpos($contenu, 'SystemeLogsGeekDragon') === false) {
        throw new Exception('Dashboard ne r√©f√©rence pas le syst√®me de logs');
    }

    return true;
}

/**
 * G√©n√®re un rapport de test d√©taill√©
 *
 * @return void
 */
function genererRapport(): void
{
    global $r√©sultatsTests, $config;

    $dur√©eTotale = microtime(true) - $r√©sultatsTests['d√©but'];
    $totalTests = $r√©sultatsTests['tests_pass√©s'] + $r√©sultatsTests['tests_√©chou√©s'];
    $tauxR√©ussite = $totalTests > 0 ? round(($r√©sultatsTests['tests_pass√©s'] / $totalTests) * 100, 1) : 0;

    $rapport = [
        'date_test' => date('Y-m-d H:i:s'),
        'dur√©e_totale_seconde' => round($dur√©eTotale, 3),
        'r√©sultats' => [
            'total_tests' => $totalTests,
            'tests_pass√©s' => $r√©sultatsTests['tests_pass√©s'],
            'tests_√©chou√©s' => $r√©sultatsTests['tests_√©chou√©s'],
            'taux_r√©ussite_percent' => $tauxR√©ussite
        ],
        'm√©triques_performance' => $r√©sultatsTests['m√©triques'],
        'erreurs' => $r√©sultatsTests['erreurs'],
        'environnement' => [
            'php_version' => PHP_VERSION,
            'm√©moire_pic_mb' => round(memory_get_peak_usage(true) / 1024 / 1024, 2),
            'syst√®me' => php_uname()
        ]
    ];

    echo "\nüìä RAPPORT DE TEST DU MONITORING\n";
    echo "================================\n\n";

    echo "üéØ R√©sultats Globaux :\n";
    echo "   Tests ex√©cut√©s : {$totalTests}\n";
    echo "   Tests r√©ussis : {$r√©sultatsTests['tests_pass√©s']}\n";
    echo "   Tests √©chou√©s : {$r√©sultatsTests['tests_√©chou√©s']}\n";
    echo "   Taux de r√©ussite : {$tauxR√©ussite}%\n";
    echo "   Dur√©e totale : " . round($dur√©eTotale, 2) . " secondes\n\n";

    if (!empty($r√©sultatsTests['erreurs'])) {
        echo "‚ùå Erreurs Rencontr√©es :\n";
        foreach ($r√©sultatsTests['erreurs'] as $erreur) {
            echo "   ‚Ä¢ {$erreur}\n";
        }
        echo "\n";
    }

    if ($config['verbeux']) {
        echo "‚ö° M√©triques de Performance :\n";
        foreach ($r√©sultatsTests['m√©triques'] as $test => $m√©trique) {
            echo "   {$test} : {$m√©trique['dur√©e_ms']}ms";
            if (isset($m√©trique['m√©moire_mb'])) {
                echo " | {$m√©trique['m√©moire_mb']}MB";
            }
            echo "\n";
        }
        echo "\n";
    }

    echo "üñ•Ô∏è Environnement :\n";
    echo "   PHP : " . $rapport['environnement']['php_version'] . "\n";
    echo "   M√©moire pic : {$rapport['environnement']['m√©moire_pic_mb']} MB\n\n";

    // Sauvegarder le rapport si demand√©
    if ($config['rapport']) {
        $nomRapport = $config['repertoire_logs'] . '/test_monitoring_' . date('Y-m-d_H-i-s') . '.json';
        file_put_contents($nomRapport, json_encode($rapport, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE));
        echo "üíæ Rapport d√©taill√© sauvegard√© : " . basename($nomRapport) . "\n";
    }

    // Log du r√©sultat des tests
    log_info('Tests du syst√®me de monitoring termin√©s', [
        'tests_pass√©s' => $r√©sultatsTests['tests_pass√©s'],
        'tests_√©chou√©s' => $r√©sultatsTests['tests_√©chou√©s'],
        'taux_r√©ussite_percent' => $tauxR√©ussite,
        'dur√©e_totale_seconde' => round($dur√©eTotale, 3)
    ]);
}

// === EX√âCUTION PRINCIPALE ===

try {
    echo "üß™ Test du Syst√®me de Monitoring - Geek & Dragon\n";
    echo "===============================================\n\n";

    if ($config['quick']) {
        afficherVerbeux("Mode rapide activ√© - tests essentiels uniquement", 'INFO');
    }

    // Liste des tests √† ex√©cuter
    $tests = [
        'Initialisation du syst√®me de logs' => 'testInitialisationLogs',
        '√âcriture et lecture des logs' => 'testEcritureLecture',
        'Niveaux de logs diff√©rents' => 'testNiveauxLogs',
        'M√©triques de performance' => 'testMetriques',
        'Rotation des logs' => 'testRotation',
        'Statistiques syst√®me' => 'testStatistiques',
        'Export des logs' => 'testExport',
        'Gestion des exceptions' => 'testGestionExceptions',
        'API de synchronisation' => 'testAPISynchronisation',
        'Interface de visualisation' => 'testInterfaceVisualisation'
    ];

    // En mode quick, ne faire que les tests essentiels
    if ($config['quick']) {
        $tests = array_slice($tests, 0, 6, true);
    }

    // Ex√©cuter tous les tests
    foreach ($tests as $nom => $fonction) {
        ex√©cuterTest($nom, $fonction);
    }

    // G√©n√©rer le rapport final
    genererRapport();

    // Code de sortie bas√© sur les r√©sultats
    $codeRetour = $r√©sultatsTests['tests_√©chou√©s'] > 0 ? 1 : 0;

    if ($codeRetour === 0) {
        echo "üéâ Tous les tests sont pass√©s avec succ√®s !\n";
        echo "Le syst√®me de monitoring est op√©rationnel.\n";
    } else {
        echo "‚ö†Ô∏è Certains tests ont √©chou√©.\n";
        echo "Veuillez v√©rifier la configuration et les erreurs ci-dessus.\n";
    }

    exit($codeRetour);

} catch (Exception $e) {
    echo "üí• Erreur fatale lors des tests : " . $e->getMessage() . "\n";
    log_error('Erreur fatale tests monitoring', [
        'erreur' => $e->getMessage(),
        'trace' => $e->getTraceAsString()
    ]);
    exit(1);
}