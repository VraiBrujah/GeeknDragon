#!/usr/bin/env node
/*
  Télécharge les polices woff2 (Open Sans 400/600, Cinzel 400/600/700)
  depuis Google Fonts et génère css/fonts-selfhosted.css avec @font-face.
*/
const https = require('https');
const fs = require('fs');
const path = require('path');

const FONTS_CSS_URL = 'https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&family=Cinzel:wght@400;600;700&display=swap';
const UA = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122 Safari/537.36';

function fetch(url, headers = {}) {
  return new Promise((resolve, reject) => {
    https.get(url, { headers }, (res) => {
      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
        // Follow redirect
        return resolve(fetch(res.headers.location, headers));
      }
      if (res.statusCode !== 200) {
        return reject(new Error(`HTTP ${res.statusCode} for ${url}`));
      }
      const chunks = [];
      res.on('data', (c) => chunks.push(c));
      res.on('end', () => resolve(Buffer.concat(chunks)));
    }).on('error', reject);
  });
}

async function main() {
  const cssBuf = await fetch(FONTS_CSS_URL, {
    'User-Agent': UA,
    'Accept': 'text/css,*/*;q=0.1'
  });
  const css = cssBuf.toString('utf8');

  // Extraire les blocs @font-face
  const blocks = css.split('@font-face').slice(1).map(b => '@font-face' + b);

  // Filtrer Open Sans (400, 600) et Cinzel (400, 600, 700) en latin (unicode-range U+0000-00FF)
  const wanted = {
    'Open Sans': new Set([400, 600]),
    'Cinzel': new Set([400, 600, 700])
  };
  const picked = [];

  for (const block of blocks) {
    const famMatch = block.match(/font-family:\s*'([^']+)'/);
    const weightMatch = block.match(/font-weight:\s*(\d+)/);
    const urMatch = block.match(/unicode-range:\s*([^;]+);/);
    const srcMatch = block.match(/src:\s*url\((https:[^\)]+\.woff2)\)/);
    if (!famMatch || !weightMatch || !urMatch || !srcMatch) continue;
    const fam = famMatch[1];
    const weight = parseInt(weightMatch[1], 10);
    const ur = urMatch[1];
    const url = srcMatch[1];
    if (!wanted[fam] || !wanted[fam].has(weight)) continue;
    if (!/U\+0000-00FF/.test(ur)) continue; // latin subset
    picked.push({ fam, weight, url });
    // Si déjà tous pris pour fam, on pourrait arrêter
  }

  if (picked.length < 5) {
    console.warn('Avertissement: moins de variantes détectées que prévu:', picked);
  }

  // Assurer répertoires
  const fontsDir = path.join(process.cwd(), 'media', 'fonts');
  const cssDir = path.join(process.cwd(), 'css');
  if (!fs.existsSync(fontsDir)) fs.mkdirSync(fontsDir, { recursive: true });
  if (!fs.existsSync(cssDir)) fs.mkdirSync(cssDir, { recursive: true });

  // Télécharger chaque woff2
  const files = [];
  for (const { fam, weight, url } of picked) {
    const baseName = `${fam.replace(/\s+/g, '')}-${weight}.woff2`;
    const outPath = path.join(fontsDir, baseName);
    const buf = await fetch(url, { 'User-Agent': UA });
    fs.writeFileSync(outPath, buf);
    files.push({ fam, weight, file: `/media/fonts/${baseName}` });
    console.log(`Saved ${fam} ${weight} -> ${outPath}`);
  }

  // Générer CSS @font-face
  let outCss = '/* Self-hosted webfonts generated by scripts/fetch-fonts.cjs */\n';
  const families = ['Open Sans', 'Cinzel'];
  for (const fam of families) {
    const subset = files.filter(f => f.fam === fam).sort((a,b)=>a.weight-b.weight);
    for (const f of subset) {
      outCss += `@font-face {\n`;
      outCss += `  font-family: '${fam}';\n`;
      outCss += `  font-style: normal;\n`;
      outCss += `  font-weight: ${f.weight};\n`;
      outCss += `  font-display: swap;\n`;
      outCss += `  src: url('${f.file}') format('woff2');\n`;
      outCss += `}\n`;
    }
  }
  fs.writeFileSync(path.join(cssDir, 'fonts-selfhosted.css'), outCss, 'utf8');
  console.log('Generated css/fonts-selfhosted.css');
}

main().catch((e) => { console.error(e); process.exit(1); });

