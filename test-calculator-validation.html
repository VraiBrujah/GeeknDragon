<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tests Calculateur Dynamique</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
        .test-case { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .test-case.SIMPLE { border-left: 4px solid #4CAF50; }
        .test-case.MOYEN { border-left: 4px solid #FF9800; }
        .test-case.COMPLEXE { border-left: 4px solid #F44336; }
        .test-case.EDGE { border-left: 4px solid #9C27B0; }
        .test-case.CACHE { border-left: 4px solid #00BCD4; }
        .needs { background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 3px; }
        .result { background: #e8f5e8; padding: 10px; margin: 10px 0; border-radius: 3px; }
        .error { background: #ffe8e8; padding: 10px; margin: 10px 0; border-radius: 3px; color: #d32f2f; }
        .expected { background: #e3f2fd; padding: 10px; margin: 10px 0; border-radius: 3px; }
        .summary { background: #333; color: white; padding: 15px; margin: 20px 0; border-radius: 5px; }
        .success { color: #4CAF50; font-weight: bold; }
        .failure { color: #F44336; font-weight: bold; }
        .loading { color: #FF9800; font-weight: bold; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 3px; cursor: pointer; margin: 5px; }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .stats { display: flex; justify-content: space-around; margin: 20px 0; }
        .stat { text-align: center; padding: 10px; }
        .recommendations { margin: 10px 0; }
        .recommendation { background: #fff3cd; padding: 8px; margin: 5px 0; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ Tests Exhaustifs - Calculateur Dynamique</h1>
        
        <div class="summary" id="globalStatus">
            <div class="loading">‚è≥ Initialisation du calculateur...</div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <h3>Tests R√©ussis</h3>
                <div id="successCount" class="success">0</div>
            </div>
            <div class="stat">
                <h3>Tests √âchou√©s</h3>
                <div id="failureCount" class="failure">0</div>
            </div>
            <div class="stat">
                <h3>Score Global</h3>
                <div id="globalScore">0%</div>
            </div>
        </div>
        
        <button onclick="runAllTests()" id="runButton" disabled>üöÄ Lancer Tous les Tests</button>
        <button onclick="runIndividualTests()" id="individualButton" disabled>üîç Tests Individuels</button>
        <button onclick="runCacheTests()" id="cacheButton" disabled>üíæ Tests Cache Dynamique</button>
        <button onclick="clearResults()">üóëÔ∏è Effacer R√©sultats</button>
        
        <div id="testResults"></div>
    </div>

    <!-- Inclusion du calculateur dynamique -->
    <script src="/js/dynamic-coin-recommender.js"></script>
    
    <script>
        // === DONN√âES DE TEST ===
        const testCases = [
    {
        "name": "CAS SIMPLE 1: 1 pi\u00e8ce de cuivre",
        "needs": {
            "copper": 1,
            "silver": 0,
            "electrum": 0,
            "gold": 0,
            "platinum": 0
        },
        "expected_strategy": "Pi\u00e8ce personnalis\u00e9e (la moins ch\u00e8re pour 1 unit\u00e9)",
        "complexity": "SIMPLE"
    },
    {
        "name": "CAS SIMPLE 2: 5 pi\u00e8ces d'or",
        "needs": {
            "copper": 0,
            "silver": 0,
            "electrum": 0,
            "gold": 5,
            "platinum": 0
        },
        "expected_strategy": "Lot offrant au moins 5 pi\u00e8ces d'or au meilleur prix\/pi\u00e8ce",
        "complexity": "SIMPLE"
    },
    {
        "name": "CAS SIMPLE 3: 2 de chaque m\u00e9tal basique",
        "needs": {
            "copper": 2,
            "silver": 2,
            "electrum": 2,
            "gold": 2,
            "platinum": 2
        },
        "expected_strategy": "Offrande du Voyageur (exactement 2 de chaque)",
        "complexity": "SIMPLE"
    },
    {
        "name": "CAS MOYEN 1: Besoin asym\u00e9trique",
        "needs": {
            "copper": 10,
            "silver": 3,
            "electrum": 1,
            "gold": 1,
            "platinum": 0
        },
        "expected_strategy": "Combinaison optimale multi-lots",
        "complexity": "MOYEN"
    },
    {
        "name": "CAS MOYEN 2: Gros besoin d'un seul m\u00e9tal",
        "needs": {
            "copper": 20,
            "silver": 0,
            "electrum": 0,
            "gold": 0,
            "platinum": 0
        },
        "expected_strategy": "Gros lot avec surplus acceptable ou multiple pi\u00e8ces personnalis\u00e9es",
        "complexity": "MOYEN"
    },
    {
        "name": "CAS COMPLEXE 1: Tous m\u00e9taux en quantit\u00e9s diff\u00e9rentes",
        "needs": {
            "copper": 15,
            "silver": 8,
            "electrum": 4,
            "gold": 12,
            "platinum": 3
        },
        "expected_strategy": "Combinaison optimale de plusieurs lots",
        "complexity": "COMPLEXE"
    },
    {
        "name": "CAS COMPLEXE 2: Tr\u00e8s gros besoins",
        "needs": {
            "copper": 50,
            "silver": 30,
            "electrum": 20,
            "gold": 25,
            "platinum": 15
        },
        "expected_strategy": "Lots volumineux avec optimisation prix total",
        "complexity": "COMPLEXE"
    },
    {
        "name": "CAS EDGE 1: Besoins minimaux partout",
        "needs": {
            "copper": 1,
            "silver": 1,
            "electrum": 1,
            "gold": 1,
            "platinum": 1
        },
        "expected_strategy": "Lot 5 m\u00e9taux ou pi\u00e8ces personnalis\u00e9es",
        "complexity": "EDGE"
    },
    {
        "name": "CAS EDGE 2: Un seul m\u00e9tal rare en grande quantit\u00e9",
        "needs": {
            "copper": 0,
            "silver": 0,
            "electrum": 0,
            "gold": 0,
            "platinum": 25
        },
        "expected_strategy": "Lots avec platine ou multiples pi\u00e8ces personnalis\u00e9es",
        "complexity": "EDGE"
    }
];

        // === TESTS SP√âCIFIQUES CACHE ===
        const cacheTestCases = [
            {
                "name": "CACHE 1: Calcul avec cache vide",
                "needs": {
                    "copper": 7,
                    "silver": 3,
                    "electrum": 2,
                    "gold": 4,
                    "platinum": 1
                },
                "expected_strategy": "Premier calcul, mise en cache automatique",
                "complexity": "CACHE",
                "testCache": true
            },
            {
                "name": "CACHE 2: M√™me calcul (doit utiliser cache)",
                "needs": {
                    "copper": 7,
                    "silver": 3,
                    "electrum": 2,
                    "gold": 4,
                    "platinum": 1
                },
                "expected_strategy": "R√©sultat depuis cache (temps < 1ms)",
                "complexity": "CACHE",
                "testCache": true
            },
            {
                "name": "CACHE 3: Nouveau calcul complexe",
                "needs": {
                    "copper": 13,
                    "silver": 7,
                    "electrum": 5,
                    "gold": 9,
                    "platinum": 4
                },
                "expected_strategy": "Calcul dynamique + mise en cache",
                "complexity": "CACHE",
                "testCache": true
            },
            {
                "name": "CACHE 4: R√©p√©tition calcul pr√©c√©dent",
                "needs": {
                    "copper": 13,
                    "silver": 7,
                    "electrum": 5,
                    "gold": 9,
                    "platinum": 4
                },
                "expected_strategy": "R√©sultat depuis cache (temps < 1ms)",
                "complexity": "CACHE",
                "testCache": true
            },
            {
                "name": "CACHE 5: Combinaison unique non-cach√©e",
                "needs": {
                    "copper": 17,
                    "silver": 11,
                    "electrum": 6,
                    "gold": 14,
                    "platinum": 8
                },
                "expected_strategy": "Calcul dynamique en temps r√©el",
                "complexity": "CACHE",
                "testCache": true
            }
        ];

        // === VARIABLES GLOBALES ===
        let calculator = null;
        let testResults = [];
        let globalStatusEl = document.getElementById('globalStatus');
        let runButton = document.getElementById('runButton');
        let individualButton = document.getElementById('individualButton');
        let cacheButton = document.getElementById('cacheButton');
        let cacheTestResults = [];

        // === INITIALISATION ===
        async function initializeCalculator() {
            try {
                // Attendre que le calculateur soit charg√©
                let attempts = 0;
                const maxAttempts = 20;
                
                while (!window.dynamicRecommender && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    attempts++;
                }
                
                if (!window.dynamicRecommender) {
                    throw new Error('Calculateur non charg√© apr√®s 4 secondes');
                }
                
                calculator = window.dynamicRecommender;
                
                // Attendre que les produits soient charg√©s
                attempts = 0;
                while (!calculator.products && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    attempts++;
                }
                
                if (!calculator.products) {
                    throw new Error('Produits non charg√©s apr√®s 4 secondes');
                }
                
                globalStatusEl.innerHTML = '<div class="success">‚úÖ Calculateur initialis√© avec ' + Object.keys(calculator.products).length + ' produits</div>';
                runButton.disabled = false;
                individualButton.disabled = false;
                cacheButton.disabled = false;
                
                console.log('Calculateur pr√™t:', calculator);
                console.log('Produits charg√©s:', Object.keys(calculator.products));
                
            } catch (error) {
                console.error('Erreur initialisation:', error);
                globalStatusEl.innerHTML = '<div class="error">‚ùå Erreur: ' + error.message + '</div>';
            }
        }

        // === FONCTIONS DE TEST ===
        function runAllTests() {
            clearResults();
            testResults = [];
            
            globalStatusEl.innerHTML = '<div class="loading">‚è≥ Ex√©cution de ' + testCases.length + ' tests...</div>';
            
            testCases.forEach((testCase, index) => {
                setTimeout(() => runSingleTest(testCase, index), index * 100);
            });
            
            // G√©n√©rer le rapport final apr√®s tous les tests
            setTimeout(() => generateFinalReport(), testCases.length * 100 + 500);
        }
        
        function runIndividualTests() {
            clearResults();
            const resultsDiv = document.getElementById('testResults');
            
            testCases.forEach((testCase, index) => {
                const testDiv = createTestCaseDiv(testCase, index);
                testDiv.innerHTML += '<button onclick="runSingleTest(testCases[' + index + '], ' + index + ', true)">‚ñ∂Ô∏è Ex√©cuter</button>';
                resultsDiv.appendChild(testDiv);
            });
        }

        function runSingleTest(testCase, index, individual = false) {
            try {
                const startTime = performance.now();
                
                // Ex√©cution du test
                const result = calculator.recommend(
                    testCase.needs.copper,
                    testCase.needs.silver,
                    testCase.needs.electrum,
                    testCase.needs.gold,
                    testCase.needs.platinum
                );
                
                const executionTime = performance.now() - startTime;
                
                // Analyse du r√©sultat
                const analysis = analyzeRecommendation(testCase, result, executionTime);
                testResults[index] = analysis;
                
                if (individual) {
                    displayTestResult(testCase, analysis, index);
                } else {
                    updateTestInPlace(testCase, analysis, index);
                }
                
            } catch (error) {
                console.error('Erreur test ' + index + ':', error);
                const analysis = {
                    success: false,
                    error: error.message,
                    recommendation: null,
                    totalCost: null,
                    executionTime: 0
                };
                testResults[index] = analysis;
                
                if (individual) {
                    displayTestResult(testCase, analysis, index);
                } else {
                    updateTestInPlace(testCase, analysis, index);
                }
            }
        }

        function analyzeRecommendation(testCase, recommendation, executionTime) {
            const analysis = {
                success: false,
                recommendation: recommendation,
                totalCost: 0,
                executionTime: Math.round(executionTime * 100) / 100,
                coverage: {},
                efficiency: 0,
                details: []
            };
            
            if (!recommendation || recommendation.length === 0) {
                analysis.error = 'Aucune recommandation retourn√©e';
                return analysis;
            }
            
            // Calcul du co√ªt total
            analysis.totalCost = recommendation.reduce((sum, item) => {
                return sum + (item.price * item.quantity);
            }, 0);
            
            // V√©rification de la couverture des besoins
            const provided = { copper: 0, silver: 0, electrum: 0, gold: 0, platinum: 0 };
            
            recommendation.forEach(item => {
                const product = calculator.products[item.productId];
                if (product && product.coinLots) {
                    Object.keys(product.coinLots).forEach(metal => {
                        const lots = product.coinLots[metal];
                        if (typeof lots === 'object' && lots !== null) {
                            // Lots complexes avec multiplicateurs
                            Object.values(lots).forEach(count => {
                                provided[metal] += count * item.quantity;
                            });
                        } else if (typeof lots === 'number') {
                            // Lots simples
                            provided[metal] += lots * item.quantity;
                        }
                    });
                }
                
                analysis.details.push({
                    product: product ? product.name : item.productId,
                    quantity: item.quantity,
                    unitPrice: item.price,
                    totalPrice: item.price * item.quantity
                });
            });
            
            // V√©rification que tous les besoins sont couverts
            analysis.coverage = provided;
            const allNeedsMet = Object.keys(testCase.needs).every(metal => {
                return provided[metal] >= testCase.needs[metal];
            });
            
            if (allNeedsMet) {
                analysis.success = true;
                
                // Calcul de l'efficacit√© (besoins couverts / total fourni)
                const totalNeeded = Object.values(testCase.needs).reduce((a, b) => a + b, 0);
                const totalProvided = Object.values(provided).reduce((a, b) => a + b, 0);
                analysis.efficiency = totalNeeded > 0 ? Math.round((totalNeeded / totalProvided) * 100) : 0;
            } else {
                analysis.error = 'Besoins non couverts';
                analysis.success = false;
            }
            
            return analysis;
        }

        function createTestCaseDiv(testCase, index) {
            const div = document.createElement('div');
            div.className = 'test-case ' + testCase.complexity;
            div.id = 'test-' + index;
            
            div.innerHTML = `
                <h3>${testCase.name}</h3>
                <div class="needs">
                    <strong>Besoins:</strong> 
                    ü•â${testCase.needs.copper} cuivre, 
                    ü•à${testCase.needs.silver} argent, 
                    ‚ö°${testCase.needs.electrum} √©lectrum, 
                    ü•á${testCase.needs.gold} or, 
                    üíé${testCase.needs.platinum} platine
                </div>
                <div class="expected">
                    <strong>Strat√©gie attendue:</strong> ${testCase.expected_strategy}
                </div>
                <div class="result" id="result-${index}">
                    <div class="loading">‚è≥ En attente...</div>
                </div>
            `;
            
            return div;
        }

        function updateTestInPlace(testCase, analysis, index) {
            const existingDiv = document.getElementById('test-' + index);
            if (!existingDiv) {
                const resultsDiv = document.getElementById('testResults');
                const testDiv = createTestCaseDiv(testCase, index);
                resultsDiv.appendChild(testDiv);
            }
            
            displayTestResult(testCase, analysis, index);
        }

        function displayTestResult(testCase, analysis, index) {
            const resultDiv = document.getElementById('result-' + index);
            if (!resultDiv) return;
            
            if (analysis.success) {
                resultDiv.innerHTML = `
                    <div class="success">‚úÖ TEST R√âUSSI</div>
                    <div><strong>Co√ªt total:</strong> ${analysis.totalCost.toFixed(2)}‚Ç¨</div>
                    <div><strong>Temps d'ex√©cution:</strong> ${analysis.executionTime}ms</div>
                    <div><strong>Efficacit√©:</strong> ${analysis.efficiency}% (${analysis.efficiency >= 80 ? 'üü¢' : analysis.efficiency >= 60 ? 'üü°' : 'üî¥'})</div>
                    <div class="recommendations">
                        <strong>Recommandation:</strong>
                        ${analysis.details.map(item => 
                            `<div class="recommendation">${item.quantity}x ${item.product} (${item.unitPrice}‚Ç¨/pi√®ce = ${item.totalPrice.toFixed(2)}‚Ç¨)</div>`
                        ).join('')}
                    </div>
                    <div><strong>Couverture:</strong> 
                        ü•â${analysis.coverage.copper} cuivre, 
                        ü•à${analysis.coverage.silver} argent, 
                        ‚ö°${analysis.coverage.electrum} √©lectrum, 
                        ü•á${analysis.coverage.gold} or, 
                        üíé${analysis.coverage.platinum} platine
                    </div>
                `;
            } else {
                resultDiv.innerHTML = `
                    <div class="failure">‚ùå TEST √âCHOU√â</div>
                    <div class="error"><strong>Erreur:</strong> ${analysis.error || 'Erreur inconnue'}</div>
                    ${analysis.recommendation ? `<div><strong>Recommandation retourn√©e:</strong> ${JSON.stringify(analysis.recommendation)}</div>` : ''}
                    ${analysis.coverage ? `<div><strong>Couverture obtenue:</strong> ${JSON.stringify(analysis.coverage)}</div>` : ''}
                `;
            }
        }

        function generateFinalReport() {
            const successful = testResults.filter(r => r && r.success).length;
            const total = testResults.filter(r => r).length;
            const percentage = total > 0 ? Math.round((successful / total) * 100) : 0;
            
            document.getElementById('successCount').textContent = successful;
            document.getElementById('failureCount').textContent = total - successful;
            document.getElementById('globalScore').textContent = percentage + '%';
            document.getElementById('globalScore').className = percentage >= 90 ? 'success' : percentage >= 70 ? 'loading' : 'failure';
            
            // Calculs statistiques
            const validResults = testResults.filter(r => r && r.success);
            const avgCost = validResults.length > 0 ? validResults.reduce((sum, r) => sum + r.totalCost, 0) / validResults.length : 0;
            const avgTime = validResults.length > 0 ? validResults.reduce((sum, r) => sum + r.executionTime, 0) / validResults.length : 0;
            const avgEfficiency = validResults.length > 0 ? validResults.reduce((sum, r) => sum + r.efficiency, 0) / validResults.length : 0;
            
            globalStatusEl.innerHTML = `
                <div class="${percentage >= 90 ? 'success' : percentage >= 70 ? 'loading' : 'failure'}">
                    ${percentage >= 90 ? 'üéâ' : percentage >= 70 ? '‚ö†Ô∏è' : '‚ùå'} 
                    RAPPORT FINAL: ${successful}/${total} tests r√©ussis (${percentage}%)
                </div>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    üìä <strong>Statistiques:</strong><br>
                    ‚Ä¢ Co√ªt moyen: ${avgCost.toFixed(2)}‚Ç¨<br>
                    ‚Ä¢ Temps moyen: ${avgTime.toFixed(2)}ms<br>
                    ‚Ä¢ Efficacit√© moyenne: ${avgEfficiency.toFixed(1)}%
                </div>
            `;
            
            // Recommandations d'am√©lioration
            if (percentage < 90) {
                const failures = testResults.filter(r => r && !r.success);
                const failureReasons = failures.map(f => f.error).filter((v, i, a) => a.indexOf(v) === i);
                
                globalStatusEl.innerHTML += `
                    <div style="margin-top: 10px; color: #ffeb3b;">
                        <strong>‚ö†Ô∏è Am√©liorations sugg√©r√©es:</strong><br>
                        ${failureReasons.map(reason => `‚Ä¢ ${reason}`).join('<br>')}
                    </div>
                `;
            }
        }

        function runCacheTests() {
            clearResults();
            cacheTestResults = [];
            
            globalStatusEl.innerHTML = '<div class="loading">‚è≥ Tests cache en cours...</div>';
            
            // Vider le cache avant les tests
            if (calculator && calculator.cache) {
                calculator.cache.clear();
                console.log('Cache vid√© pour les tests');
            }
            
            cacheTestCases.forEach((testCase, index) => {
                setTimeout(() => runCacheTest(testCase, index), index * 200);
            });
            
            // G√©n√©rer le rapport cache apr√®s tous les tests
            setTimeout(() => generateCacheReport(), cacheTestCases.length * 200 + 500);
        }
        
        function runCacheTest(testCase, index) {
            try {
                const startTime = performance.now();
                const cacheKey = JSON.stringify(testCase.needs);
                const wasCached = calculator.cache && calculator.cache.has(cacheKey);
                
                // Ex√©cution du test
                const result = calculator.recommend(
                    testCase.needs.copper,
                    testCase.needs.silver,
                    testCase.needs.electrum,
                    testCase.needs.gold,
                    testCase.needs.platinum
                );
                
                const executionTime = performance.now() - startTime;
                const isNowCached = calculator.cache && calculator.cache.has(cacheKey);
                
                // Analyse sp√©cifique cache
                const analysis = analyzeCacheTest(testCase, result, executionTime, wasCached, isNowCached);
                cacheTestResults[index] = analysis;
                
                updateCacheTestInPlace(testCase, analysis, index);
                
            } catch (error) {
                console.error('Erreur test cache ' + index + ':', error);
                const analysis = {
                    success: false,
                    error: error.message,
                    wasCached: false,
                    isNowCached: false,
                    executionTime: 0
                };
                cacheTestResults[index] = analysis;
                updateCacheTestInPlace(testCase, analysis, index);
            }
        }
        
        function analyzeCacheTest(testCase, recommendation, executionTime, wasCached, isNowCached) {
            const analysis = {
                success: false,
                recommendation: recommendation,
                executionTime: Math.round(executionTime * 100) / 100,
                wasCached: wasCached,
                isNowCached: isNowCached,
                cacheWorking: false,
                details: []
            };
            
            // V√©rifier que la recommandation existe
            if (!recommendation || recommendation.length === 0) {
                analysis.error = 'Aucune recommandation retourn√©e';
                return analysis;
            }
            
            // Tests sp√©cifiques selon le cas
            if (testCase.name.includes('M√™me calcul')) {
                // Ce test v√©rifie que le cache fonctionne
                analysis.cacheWorking = wasCached && executionTime < 1;
                analysis.success = analysis.cacheWorking;
                if (!analysis.success) {
                    analysis.error = wasCached ? 'Cache utilis√© mais temps trop √©lev√©' : 'Cache non utilis√©';
                }
            } else if (testCase.name.includes('R√©p√©tition')) {
                // M√™me chose pour les r√©p√©titions
                analysis.cacheWorking = wasCached && executionTime < 1;
                analysis.success = analysis.cacheWorking;
                if (!analysis.success) {
                    analysis.error = wasCached ? 'Cache utilis√© mais temps trop √©lev√©' : 'Cache non utilis√©';
                }
            } else {
                // Tests de calcul dynamique (nouveaux calculs)
                analysis.cacheWorking = !wasCached && isNowCached;
                analysis.success = analysis.cacheWorking && recommendation.length > 0;
                if (!analysis.success) {
                    analysis.error = !wasCached ? 
                        (!isNowCached ? 'R√©sultat non mis en cache' : 'Calcul √©chou√©') : 
                        '√âtait d√©j√† en cache (test invalide)';
                }
            }
            
            // Ajouter les d√©tails de la recommandation
            recommendation.forEach(item => {
                const product = calculator.products[item.productId];
                analysis.details.push({
                    product: product ? product.name : item.productId,
                    quantity: item.quantity,
                    price: item.price
                });
            });
            
            return analysis;
        }
        
        function updateCacheTestInPlace(testCase, analysis, index) {
            const resultsDiv = document.getElementById('testResults');
            let testDiv = document.getElementById('cache-test-' + index);
            
            if (!testDiv) {
                testDiv = document.createElement('div');
                testDiv.className = 'test-case ' + testCase.complexity;
                testDiv.id = 'cache-test-' + index;
                
                testDiv.innerHTML = `
                    <h3>${testCase.name}</h3>
                    <div class="needs">
                        <strong>Besoins:</strong> 
                        ü•â${testCase.needs.copper} cuivre, 
                        ü•à${testCase.needs.silver} argent, 
                        ‚ö°${testCase.needs.electrum} √©lectrum, 
                        ü•á${testCase.needs.gold} or, 
                        üíé${testCase.needs.platinum} platine
                    </div>
                    <div class="expected">
                        <strong>Test cache:</strong> ${testCase.expected_strategy}
                    </div>
                    <div class="result" id="cache-result-${index}">
                        <div class="loading">‚è≥ Test en cours...</div>
                    </div>
                `;
                
                resultsDiv.appendChild(testDiv);
            }
            
            displayCacheTestResult(analysis, index);
        }
        
        function displayCacheTestResult(analysis, index) {
            const resultDiv = document.getElementById('cache-result-' + index);
            if (!resultDiv) return;
            
            if (analysis.success) {
                resultDiv.innerHTML = `
                    <div class="success">‚úÖ TEST CACHE R√âUSSI</div>
                    <div><strong>Temps d'ex√©cution:</strong> ${analysis.executionTime}ms</div>
                    <div><strong>√âtat cache avant:</strong> ${analysis.wasCached ? 'üíæ En cache' : 'üÜï Nouveau'}</div>
                    <div><strong>√âtat cache apr√®s:</strong> ${analysis.isNowCached ? 'üíæ Mis en cache' : '‚ùå Non cach√©'}</div>
                    <div><strong>Fonctionnement cache:</strong> ${analysis.cacheWorking ? '‚úÖ Correct' : '‚ùå Probl√®me'}</div>
                    <div class="recommendations">
                        <strong>Recommandation:</strong>
                        ${analysis.details.map(item => 
                            `<div class="recommendation">${item.quantity}x ${item.product} (${item.price}‚Ç¨)</div>`
                        ).join('')}
                    </div>
                `;
            } else {
                resultDiv.innerHTML = `
                    <div class="failure">‚ùå TEST CACHE √âCHOU√â</div>
                    <div class="error"><strong>Erreur:</strong> ${analysis.error || 'Erreur inconnue'}</div>
                    <div><strong>Temps d'ex√©cution:</strong> ${analysis.executionTime}ms</div>
                    <div><strong>√âtat cache avant:</strong> ${analysis.wasCached ? 'üíæ En cache' : 'üÜï Nouveau'}</div>
                    <div><strong>√âtat cache apr√®s:</strong> ${analysis.isNowCached ? 'üíæ Mis en cache' : '‚ùå Non cach√©'}</div>
                `;
            }
        }
        
        function generateCacheReport() {
            const successful = cacheTestResults.filter(r => r && r.success).length;
            const total = cacheTestResults.filter(r => r).length;
            const percentage = total > 0 ? Math.round((successful / total) * 100) : 0;
            
            // Calculs statistiques sp√©cifiques cache
            const validResults = cacheTestResults.filter(r => r && r.success);
            const cacheHits = cacheTestResults.filter(r => r && r.wasCached).length;
            const cacheMisses = cacheTestResults.filter(r => r && !r.wasCached).length;
            const avgTimeCache = validResults.filter(r => r.wasCached).length > 0 ? 
                validResults.filter(r => r.wasCached).reduce((sum, r) => sum + r.executionTime, 0) / validResults.filter(r => r.wasCached).length : 0;
            const avgTimeNoCache = validResults.filter(r => !r.wasCached).length > 0 ? 
                validResults.filter(r => !r.wasCached).reduce((sum, r) => sum + r.executionTime, 0) / validResults.filter(r => !r.wasCached).length : 0;
            
            document.getElementById('successCount').textContent = successful;
            document.getElementById('failureCount').textContent = total - successful;
            document.getElementById('globalScore').textContent = percentage + '%';
            document.getElementById('globalScore').className = percentage >= 90 ? 'success' : percentage >= 70 ? 'loading' : 'failure';
            
            globalStatusEl.innerHTML = `
                <div class="${percentage >= 90 ? 'success' : percentage >= 70 ? 'loading' : 'failure'}">
                    ${percentage >= 90 ? 'üéâ' : percentage >= 70 ? '‚ö†Ô∏è' : '‚ùå'} 
                    RAPPORT CACHE: ${successful}/${total} tests r√©ussis (${percentage}%)
                </div>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    üíæ <strong>Statistiques Cache:</strong><br>
                    ‚Ä¢ Cache hits: ${cacheHits} | Cache misses: ${cacheMisses}<br>
                    ‚Ä¢ Temps moyen avec cache: ${avgTimeCache.toFixed(2)}ms<br>
                    ‚Ä¢ Temps moyen sans cache: ${avgTimeNoCache.toFixed(2)}ms<br>
                    ‚Ä¢ Gain performance: ${avgTimeNoCache > 0 ? Math.round(((avgTimeNoCache - avgTimeCache) / avgTimeNoCache) * 100) : 0}%
                </div>
            `;
            
            // V√©rification taille cache
            if (calculator && calculator.cache) {
                globalStatusEl.innerHTML += `
                    <div style="margin-top: 10px; color: #00BCD4;">
                        üóÉÔ∏è <strong>√âtat final cache:</strong> ${calculator.cache.size} entr√©es
                    </div>
                `;
            }
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
            testResults = [];
            cacheTestResults = [];
            document.getElementById('successCount').textContent = '0';
            document.getElementById('failureCount').textContent = '0';
            document.getElementById('globalScore').textContent = '0%';
            document.getElementById('globalScore').className = '';
        }

        // === INITIALISATION AUTOMATIQUE ===
        window.addEventListener('load', initializeCalculator);
    </script>
</body>
</html>