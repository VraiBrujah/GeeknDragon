<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Algorithme Simplifi√© avec Surplus</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: white; }
        .container { max-width: 900px; margin: 0 auto; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background-color: #0f5132; border: 1px solid #198754; }
        .error { background-color: #721c24; border: 1px solid #dc3545; }
        .info { background-color: #055160; border: 1px solid #0dcaf0; }
        .warning { background-color: #664d03; border: 1px solid #ffc107; }
        button { background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer; }
        button:hover { background: #5a6268; }
        .test-case { margin: 20px 0; padding: 15px; border: 1px solid #444; border-radius: 8px; }
        pre { background: #2d2d2d; padding: 10px; border-radius: 4px; overflow-x: auto; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ Test Algorithme Simplifi√© avec Surplus Autoris√©s</h1>
        <p>Verification que l'algorithme simplifi√© trouve les meilleures solutions en acceptant les surplus de pi√®ces.</p>
        
        <div id="results"></div>
        <button onclick="runAllTests()">üöÄ Lancer Tous les Tests</button>
        <button onclick="clearResults()">üóëÔ∏è Effacer</button>
    </div>

    <script>
        let dataLoaded = false;
        
        async function loadRealData() {
            try {
                const response = await fetch('/data/products.json');
                window.products = await response.json();
                dataLoaded = true;
                addResult(`‚úÖ Donn√©es r√©elles charg√©es: ${Object.keys(window.products).length} produits total`, 'success');
            } catch (error) {
                addResult(`‚ùå Erreur chargement donn√©es: ${error.message}`, 'error');
            }
        }

        function addResult(message, type = 'info') {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong>: ${message}`;
            results.appendChild(div);
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        async function runAllTests() {
            clearResults();
            addResult('üîÑ D√©marrage des tests algorithme simplifi√©...', 'info');

            // Charger les donn√©es d'abord
            if (!dataLoaded) {
                await loadRealData();
            }

            try {
                // Initialiser le recommandeur
                const recommender = new DynamicCoinRecommender();
                await new Promise(resolve => setTimeout(resolve, 1000)); // Attendre l'initialisation

                // Test cases with surplus acceptance
                const testCases = [
                    {
                        name: 'üî• CAS CRITIQUE: 1 de chaque m√©tal (devrait recommander Quintessence M√©tallique)',
                        needs: { copper: 1, silver: 1, electrum: 1, gold: 1, platinum: 1 },
                        expectedProduct: 'coin-quintessence-metallique',
                        maxCost: 40
                    },
                    {
                        name: 'üí∞ SURPLUS ACCEPTABLE: 10 cuivre (surplus OK si moins cher)',
                        needs: { copper: 10, silver: 0, electrum: 0, gold: 0, platinum: 0 },
                        maxCost: 50
                    },
                    {
                        name: 'üéØ OPTIMISATION: 2 or + 3 argent (tester combinaisons)',
                        needs: { copper: 0, silver: 3, electrum: 0, gold: 2, platinum: 0 },
                        maxCost: 80
                    },
                    {
                        name: 'üöÄ GROS VOLUME: 100 cuivre (√©conomies d\'√©chelle)',
                        needs: { copper: 100, silver: 0, electrum: 0, gold: 0, platinum: 0 },
                        maxCost: 200
                    }
                ];

                for (const testCase of testCases) {
                    addResult(`\nüìã ${testCase.name}`, 'info');
                    
                    console.log('üéØ Test case:', testCase.name, testCase.needs);
                    
                    const startTime = performance.now();
                    const recommendations = await recommender.recommend(
                        testCase.needs.copper,
                        testCase.needs.silver, 
                        testCase.needs.electrum,
                        testCase.needs.gold,
                        testCase.needs.platinum
                    );
                    const endTime = performance.now();
                    
                    addResult(`‚è±Ô∏è Temps de calcul: ${(endTime - startTime).toFixed(2)}ms`, 'info');
                    
                    if (recommendations && recommendations.length > 0) {
                        let totalPrice = 0;
                        addResult(`‚úÖ ${recommendations.length} lot(s) recommand√©(s):`, 'success');
                        
                        recommendations.forEach((rec, i) => {
                            totalPrice += rec.price * rec.quantity;
                            const productName = rec.displayName || rec.productId;
                            addResult(`   ${i+1}. ${rec.quantity}√ó ${productName} - $${(rec.price * rec.quantity).toFixed(2)}`, 'info');
                        });
                        
                        addResult(`üí∞ Prix total: $${totalPrice.toFixed(2)}`, 'success');
                        
                        // V√©rifications sp√©cifiques
                        if (testCase.expectedProduct) {
                            const hasExpected = recommendations.some(rec => rec.productId === testCase.expectedProduct);
                            if (hasExpected) {
                                addResult(`üéØ ‚úÖ Produit attendu trouv√©: ${testCase.expectedProduct}`, 'success');
                            } else {
                                addResult(`‚ö†Ô∏è Produit attendu non trouv√©: ${testCase.expectedProduct}`, 'warning');
                                addResult(`   Produits recommand√©s: ${recommendations.map(r => r.productId).join(', ')}`, 'info');
                            }
                        }
                        
                        if (testCase.maxCost && totalPrice <= testCase.maxCost) {
                            addResult(`üí∏ Prix acceptable (‚â§ $${testCase.maxCost})`, 'success');
                        } else if (testCase.maxCost) {
                            addResult(`üí∏ Prix √©lev√© ($${totalPrice.toFixed(2)} > $${testCase.maxCost})`, 'warning');
                        }
                        
                        // Analyser les surplus
                        addResult(`üîç Analyse des surplus...`, 'info');
                        const surplus = await analyzeSuprlus(recommender, recommendations, testCase.needs);
                        if (Object.keys(surplus).length > 0) {
                            const surplusDesc = Object.keys(surplus).map(metal => `${surplus[metal]} ${metal}`).join(', ');
                            addResult(`üì¶ Surplus d√©tect√©s: ${surplusDesc} (acceptable si prix r√©duit)`, 'info');
                        } else {
                            addResult(`üéØ Couverture exacte des besoins`, 'success');
                        }
                        
                    } else {
                        addResult('‚ùå Aucune recommandation g√©n√©r√©e', 'error');
                    }
                }

            } catch (error) {
                addResult(`‚ùå Erreur: ${error.message}`, 'error');
                console.error('D√©tails:', error);
            }
        }

        async function analyzeSuprlus(recommender, recommendations, needs) {
            const provided = {};
            const surplus = {};
            
            // Initialiser
            Object.keys(needs).forEach(metal => provided[metal] = 0);
            
            // Calculer ce qui est fourni
            recommendations.forEach(rec => {
                const product = recommender.products[rec.productId];
                if (product && product.coinLots) {
                    const multiplier = rec.customMultiplier || 1;
                    Object.keys(product.coinLots).forEach(metal => {
                        if (provided[metal] !== undefined) {
                            const lotData = product.coinLots[metal];
                            if (typeof lotData === 'number') {
                                provided[metal] += lotData * rec.quantity * multiplier;
                            } else if (typeof lotData === 'object') {
                                const total = Object.values(lotData).reduce((sum, count) => sum + count, 0);
                                provided[metal] += total * rec.quantity * multiplier;
                            }
                        }
                    });
                }
            });
            
            // D√©tecter les surplus
            Object.keys(needs).forEach(metal => {
                if (provided[metal] > needs[metal]) {
                    surplus[metal] = provided[metal] - needs[metal];
                }
            });
            
            return surplus;
        }
    </script>

    <script src="js/dynamic-coin-recommender.js"></script>
</body>
</html>