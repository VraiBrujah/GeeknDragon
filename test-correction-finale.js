/**
 * Test de correction finale - Cas √©lectrum + cuivre
 * Simule exactement le comportement attendu apr√®s correction
 */

console.log("üß™ TEST CORRECTION FINALE - CAS √âLECTRUM + CUIVRE");
console.log("==================================================");

// Mock complet des produits
const mockProducts = {
    "coin-custom-single": {
        "name": {"fr": "Pi√®ce personnalis√©e", "en": "Custom Coin"},
        "price": 10,
        "coin_lots": {
            "copper": {"1": 1, "10": 10, "100": 100, "1000": 1000, "10000": 10000},
            "silver": {"1": 1, "10": 10, "100": 100, "1000": 1000, "10000": 10000},
            "electrum": {"1": 1, "10": 10, "100": 100, "1000": 1000, "10000": 10000},
            "gold": {"1": 1, "10": 10, "100": 100, "1000": 1000, "10000": 10000},
            "platinum": {"1": 1, "10": 10, "100": 100, "1000": 1000, "10000": 10000}
        }
    },
    "coin-trio-customizable": {
        "name": {"fr": "Trio de pi√®ces", "en": "Trio of Coins"},
        "price": 25,
        "coin_lots": {
            "copper": {"1": 3, "10": 30, "100": 300},
            "silver": {"1": 3, "10": 30, "100": 300},
            "electrum": {"1": 3, "10": 30, "100": 300},
            "gold": {"1": 3, "10": 30, "100": 300},
            "platinum": {"1": 3, "10": 30, "100": 300}
        }
    },
    "coin-quintessence-metals": {
        "name": {"fr": "Quintessence M√©tallique", "en": "Metallic Quintessence"},
        "price": 35,
        "fixed_content": {
            "copper_1": 1,
            "silver_1": 1,
            "electrum_1": 1,
            "gold_1": 1,
            "platinum_1": 1
        }
    }
};

// Simulation compl√®te de CoinLotOptimizer avec corrections
class CorrectedCoinLotOptimizer {
    constructor() {
        this.DEBUG_MODE = true;
        this.rates = {copper: 1, silver: 10, electrum: 50, gold: 100, platinum: 1000};
        this.multipliers = [1, 10, 100, 1000, 10000];
        this.products = mockProducts;
    }

    debugLog(...args) {
        console.log(...args);
    }

    // G√©n√©ration des variations (simplifi√©e)
    generateAllProductVariations() {
        const variations = [];

        // Pi√®ces personnalis√©es
        Object.entries(this.rates).forEach(([metal, rate]) => {
            this.multipliers.forEach(mult => {
                const key = `${metal}_${mult}`;
                variations.push({
                    productId: 'coin-custom-single',
                    type: 'normal',
                    name: `Pi√®ce personnalis√©e ${metal} √ó${mult}`,
                    price: this.products['coin-custom-single'].price,
                    metal, multiplier: mult,
                    capacity: { [key]: 1 }
                });
            });
        });

        // Quintessence M√©tallique (5 variations par multiplicateur)
        this.multipliers.forEach(mult => {
            const capacity = {};
            Object.keys(this.rates).forEach(metal => {
                const key = `${metal}_${mult}`;
                capacity[key] = 1;
            });

            variations.push({
                productId: 'coin-quintessence-metals',
                type: 'quintessence',
                name: `Quintessence M√©tallique √ó${mult}`,
                price: this.products['coin-quintessence-metals'].price,
                multiplier: mult,
                capacity
            });
        });

        return variations;
    }

    // Logique anti-gaspillage (copi√©e)
    isWastefulSolution(variation, needs, quantity) {
        if (variation.type === 'quintessence') {
            const neededMetals = Object.keys(needs).map(key => key.split('_')[0]);
            const uniqueMetals = [...new Set(neededMetals)];

            if (uniqueMetals.length <= 2) {
                this.debugLog(`üö´ Anti-gaspillage: Quintessence rejet√©e (${uniqueMetals.length} m√©taux vs 5 fournis)`);
                return true;
            }

            const totalNeeded = Object.values(needs).reduce((sum, qty) => sum + qty, 0);
            if (totalNeeded <= 3 && uniqueMetals.length <= 2) {
                this.debugLog(`üö´ Anti-gaspillage: Quintessence rejet√©e (${totalNeeded} pi√®ces, ${uniqueMetals.length} m√©taux)`);
                return true;
            }
        }

        const totalProvided = Object.values(variation.capacity).reduce((sum, cap) => sum + cap * quantity, 0);
        const totalNeeded = Object.values(needs).reduce((sum, needed) => sum + needed, 0);
        const wasteRatio = (totalProvided - totalNeeded) / totalProvided;

        if (wasteRatio > 0.7) {
            this.debugLog(`üö´ Anti-gaspillage: ${variation.name} rejet√© (${Math.round(wasteRatio * 100)}% gaspillage)`);
            return true;
        }

        return false;
    }

    canCoverWithQuantity(variation, needs, quantity) {
        const coverage = {};
        Object.entries(variation.capacity).forEach(([coinKey, capacity]) => {
            coverage[coinKey] = capacity * quantity;
        });

        return Object.entries(needs).every(([coinKey, needed]) => {
            const covered = coverage[coinKey] || 0;
            return needed <= covered;
        });
    }

    // Algorithme principal simplifi√©
    findOptimalProductCombination(needs) {
        this.debugLog('üéØ Recherche solution optimale pour:', needs);

        const variations = this.generateAllProductVariations();
        const solutions = [];

        // Test solutions simples avec anti-gaspillage
        variations.forEach(variation => {
            if (this.canCoverWithQuantity(variation, needs, 1)) {
                if (this.isWastefulSolution(variation, needs, 1)) {
                    return; // Skip cette variation
                }

                solutions.push({
                    products: [{
                        id: variation.productId,
                        name: variation.name,
                        quantity: 1,
                        price: variation.price
                    }],
                    totalCost: variation.price,
                    type: variation.type
                });

                this.debugLog(`‚úÖ Solution: ${variation.name} - $${variation.price}`);
            }
        });

        // Si aucune solution compl√®te, cr√©er solution par pi√®ces individuelles
        if (solutions.length === 0) {
            this.debugLog('üîÑ Aucune solution compl√®te - g√©n√©ration solution par pi√®ces individuelles');
            const individualProducts = [];
            let totalCost = 0;

            Object.entries(needs).forEach(([coinKey, quantity]) => {
                const [metal, mult] = coinKey.split('_');
                const individualVariation = variations.find(v =>
                    v.type === 'normal' && v.metal === metal && v.multiplier === parseInt(mult)
                );

                if (individualVariation) {
                    individualProducts.push({
                        id: individualVariation.productId,
                        name: individualVariation.name,
                        quantity: quantity,
                        price: individualVariation.price
                    });
                    totalCost += individualVariation.price * quantity;
                    this.debugLog(`  + ${quantity}x ${individualVariation.name} ($${individualVariation.price})`);
                }
            });

            if (individualProducts.length > 0) {
                this.debugLog(`üèÜ Solution par pi√®ces individuelles: $${totalCost}`);
                return individualProducts;
            }

            this.debugLog('‚ùå Aucune solution trouv√©e');
            return [];
        }

        const optimal = solutions.reduce((best, current) =>
            current.totalCost < best.totalCost ? current : best
        );

        this.debugLog(`üèÜ Solution optimale: ${optimal.type} - $${optimal.totalCost}`);
        return optimal.products;
    }
}

// Test du cas probl√©matique
function testProblematicCase() {
    console.log("\nüéØ TEST: 1 √©lectrum + 1 cuivre (cas probl√©matique)");
    console.log("-".repeat(50));

    const optimizer = new CorrectedCoinLotOptimizer();
    const needs = { electrum_1: 1, copper_1: 1 };

    const result = optimizer.findOptimalProductCombination(needs);

    console.log("\nüìä R√âSULTAT:");
    if (result.length === 0) {
        console.log("‚ùå Aucune solution trouv√©e");
        return false;
    }

    let hasQuintessence = false;
    result.forEach(product => {
        console.log(`  - ${product.name}: $${product.price}`);
        if (product.name.toLowerCase().includes('quintessence')) {
            hasQuintessence = true;
        }
    });

    const totalCost = result.reduce((sum, p) => sum + p.price * p.quantity, 0);
    console.log(`  Total: $${totalCost}`);

    console.log(`\nüéØ VALIDATION:`);
    console.log(`  Quintessence recommand√©e: ${hasQuintessence ? '‚ùå OUI' : '‚úÖ NON'}`);
    console.log(`  Co√ªt raisonnable: ${totalCost <= 25 ? '‚úÖ OUI' : '‚ùå NON'}`);

    const success = !hasQuintessence && totalCost <= 25;
    console.log(`  R√©sultat global: ${success ? '‚úÖ SUCC√àS' : '‚ùå √âCHEC'}`);

    return success;
}

// Test de validation avec diff√©rents cas
function testMultipleCases() {
    console.log("\nüß™ TESTS MULTIPLES");
    console.log("==================");

    const testCases = [
        {
            name: "1 √©lectrum + 1 cuivre",
            needs: { electrum_1: 1, copper_1: 1 },
            expectNoQuintessence: true
        },
        {
            name: "1 or + 1 argent",
            needs: { gold_1: 1, silver_1: 1 },
            expectNoQuintessence: true
        },
        {
            name: "4 m√©taux diff√©rents",
            needs: { platinum_1: 1, gold_1: 1, electrum_1: 1, silver_1: 1 },
            expectNoQuintessence: false // Quintessence acceptable ici
        }
    ];

    const optimizer = new CorrectedCoinLotOptimizer();
    let allPassed = true;

    testCases.forEach((testCase, i) => {
        console.log(`\n${i+1}. ${testCase.name}:`);
        const result = optimizer.findOptimalProductCombination(testCase.needs);

        const hasQuintessence = result.some(p => p.name.toLowerCase().includes('quintessence'));
        const passed = testCase.expectNoQuintessence ? !hasQuintessence : true;

        console.log(`   Quintessence: ${hasQuintessence ? 'OUI' : 'NON'} - ${passed ? '‚úÖ' : '‚ùå'}`);

        if (!passed) allPassed = false;
    });

    console.log(`\nüéØ R√âSULTAT GLOBAL: ${allPassed ? '‚úÖ TOUS TESTS PASS√âS' : '‚ùå √âCHECS D√âTECT√âS'}`);
    return allPassed;
}

// Ex√©cution principale
console.log("D√©marrage des tests de correction...\n");

const mainTestPassed = testProblematicCase();
const multipleTestsPassed = testMultipleCases();

const overallSuccess = mainTestPassed && multipleTestsPassed;

console.log("\n" + "=".repeat(60));
console.log(`üèÅ CONCLUSION: ${overallSuccess ? '‚úÖ CORRECTION VALID√âE' : '‚ùå CORRECTION INSUFFISANTE'}`);

if (overallSuccess) {
    console.log("‚úÖ La logique anti-gaspillage fonctionne correctement");
    console.log("‚úÖ Quintessence n'est plus forc√©e pour des besoins simples");
    console.log("‚úÖ Recommandations √©conomiquement coh√©rentes");
} else {
    console.log("‚ùå Des probl√®mes persistent dans l'algorithme");
}

process.exit(overallSuccess ? 0 : 1);